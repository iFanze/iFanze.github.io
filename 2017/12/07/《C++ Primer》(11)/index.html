<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="孟凡泽的博客"><title>《C++ Primer》读书笔记 11 | Meng Fanze's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《C++ Primer》读书笔记 11</h1><a id="logo" href="/.">Meng Fanze's Blog</a><p class="description">C++、Web、Game</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《C++ Primer》读书笔记 11</h1><div class="post-meta">Dec 7, 2017<span> | </span><span class="category"><a href="/categories/《C-Primer》/">《C++ Primer》</a></span></div><a class="disqus-comment-count" href="/2017/12/07/《C++ Primer》(11)/#vcomment"><span class="valine-comment-count" data-xid="/2017/12/07/《C++ Primer》(11)/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章-关联容器"><span class="toc-text">第十一章 关联容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-1-使用关联容器"><span class="toc-text">11.1 使用关联容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-2-关联容器概述"><span class="toc-text">11.2 关联容器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-1-定义关联容器"><span class="toc-text">11.2.1 定义关联容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-2-关键字类型的要求"><span class="toc-text">11.2.2 关键字类型的要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-3-pair-类型"><span class="toc-text">11.2.3 pair 类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-3-关联容器操作"><span class="toc-text">11.3 关联容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-1-关联容器迭代器"><span class="toc-text">11.3.1 关联容器迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-2-添加元素"><span class="toc-text">11.3.2 添加元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-3-删除元素"><span class="toc-text">11.3.3 删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-4-map-的下标操作"><span class="toc-text">11.3.4 map 的下标操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-5-访问元素"><span class="toc-text">11.3.5 访问元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-6-一个单词转换的-map"><span class="toc-text">11.3.6 一个单词转换的 map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-4-无序容器"><span class="toc-text">11.4 无序容器</span></a></li></ol></div></div><div class="post-content"><p>《C++ Primer》读书笔记 第十一章 关联容器</p>
<a id="more"></a>
<!-- toc -->
<h1 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="headerlink" title="第十一章 关联容器"></a>第十一章 关联容器</h1><p>2 <em> 2 </em> 2 = 8种：</p>
<ul>
<li><code>set</code>、<code>map</code></li>
<li><code>multi</code>：允许重复关键字（定义在<code>&lt;map&gt;</code>、<code>&lt;set&gt;</code>）</li>
<li><code>unordered</code>：无序保存（定义在<code>unordered_map</code>、<code>unordered_set</code>）</li>
</ul>
<h1 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h1><p>基本使用。</p>
<h1 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h1><h2 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h2><h2 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h2><p>有序容器需要关键字类型支持<strong>行为正常</strong>的比较操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn)*&gt; bookstore(compareIsbn);    <span class="comment">// 后面的 compareIsbn 可以换成 &amp;compareIsbn</span></span><br></pre></td></tr></table></figure>
<p>注意：用 decltype 来获得一个函数指针类型时，必须加上一个<code>*</code>指出我们要得到的是函数的指针。</p>
<h2 id="11-2-3-pair-类型"><a href="#11-2-3-pair-类型" class="headerlink" title="11.2.3 pair 类型"></a>11.2.3 pair 类型</h2><p>在<code>&lt;utility&gt;</code>中。</p>
<p><img src="http://static.ifanze.cn/2018-06-23-15126508707740.jpg" alt=""></p>
<p>如果函数返回 pair：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; process(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;;     <span class="comment">// 列表初始化（C++11）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;();             <span class="comment">// 隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(v.back(), v.back().size());</span><br><span class="line"><span class="keyword">return</span> make_pair(v.back(), v.back().size());</span><br></pre></td></tr></table></figure>
<h1 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h1><p><img src="http://static.ifanze.cn/2018-06-23-15126510682571.jpg" alt=""></p>
<h2 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h2><ul>
<li>关键字类型（包括 pair 的 first）是 const 的。</li>
<li>对 map 解引用得到的类型是 value_type，是个 pair。</li>
<li>set 的 iterator 和 const_iterator 都是只读的，不能改变 set 的元素。</li>
<li>通常不对关联容器使用泛型算法，关键字是 const 这一特性使得算法不能对容器进行修改或重排。关联容器可用于只读算法，如 find，但还是优先使用成员函数版本。</li>
<li>实际使用中，若是用在泛型算法上，要么当作一个源序列，要么当作一个目标位置（使用 inserter）。</li>
</ul>
<h2 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1.insert(ivec.cbegin(), ivec.cend());</span><br><span class="line">set1.insert(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">map1.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">map1.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">map1.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">map1.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><img src="http://static.ifanze.cn/2018-06-23-15126518693490.jpg" alt=""></p>
<p>对于不返回重复关键字的容器，这些函数返回一个 pair，其 first 是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出是插入成功还是已经存在于容器。</p>
<p>一个单词计数的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.second)</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>auto 的类型是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;map&lt;string, size_t&gt;::iterator, bool&gt;</span><br></pre></td></tr></table></figure>
<p>注意，对于<code>mutiset</code>和<code>multimap</code>，一定会插入成功，因此只返回迭代器。</p>
<h2 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15128849829768.jpg" alt=""></p>
<h2 id="11-3-4-map-的下标操作"><a href="#11-3-4-map-的下标操作" class="headerlink" title="11.3.4 map 的下标操作"></a>11.3.4 map 的下标操作</h2><p>如果关键字不在 map vs ,下标运算符会创建一个元素并插入到 map 中，并进行值初始化。所以，我们只能对非 const 的 map 使用下标操作。</p>
<p><img src="http://static.ifanze.cn/2018-06-23-15128851559984.jpg" alt=""></p>
<p>注意在 map 中，下标操作的返回值和对迭代器进行解引用不一样。前者是 mapped_type，后者是 value_type。但相同的一点是都是左值。</p>
<h2 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15128852997668.jpg" alt=""></p>
<p>注意：lower_bound 和 upper_bound 不适用于无序容器。下标和 at 只适用于非 const 的 map 和 unordered_map。</p>
<p>不能用下标运算符来检查一个元素是否存在！</p>
<p>如果是在 multimap 或 multiset 查找给定关键字，有三种方法（它们一定是连续存储的）：</p>
<ol>
<li>find 和 count：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> count = map1.count(key);</span><br><span class="line"><span class="keyword">auto</span> iter  = map1.find (key);</span><br><span class="line"><span class="keyword">while</span>(count)&#123;</span><br><span class="line">    count &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++iter;</span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>迭代器组：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = map1.lower_bound(key),</span><br><span class="line">          end = map1.upper_bound(key);</span><br><span class="line">     beg != end;</span><br><span class="line">     ++beg)</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>equal_range函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = map1.equal_range(key);</span><br><span class="line">     pos.first != pos.second;</span><br><span class="line">     ++pos.first)</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-6-一个单词转换的-map"><a href="#11-3-6-一个单词转换的-map" class="headerlink" title="11.3.6 一个单词转换的 map"></a>11.3.6 一个单词转换的 map</h2><h1 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h1><p>无序容器使用一个哈希函数将元素映射到桶。<br><img src="http://static.ifanze.cn/2018-06-23-15128859821311.jpg" alt=""></p>
<p>无序容器对关键字类型使用<code>==</code>比较元素，还使用<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型，还有string和智能指针等标准库类型定义了hash。</p>
<p>但是，我们不能定义关键字类型为自定义类类型的无序容器。必须提供自己的 hash 模版。<em>16.5</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> hasher(<span class="keyword">const</span> Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(haser)*, <span class="keyword">decltype</span>(eqOp)* &gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经定义了 == 运算符，则只重载哈希函数：</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;Foo, <span class="keyword">decltype</span>(FooHash)* &gt; fooSet(<span class="number">10</span>, FooHash);</span><br></pre></td></tr></table></figure>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Meng Fanze</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2017/12/07/《C++ Primer》(11)/">http://ifanze.cn/2017/12/07/《C++ Primer》(11)/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请在评论区说明。</li></ul></div><br><div class="tags"><a href="/tags/C/">C++</a><a href="/tags/读书/">读书</a></div><div class="post-nav"><a class="pre" href="/2017/12/10/《C++ Primer》(12)/">《C++ Primer》读书笔记 12</a><a class="next" href="/2017/12/03/《C++ Primer》(10)/">《C++ Primer》读书笔记 10</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'kfIuT7r4gG6hnmNl3uQ5vOqp-gzGzoHsz',
  appKey:'59tx3uBM3K1Ao4JFH5oE3VEK',
  placeholder:'Welcome~',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ifanze.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/《C-Primer》/">《C++ Primer》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《代码大全2》/">《代码大全2》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《深入理解计算机系统》/">《深入理解计算机系统》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/参考/" style="font-size: 15px;">参考</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/coding/" style="font-size: 15px;">coding</a> <a href="/tags/libevent/" style="font-size: 15px;">libevent</a> <a href="/tags/python/" style="font-size: 15px;">python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ifanze.cn" title="欢迎友链～" target="_blank">欢迎友链～</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Meng Fanze's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script type="text/javascript" src="/js/fanze.js?v=0.0.0"></script></div></body></html>