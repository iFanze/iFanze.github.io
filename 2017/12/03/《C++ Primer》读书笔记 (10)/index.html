<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="孟凡泽的博客"><title>《C++ Primer》读书笔记 10 | Meng Fanze's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《C++ Primer》读书笔记 10</h1><a id="logo" href="/.">Meng Fanze's Blog</a><p class="description">C++、Web、Game</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《C++ Primer》读书笔记 10</h1><div class="post-meta">Dec 3, 2017<span> | </span><span class="category"><a href="/categories/《C-Primer》/">《C++ Primer》</a></span></div><a class="disqus-comment-count" href="/2017/12/03/《C++ Primer》读书笔记 (10)/#vcomment"><span class="valine-comment-count" data-xid="/2017/12/03/《C++ Primer》读书笔记 (10)/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章-泛型算法"><span class="toc-text">第十章 泛型算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-概述"><span class="toc-text">10.1 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-初识泛型算法"><span class="toc-text">10.2 初识泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-1-只读算法"><span class="toc-text">10.2.1 只读算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-2-写容器元素的算法"><span class="toc-text">10.2.2 写容器元素的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-3-重排容器元素的算法"><span class="toc-text">10.2.3 重排容器元素的算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-3-定制操作"><span class="toc-text">10.3 定制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-1-向算法传递函数"><span class="toc-text">10.3.1 向算法传递函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-2-lambda-表达式"><span class="toc-text">10.3.2 lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-3-lambda-捕获和返回"><span class="toc-text">10.3.3 lambda 捕获和返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-4-参数绑定"><span class="toc-text">10.3.4 参数绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-4-再探迭代器"><span class="toc-text">10.4 再探迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-1-插入迭代器"><span class="toc-text">10.4.1 插入迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-2-iostream-迭代器"><span class="toc-text">10.4.2 iostream 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-3-反向迭代器"><span class="toc-text">10.4.3 反向迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-5-泛型算法结构"><span class="toc-text">10.5 泛型算法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-1-5类迭代器"><span class="toc-text">10.5.1 5类迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-2-算法形参模式"><span class="toc-text">10.5.2 算法形参模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-3-算法命名规范"><span class="toc-text">10.5.3 算法命名规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-6-特定容器算法"><span class="toc-text">10.6 特定容器算法</span></a></li></ol></div></div><div class="post-content"><p>《C++ Primer》读书笔记 第十章 泛型算法</p>
<a id="more"></a>
<!-- toc -->
<h1 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h1><h1 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h1><ul>
<li>定义在<code>&lt;algorithm&gt;</code>、<code>&lt;numeric&gt;</code>。</li>
<li>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，一般不会改变底层容器的大小。</li>
</ul>
<h1 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h1><h2 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h2><p>find、count、accumulate、equal。</p>
<p>其中，accumulate 是累加，第三个参数是初始值，需要支持 <code>+</code> 运算。equal 操作两个序列，比较指定范围内的元素是否都相等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="built_in">string</span>(<span class="string">""</span>));  <span class="comment">// 不能改成""</span></span><br></pre></td></tr></table></figure>
<h2 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h2><p>注意确保序列原大小至少不小于我们要求写入的元素数目。</p>
<p>操作两个序列时，有些接受三个迭代器，有些接受四个。</p>
<p><code>fill</code>函数：在指定位置之间填充指定值。<br><code>fill_n</code>函数：从指定位置开始填充指定数量的指定值。注意空间够不够。<br><code>copy</code>函数：<br><code>replace</code>函数：<br><code>replace_copy</code>函数：</p>
<p>插入迭代器：向插入迭代器所指元素赋值将插入新值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">0</span>);         <span class="comment">// 错误</span></span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">replace(ilst.begin(), ilst.end(), <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line">replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h2 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h2><ul>
<li><code>sort</code>函数：排列。</li>
<li><code>unique</code>函数：排列使不重复的元素出现在前面，返回第一个出现重复的元素的位置。（标准库算法是对迭代器而不是容器进行操作。）</li>
</ul>
<h1 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h1><h2 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h2><p>给 sort 等函数多传递一个参数，称作谓词（predicate）：它是一个可调用的表达式，其返回结果是一个能用作条件的值。</p>
<p>稳定排序：<code>stable_sort</code>。</p>
<h2 id="10-3-2-lambda-表达式"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式</h2><p><code>find_if</code>函数：第三个参数是一个谓词，返回第一个使谓词返回 true 的元素，否则返回尾迭代器。</p>
<p>可调用对象包括：</p>
<ul>
<li>函数</li>
<li>函数指针</li>
<li>重载了函数调用运算符的类</li>
<li>lambda 表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>其中，捕获列表是一个 lambda 所在函数中定义的局部变量的列表（通常为空）。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。</p>
<p>如果函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b) &#123; <span class="keyword">return</span> a.size() &lt; b.size(); &#125; );</span><br></pre></td></tr></table></figure>
<p>如果 lambda 表达式还用到它所在函数中的局部非静态变量，必须将它写在捕获列表中。所以 find_if 可以写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">            [sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)</span><br><span class="line">                &#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>
<p><code>for_each</code>算法：接受一个可调用对象，对输入序列中每个元素调用此对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="10-3-3-lambda-捕获和返回"><a href="#10-3-3-lambda-捕获和返回" class="headerlink" title="10.3.3 lambda 捕获和返回"></a>10.3.3 lambda 捕获和返回</h2><p>变量的捕获方式也可以是值或引用。被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();       <span class="comment">// j 为 42</span></span><br></pre></td></tr></table></figure>
<p>以引用方式捕获：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();       <span class="comment">// j 为 0</span></span><br></pre></td></tr></table></figure>
<p>引用捕获和返回引用一样，要确保被引用对象在 lambda 执行的时候是存在的。</p>
<p>当我们向一个函数传递一个 lambda 时，lambda 会立即执行。</p>
<p>我们也可以返回一个 lambda，但注意不能包含引用捕获。</p>
<p>尽量减少捕获的数据量，尽量避免捕获指针或引用。</p>
<p>可以使用<code>&amp;</code>或<code>=</code>表示隐式捕获，也可以混用隐式捕获和显式捕获。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[=]&#123;<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br><span class="line">[=, &amp;os](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>
<p><img src="http://static.ifanze.cn/2018-06-23-15124918050273.jpg" alt=""></p>
<p>如果希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++i; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();   <span class="comment">// j 为 43</span></span><br></pre></td></tr></table></figure>
<p><code>transform</code>算法：将一个序列的元素依次做一个转化，放到另一个指定位置开始的序列中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), vi.begin(),</span><br><span class="line">            [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span></span><br><span class="line">            &#123; <span class="keyword">if</span> ( i &lt; <span class="number">0</span> ) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h2><p>lambda 表达式适合使用次数少、代码少的应用场景，取代函数。但是不能直接把捕获列表作为谓词的参数放到函数的形参中。</p>
<p>解决方法：使用<code>&lt;functional&gt;</code>中定义的<code>bind</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">                bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure>
<p>其中，<code>_1</code>是占位符。更一般的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _2, c, _1);</span><br><span class="line"></span><br><span class="line">g(X, Y);</span><br><span class="line">f(a, b, Y, c, X);</span><br></pre></td></tr></table></figure>
<p>如果需要绑定引用，使用<code>ref</code>或<code>cref</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.begin(), words.end(),</span><br><span class="line">            bind(print, ref(os), _1, <span class="string">' '</span>));</span><br></pre></td></tr></table></figure>
<p>旧版本的 bind1st 和 bind2nd 应被弃用。</p>
<h1 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h1><p><iterator> 中还定义了：</p>
<ul>
<li>插入迭代器。</li>
<li>流迭代器。</li>
<li>反向迭代器。</li>
<li>移动迭代器。</li>
</ul>
<h2 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h2><p><img src="http://static.ifanze.cn/2018-06-23-15124937743666.jpg" alt=""></p>
<p>三种类型：</p>
<ul>
<li><code>back_inserter</code>：创建一个使用 push_back 的迭代器。</li>
<li><code>front_inserter</code>：创建一个使用 push_front 的迭代器。</li>
<li><code>inserter</code>：创建一个使用 inserter 的迭代器，此函数接受第二个参数表示位置，元素被插入到它之前。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">//inserter 插入迭代器相当于：</span></span><br><span class="line">it = c.insert(it, val);     <span class="comment">// 指向新加入的元素</span></span><br><span class="line">++it;                       <span class="comment">// 指回原来的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line">copy(lst.cbegin(), lst.cend(), front_inserter(list2));  <span class="comment">// 4,3,2,1，始终指向新首元素。</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));   <span class="comment">// 1,2,3,4</span></span><br></pre></td></tr></table></figure>
<h2 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h2><ul>
<li><code>istream_iterator</code>要读写的类型必须定义了<code>&gt;&gt;</code>。</li>
<li><code>ostream_iterator</code>要读写的类型必须定义了<code>&lt;&lt;</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造1：使用流</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_it(<span class="built_in">cin</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"afile"</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; str_it(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造2：默认初始化</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof;          <span class="comment">// 可得到尾后迭代器，一旦到文件尾或者IO错误，迭代器就与之相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法1: 从流中读内容</span></span><br><span class="line"><span class="keyword">while</span> (int_it != int_eof)</span><br><span class="line">    ivec.push_back(*in_it++);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法2: 两个迭代器结合用来构造容器</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>), eof;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(in_iter, eof);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法3：算法中使用</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in(<span class="built_in">cin</span>), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><img src="http://static.ifanze.cn/2018-06-23-15126478937848.jpg" alt=""></p>
<p>注意：标准库不保证迭代器立即从流读取数据，允许使用懒惰求值，只保证在第一次解引用前完成从流中读数据的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 用法1：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    out_iter = e;   <span class="comment">// 等效于 *out_iter++ = e;，但推荐别简写。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用法2：</span></span><br><span class="line">copy(vec.begin(), vec.end(), out_iter);</span><br></pre></td></tr></table></figure>
<h2 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h2><ul>
<li><code>rbegin</code>、<code>rend</code>、<code>crbegin</code>、<code>crend</code>。</li>
<li>反响迭代器需要<code>--</code>运算符。</li>
<li>可以调用<code>base()</code>转化成正常迭代器。</li>
</ul>
<p><img src="http://static.ifanze.cn/2018-06-23-15126482760762.jpg" alt=""></p>
<h1 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h1><h2 id="10-5-1-5类迭代器"><a href="#10-5-1-5类迭代器" class="headerlink" title="10.5.1 5类迭代器"></a>10.5.1 5类迭代器</h2><p><img src="http://static.ifanze.cn/2018-06-23-15126484658475.jpg" alt=""></p>
<h2 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg(beg, end, ...);</span><br><span class="line">alg(beg, end, dest, ...);</span><br><span class="line">alg(beg, end, beg2, ...);</span><br><span class="line">alg(beg, end, beg2, end2, ...);</span><br></pre></td></tr></table></figure>
<h2 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h2><p>重载一个谓词：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end);</span><br><span class="line">unique(beg, end, comp);</span><br></pre></td></tr></table></figure>
<p>_if 版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val);</span><br><span class="line">find_if(beg, end, pred);</span><br></pre></td></tr></table></figure>
<p>区分拷贝不拷贝的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end);</span><br><span class="line">reverse_copy(beg, end, dest);</span><br></pre></td></tr></table></figure>
<p>同时包含上面两点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remove_if(beg, end, pred);</span><br><span class="line">remove_copy_if(beg, end, dest, pred);</span><br></pre></td></tr></table></figure>
<h1 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h1><p>list 和 forward_list 还定义了：</p>
<p><img src="http://static.ifanze.cn/2018-06-23-15126493120661.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15126493216728.jpg" alt=""></p>
<p>通用版本的 sort 要求随机访问迭代器，不能用于它们。list 和 forward_list 应优先使用成员函数版本的算法。</p>
<p>另外还有<code>splice</code>成员：<br><img src="http://static.ifanze.cn/2018-06-23-15126493931751.jpg" alt=""></p>
<p>有些链表版本的算法与通用版本有区别，主要是会改变底层结构。包括<code>remove</code>、<code>unique</code>、<code>merge</code>、<code>splice</code>。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Meng Fanze</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2017/12/03/《C++ Primer》读书笔记 (10)/">http://ifanze.cn/2017/12/03/《C++ Primer》读书笔记 (10)/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请在评论区说明。</li></ul></div><br><div class="tags"><a href="/tags/C/">C++</a><a href="/tags/读书/">读书</a></div><div class="post-nav"><a class="pre" href="/2017/12/07/《C++ Primer》读书笔记 (11)/">《C++ Primer》读书笔记 11</a><a class="next" href="/2017/12/03/《C++ Primer》读书笔记 (9)/">《C++ Primer》读书笔记 9</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'kfIuT7r4gG6hnmNl3uQ5vOqp-gzGzoHsz',
  appKey:'59tx3uBM3K1Ao4JFH5oE3VEK',
  placeholder:'Welcome~',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ifanze.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/《C-Primer》/">《C++ Primer》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/homebrew/" style="font-size: 15px;">homebrew</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/libevent/" style="font-size: 15px;">libevent</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/python/" style="font-size: 15px;">python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ifanze.cn" title="欢迎友链～" target="_blank">欢迎友链～</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Meng Fanze's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>