<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="孟凡泽的博客"><title>Python 学习笔记 | Meng Fanze's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python 学习笔记</h1><a id="logo" href="/.">Meng Fanze's Blog</a><p class="description">C++、Web、Game</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python 学习笔记</h1><div class="post-meta">May 9, 2016<span> | </span><span class="category"><a href="/categories/笔记/">笔记</a></span></div><a class="disqus-comment-count" href="/2016/05/09/Python学习笔记/#vcomment"><span class="valine-comment-count" data-xid="/2016/05/09/Python学习笔记/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python简介"><span class="toc-text">Python简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装Python"><span class="toc-text">安装Python</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一个Python程序"><span class="toc-text">第一个Python程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#输出"><span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#输入"><span class="toc-text">输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python基础"><span class="toc-text">Python基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#除法"><span class="toc-text">除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串和编码"><span class="toc-text">字符串和编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编码常识"><span class="toc-text">编码常识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串和编码转换"><span class="toc-text">字符串和编码转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源代码的编码"><span class="toc-text">源代码的编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的格式化"><span class="toc-text">字符串的格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的不可变性"><span class="toc-text">字符串的不可变性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用list和tuple"><span class="toc-text">使用list和tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件判断"><span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用dict和set"><span class="toc-text">使用dict和set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义函数"><span class="toc-text">定义函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导入函数"><span class="toc-text">导入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空函数"><span class="toc-text">空函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查参数类型"><span class="toc-text">检查参数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回多个值"><span class="toc-text">返回多个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数参数"><span class="toc-text">函数参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#默认参数：同C语言，如果只是指定个别的默认参数，可以这样写："><span class="toc-text">默认参数：同C语言，如果只是指定个别的默认参数，可以这样写：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变参数"><span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关键字参数"><span class="toc-text">关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名关键字参数"><span class="toc-text">命名关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数组合"><span class="toc-text">参数组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归函数"><span class="toc-text">递归函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高级特性"><span class="toc-text">高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#切片"><span class="toc-text">切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代"><span class="toc-text">迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#列表生成式（List-Comprehensions）"><span class="toc-text">列表生成式（List Comprehensions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成器（generator）"><span class="toc-text">生成器（generator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器（Iterator）"><span class="toc-text">迭代器（Iterator）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程"><span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#高阶函数"><span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map-reduce"><span class="toc-text">map/reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sorted"><span class="toc-text">sorted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回函数"><span class="toc-text">返回函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用闭包的注意事项"><span class="toc-text">使用闭包的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名函数"><span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#偏函数"><span class="toc-text">偏函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块"><span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用模块"><span class="toc-text">使用模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三方模块"><span class="toc-text">第三方模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象编程"><span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问限制"><span class="toc-text">访问限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承和多态"><span class="toc-text">继承和多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取对象信息"><span class="toc-text">获取对象信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例属性和类属性"><span class="toc-text">实例属性和类属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象高级编程"><span class="toc-text">面向对象高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用slots"><span class="toc-text">使用slots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-property"><span class="toc-text">使用@property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重继承"><span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定制类"><span class="toc-text">定制类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#str"><span class="toc-text">__str__()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#repr"><span class="toc-text">__repr__()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iter"><span class="toc-text">__iter__</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getitem"><span class="toc-text">__getitem__()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getattr"><span class="toc-text">__getattr__()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call"><span class="toc-text">__call__()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用枚举类"><span class="toc-text">使用枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用元类"><span class="toc-text">使用元类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用type-动态创建类"><span class="toc-text">使用type()动态创建类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用metaclass控制类的创建行为"><span class="toc-text">使用metaclass控制类的创建行为</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误、调试、测试"><span class="toc-text">错误、调试、测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试"><span class="toc-text">调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单元测试"><span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档测试"><span class="toc-text">文档测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO编程"><span class="toc-text">IO编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件读写"><span class="toc-text">文件读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringIO和BytesIO"><span class="toc-text">StringIO和BytesIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringIO"><span class="toc-text">StringIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BytesIO"><span class="toc-text">BytesIO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作文件和目录"><span class="toc-text">操作文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化（pickling）"><span class="toc-text">序列化（pickling）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程"><span class="toc-text">多进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多进程对比多线程"><span class="toc-text">多进程对比多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分布式进程"><span class="toc-text">分布式进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式"><span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式的应用"><span class="toc-text">正则表达式的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用内建模块"><span class="toc-text">常用内建模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#datetime"><span class="toc-text">datetime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collections"><span class="toc-text">collections</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#namedtuple"><span class="toc-text">namedtuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defaultdict"><span class="toc-text">defaultdict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OrderedDict"><span class="toc-text">OrderedDict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Counter"><span class="toc-text">Counter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#base64"><span class="toc-text">base64</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct"><span class="toc-text">struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashlib"><span class="toc-text">hashlib</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itertools"><span class="toc-text">itertools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML"><span class="toc-text">XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTMLParser"><span class="toc-text">HTMLParser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#urllib"><span class="toc-text">urllib</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GET"><span class="toc-text">GET</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Post"><span class="toc-text">Post</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handler"><span class="toc-text">Handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用第三方模块"><span class="toc-text">常用第三方模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PIL（Python-Imaging-Library）"><span class="toc-text">PIL（Python Imaging Library）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtualenv"><span class="toc-text">virtualenv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图形界面"><span class="toc-text">图形界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络编程"><span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP编程"><span class="toc-text">TCP编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP编程："><span class="toc-text">UDP编程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#电子邮件"><span class="toc-text">电子邮件</span></a></li></ol></div></div><div class="post-content"><p>“廖雪峰的官方网站 - Python教程”的阅读笔记。</p>
<a id="more"></a>
<!-- toc -->
<h2 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h2><ul>
<li><p>C语言是可以用来编写操作系统的贴近硬件的语言，适合开发那些追求运行速度、充分发挥硬件性能的程序。</p>
</li>
<li><p>Python是用来编写应用程序的高级编程语言，有大量基础库和第三方库可直接使用。适合：</p>
<ul>
<li>网络应用：如网站、后台服务。 </li>
<li>日常小工具：如脚本任务。</li>
<li>把其它语言开发的程序包装起来。</li>
</ul>
</li>
<li><p>Python缺点：</p>
<ul>
<li>速度慢。</li>
<li>代码不加密。</li>
</ul>
</li>
</ul>
<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><ul>
<li><p>2.x和3.x不兼容，教程以3.5为准。</p>
</li>
<li><p>使用homebrew安装：<code>brew install python3</code></p>
</li>
<li><p>常见Python解释器</p>
<ul>
<li>CPython：官方默认。（提示符：&gt;&gt;&gt;）</li>
<li>IPythion：基于CPython，在交互上有所增强。（提示符：In[序号]）</li>
<li>PyPy：利用动态编译提升速度，可能和CPython的执行结果不同。</li>
<li>Jython：运行在Java平台，编译成Java字节码执行。</li>
<li>IronPython：运行在.Net平台。</li>
</ul>
</li>
</ul>
<h2 id="第一个Python程序"><a href="#第一个Python程序" class="headerlink" title="第一个Python程序"></a>第一个Python程序</h2><ul>
<li>在Python交互式环境下，输入表达式可以直接看到结果。</li>
<li><p>如果表达式写在abc.py文件中，必须写在print()里，才能通过<code>python abc.py</code>打印出来。</p>
</li>
<li><p>如果想能够直接在shell中运行py文件，需要在py文件第一行加上以下内容：<code>#!/usr/bin/env python3</code>（Windows会忽略这一行），同时赋予执行权限：<code>chmod a+x hello.py</code>。</p>
</li>
</ul>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ul>
<li><code>print(&#39;hello, world&#39;)</code></li>
<li><code>print(&#39;hello&#39;, &#39;world&#39;)</code> 遇到逗号会输出一个空格。</li>
</ul>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li><code>name = input()</code> </li>
<li><code>name = input(&#39;please input your name: &#39;)</code></li>
</ul>
<h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><ul>
<li><code>#这是注释</code></li>
<li>每一行是一个语句，若语句以<code>:</code>结尾，后面缩进的语句为代码块。最好以4个空格为缩进。</li>
<li>大小写敏感。</li>
<li>Python是动态语言。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>整数：1，100，0xff00</li>
<li>浮点数：1.23，1.2e-9</li>
<li><p>字符串：’abc’，”xyz”，”I’m OK”，”I\’m \”OK\”\n”</p>
<ul>
<li>不转义：r’\\\t\n\\’</li>
<li><p>多行字符串：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r&apos;&apos;&apos;line1</span><br><span class="line">line2</span><br><span class="line">line3&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>布尔值：True，False（运算：and，or，not）</p>
</li>
<li>空值：None</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><code>int()</code>、<code>float()</code>、<code>str()</code>、<code>bool()</code>可以实现数据类型转换。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>执行 <code>a = &#39;ABC&#39;</code>时：<ul>
<li>在内存中创建了字符串’ABC’。</li>
<li>在内存中创建了变量a，让它指向’ABC’。</li>
</ul>
</li>
</ul>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><ul>
<li><code>10 / 3</code>得3.333333。</li>
<li><code>10 // 3</code>得3。</li>
<li><code>10 % 3</code>得1。</li>
</ul>
<h3 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h3><h4 id="编码常识"><a href="#编码常识" class="headerlink" title="编码常识"></a>编码常识</h4><ul>
<li>ASCII编码是1个字节，Unicode编码通常是2个字节。</li>
<li>UTF-8编码是可变长编码，可以是1~6个字节。英文字母为1个字节，汉字通常3个字节。</li>
<li>内存中统一用Unicode编码，存储和传输时使用UTF-8编码。</li>
</ul>
<h4 id="字符串和编码转换"><a href="#字符串和编码转换" class="headerlink" title="字符串和编码转换"></a>字符串和编码转换</h4><ul>
<li>Python3中，字符串是以Unicode编码的，支持多语言。使用<code>chr()</code>和<code>ord()</code>可以对字符进行编码转换：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&apos;A&apos;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&apos;中&apos;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&apos;文&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>在内存中，字符串类型以Unicode表示。但如果要保存或传输，需要转变为以字节为单位的bytes。使用<code>b&#39;ABC&#39;</code>来表示。使用<code>encode()</code>方法可以将字符串转换为指定编码的bytes：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">b&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">b&apos;\xe64\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;ascii&apos;)</span><br><span class="line">(UnicodeEncodeError....)</span><br></pre></td></tr></table></figure>
<ul>
<li>反之，可以使用<code>decode()</code>方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&apos;ABC&apos;.decode(&apos;ascii&apos;)</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; b&apos;\xe64\xb8\xad\xe6\x96\x87&apos;</span><br><span class="line">&apos;中文&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>计算字符串的字符数，使用<code>len(&#39;ABC中文&#39;)</code>，得到结果<code>5</code>。</li>
<li>计算bytes的字节数，使用<code>len(b&#39;ABC\xe4&#39;)</code>，得到结果<code>4</code>。</li>
</ul>
<h4 id="源代码的编码"><a href="#源代码的编码" class="headerlink" title="源代码的编码"></a>源代码的编码</h4><ul>
<li>Python源代码文件包含中文时要使用UTF-8编码，需要在文件开头加上：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>
<p>同时要注意文本编辑器使用UTF-8 without BOM编码。</p>
<h4 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Hi, %s, you have $%d. &apos; % (&apos;Michael&apos;, 10000)</span><br><span class="line">&apos;Hi, Michael, you have $10000.</span><br><span class="line">&gt;&gt;&gt; &apos;%2d----%02d&apos; % (3, 1)</span><br><span class="line">&apos; 3----01&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;%.2f&apos; % 3.14159</span><br><span class="line">&apos;3.14&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>%d：整数</li>
<li>%f：浮点数</li>
<li>%x：十六进制整数</li>
<li>%s：字符串（从任意类型转换）</li>
</ul>
<p>注意：<code>%</code>的转义使用<code>%%</code></p>
<h4 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h4><p><code>str.replace(&#39;a&#39;,&#39;A&#39;)</code>会返回替换的结果，但不会改变str。</p>
<h3 id="使用list和tuple"><a href="#使用list和tuple" class="headerlink" title="使用list和tuple"></a>使用list和tuple</h3><ul>
<li>list：可变，有序表，数据类型可不同，可嵌套。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3, [11, 22], True]</span><br><span class="line">&gt;&gt;&gt; len(classmates)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; classmates[0]</span><br><span class="line">&apos;A&apos;</span><br><span class="line">&gt;&gt;&gt; classmates[-1]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; classmates.append(&apos;D&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates.insert(1, &apos;AB&apos;)</span><br><span class="line">&gt;&gt;&gt; classmates.pop()</span><br><span class="line">&apos;D&apos;</span><br><span class="line">&gt;&gt;&gt; classmates.pop(0)</span><br><span class="line">&apos;A&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>tuple：元组，只读的有序表。注意若有元素是list，该list的内容是可变的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2)</span><br><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; t = (&apos;a&apos;,&apos;b&apos;, [1, 2])</span><br></pre></td></tr></table></figure>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul>
<li>注意这里使用了<code>int()</code>将input的字符串转化成整型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age = input(&apos;input your age: &apos;)</span><br><span class="line">age = int(age)</span><br><span class="line">if age &gt;= 6:</span><br><span class="line">    print(&apos;teenager&apos;);</span><br><span class="line">elif age &gt;= 18:</span><br><span class="line">    print(&apos;adult&apos;);</span><br><span class="line">else</span><br><span class="line">    print(&apos;kid&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul>
<li>注意这里使用了<code>range(101)</code>来生成<code>[0,1,......,100]</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">for name in names:</span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line">sum = 0</span><br><span class="line">for x in range(101):</span><br><span class="line">    sum = sum + x</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    n = n - 1</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure>
<h3 id="使用dict和set"><a href="#使用dict和set" class="headerlink" title="使用dict和set"></a>使用dict和set</h3><ul>
<li>dict：字典，无序的，常数时间查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">&gt;&gt;&gt; d[&apos;Adam&apos;] = 67</span><br><span class="line">&gt;&gt;&gt; d[&apos;Bob&apos;]</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; &apos;Thomas&apos; in d</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;)         #返回None时Python不显示结果</span><br><span class="line">&gt;&gt;&gt; d.get(&apos;Thomas&apos;, -1)     #自己指定找不到key时返回的value</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; d.pop(&apos;Bob&apos;)</span><br><span class="line">75</span><br></pre></td></tr></table></figure>
<ul>
<li>set：一组key的集合，没有重复。和dict一样，都不能把可变的元素放入，如list。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 1, 2, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; t = set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s &amp; t</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s | t</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>调用函数时，参数数量不对或者参数类型不对都会导致TypeError错误。</li>
<li>max()函数可以支持任意多个参数。</li>
<li>函数名是一个函数对象的引用，可以将其复制给一个变量，相当于给函数起了一个别名。</li>
</ul>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(s):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有返回值，函数执行完毕会返回None。</li>
<li>在交互环境中，定义函数时Python会出现<code>...</code>的提示，定义结束后需要按两次回车。</li>
</ul>
<h3 id="导入函数"><a href="#导入函数" class="headerlink" title="导入函数"></a>导入函数</h3><ul>
<li>假设<code>my_abs()</code>定义在<code>abstest.py</code>中，在该目录的交互式环境中，可以使用<code>from abstest import my_abs</code>来导入该函数。</li>
</ul>
<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><ul>
<li>用pass表示占位符，什么都不做：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h3 id="检查参数类型"><a href="#检查参数类型" class="headerlink" title="检查参数类型"></a>检查参数类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&apos;bad operand type&apos;)</span><br><span class="line">    if x &gt;= 0</span><br><span class="line">        return x</span><br><span class="line">    else</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><ul>
<li>利用tuple（省略了小括号）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def move(x, y, step, angle):</span><br><span class="line">    ...</span><br><span class="line">    return x*x, y*y</span><br></pre></td></tr></table></figure>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="默认参数：同C语言，如果只是指定个别的默认参数，可以这样写："><a href="#默认参数：同C语言，如果只是指定个别的默认参数，可以这样写：" class="headerlink" title="默认参数：同C语言，如果只是指定个别的默认参数，可以这样写："></a>默认参数：同C语言，如果只是指定个别的默认参数，可以这样写：</h4><p><code>enroll(&#39;Adam&#39;, city = &#39;Tianjin&#39;)</code></p>
<p>注意：默认参数一定要指向不变对象，比如如果是个List，每次调用改变这个List值，这个状态会持续到下次调用。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L = []):</span><br><span class="line">    L.append(&apos;End&apos;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure>
<p>这里最好使用None：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L = None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(&apos;End&apos;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure></p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ul>
<li>允许传入0个或任意个参数，组装为一个tuple。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum = 0</span><br><span class="line">    for n in numbers</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>如果去掉*，则需要传入一个list或者tuple。</li>
<li>传入0个参数也是可以的。</li>
<li>也可以使用list或者tuple前面加*的方式进行调用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; num = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br></pre></td></tr></table></figure>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><ul>
<li>允许传入0个或任意多个含参数名的参数，组装为一个dict。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&apos;name: &apos;, name, &apos;age: &apos;, age, &apos;other: &apos;, kw)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; person(&apos;Michael&apos;, 30)</span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city = &apos;Beijing&apos;)</span><br><span class="line">name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender = &apos;M&apos;, job = &apos;Engineer&apos;)</span><br><span class="line">name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)</span><br><span class="line">name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：函数里对kw的改动不会影响到实参。</p>
<h4 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h4><ul>
<li>对关键字参数的key进行限制，如：只接受city和job：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果已经有了一个可变参数，后面的命名关键字参数就不需要用*分割了，但这时调用必须传入参数名，可以有缺省值：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *args, city = &apos;Beijing&apos;, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>
<h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><ul>
<li>参数定义顺序：必选参数、默认参数<code>POSITIONAL_OR_KEYWORD</code>、可变参数<code>VAR_POSITIONAL</code>、命名关键字参数<code>KEYWORD_ONLY</code>、关键字参数<code>VAR_KEYWORD</code></li>
<li>其实还有一种<code>POSITIONAL_ONLY</code>的参数，只有一些内置函数用到。</li>
<li>使用<code>inspect.signature(func).parameters[i].kind</code>获取函数的参数信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c = 0, *args, **kw):</span><br><span class="line">    pass</span><br><span class="line">def f2(a, b, c = 0, *, d, **kw):</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c = 3)</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x = 99)</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d = 99, ext = None)</span><br><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)                 #对任何函数，都可以这样进行调用！</span><br></pre></td></tr></table></figure>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul>
<li>小心栈溢出！对于没有循环语句的语言，可以使用<em>尾递归优化</em>策略，让函数返回的时候，调用自身而不包含表达式。但是大多数语言没有针对尾递归做优化，包括Python解释器。</li>
</ul>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul>
<li>取List的部分元素：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]                  #从下标0开始取3个元素</span><br><span class="line">&gt;&gt;&gt; L[:3]                   #0可以省略</span><br><span class="line">&gt;&gt;&gt; L[-3:-1]</span><br><span class="line">&gt;&gt;&gt; L[-3:]</span><br><span class="line">&gt;&gt;&gt; L[:10:2]                #前10个数，每两个取一个</span><br><span class="line">&gt;&gt;&gt; L[:]                    #复制一个list</span><br><span class="line">&gt;&gt;&gt; (0, 1, 2, 3, 4)[:3]     #tuple的切片仍为tuple</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]           #字符串也可以切</span><br></pre></td></tr></table></figure>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>即for…in…，可迭代对象有：list、tuple、dict、str。</li>
<li><p>注意dict的三种迭代方式：</p>
<ul>
<li><code>for key in d</code></li>
<li><code>for value in d.values()</code></li>
<li><code>for k, v in d.items()</code></li>
</ul>
</li>
<li><p>注意list的下标迭代方式：</p>
<ul>
<li><code>for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):</code></li>
</ul>
</li>
<li><p>判断一个对象是否可迭代：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h3 id="列表生成式（List-Comprehensions）"><a href="#列表生成式（List-Comprehensions）" class="headerlink" title="列表生成式（List Comprehensions）"></a>列表生成式（List Comprehensions）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(range(1,11))                               #生成列表[1, 2, 3, ..., 10]</span><br><span class="line">&gt;&gt;&gt; [x * x for x in range(1,11)]                    #生成列表[1, 4, 9, ..., 100]</span><br><span class="line">&gt;&gt;&gt; [x * x for x in range(1,11) if x % 2 == 0]      #生成列表[4, 16, 36, ..., 100]</span><br><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;XYZ&apos;]           #生成列表[&apos;AX&apos;, &apos;AY&apos;, ..., CZ&apos;]（全排列）</span><br><span class="line">&gt;&gt;&gt; d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; [k + &apos;=&apos; + v for k, v in d.items()]             #生成列表[&apos;y=B&apos;, &apos;x=A&apos;, &apos;z=c&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)]                    #生成当前目录下的文件和目录构成的列表</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L = [&apos;Hello&apos;, &apos;World&apos;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]                          #把L总的字符串都变成小写</span><br></pre></td></tr></table></figure>
<h3 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h3><ul>
<li>把列表生成式的[]改成()即可。</li>
<li>边循环边计算，节约空间。</li>
<li>通过next(g)函数获取下一个返回值。或者使用for…in。</li>
<li>也可以通过函数生成，利用yield：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure>
<p>注意，generator函数每次调用next()时执行，遇到yield语句返回，再次执行时从上次返回的yield语句出继续执行。</p>
<ul>
<li><p>通过调用该函数将得到一个可迭代的generator对象。</p>
</li>
<li><p>如果想捕获该函数的返回值，需要捕获StopIteration错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = next(g)</span><br><span class="line">        print(&apos;g:&apos;, x)</span><br><span class="line">    except StopIteration as e:</span><br><span class="line">        print(&apos;Generator return Value:&apos;, e.value)</span><br><span class="line">        break;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><ul>
<li>可用于for循环的对象统称为可迭代对象：Iterable。</li>
<li>可以使用<code>isinstance(x, Iterable)</code>来判断是否是可迭代对象。</li>
<li>生成器还可以使用next()不断调用并返回下一个值，直至StopIteration错误。这种对象称为迭代器。</li>
<li>可以使用<code>isinstance(x, Iterator)</code>来判断是否是迭代器。</li>
<li>可以使用<code>iter(x)</code>函数把list、dict、str等Iterable变成Iterator。</li>
<li>for … in 的等价写法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for x in [1, 2, 3 ,4]:</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">it = iter([1, 2, 3, 4])</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        x = next(it)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        break;</span><br></pre></td></tr></table></figure>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul>
<li>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</li>
<li>函数式编程允许把函数本身作为参数，还允许返回一个函数。</li>
<li>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul>
<li>变量可以指向函数。</li>
<li>函数名也是变量。（不是只读的）</li>
<li>函数名作参数。</li>
</ul>
<h4 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h4><ul>
<li><code>map()</code>接受两个参数：函数和Iterable，map将函数依次作用在每个元素上，把结果作为新的Iterator返回。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; r = map(f, [1, 2, 3 ,4])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>reduce()</code>也接受这样的两个参数，函数把上一次计算结果与下一个元素做累积计算。即：`reduce(f, [x1, x2, x3，x4]) = f(f(f(x1, x2), x3), x4）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7])</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<ul>
<li>利用这两个函数，可以实现int(str)的功能：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def str2int(s):</span><br><span class="line">    def fn(x, y):</span><br><span class="line">        return x * 10 + y</span><br><span class="line">    def char2num(s):</span><br><span class="line">        return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line">   return reduce(fn, map(char2num, s));</span><br></pre></td></tr></table></figure>
<p>还可以使用lambda函数进一步简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def char2num(s):</span><br><span class="line">    return &#123;&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9&#125;[s]</span><br><span class="line">def str2int(s):</span><br><span class="line">    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul>
<li><p>类似map，不过函数返回True/False，决定元素是否保留。返回的也是Iterator。</p>
</li>
<li><p>实例：利用埃氏算法计算素数：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#构造3开始的奇数序列</span><br><span class="line">def _odd_iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br><span class="line">        </span><br><span class="line">#定义筛选函数</span><br><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0</span><br><span class="line">    </span><br><span class="line">#生成器</span><br><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _odd_iter()</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it)</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it)</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line">for n in primes():</span><br><span class="line">    if n &lt; 1000:</span><br><span class="line">        print(n)</span><br><span class="line">    else</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([3, 2 , 4, 1])</span><br><span class="line">[1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; sorted([-3, 2, 4, 1], key = abs)</span><br><span class="line">[1, 2, -3, 4]</span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;])</span><br><span class="line">[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;]</span><br><span class="line">&gt;&gt;&gt; sorted([&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;], key=str.lower, reverse=True)</span><br><span class="line">[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; f = lazy_sum(1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<ul>
<li>内部函数sum可以访问外部函数lazy_sum的参数和局部变量。当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中。————“闭包（Closure）”</li>
<li>每次调用lazy_sum返回的都是个新函数。</li>
</ul>
<h4 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" class="headerlink" title="使用闭包的注意事项"></a>使用闭包的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">            return i * i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return fs</span><br><span class="line">    </span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">&gt;&gt;&gt; f3()</span><br></pre></td></tr></table></figure>
<p>注意：这里三次执行的结果都是9，因为返回的函数引用了变量i，但它并非立即执行。等到3个函数都返回时，所引用的变量i都变成了3.</p>
<p>所以：返回闭包时，返回函数不要引用任何循环变量等后续会发生变化的变量。</p>
<p>如果一定要引用循环变量，可以再引入一个函数（可以使用lambda函数缩短代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul>
<li><code>lambda x: x * x</code>实际上就是<code>def f(x):  return x * x</code>。</li>
<li>Python对匿名函数支持有限，只有一些简单的情况下可以使用。</li>
</ul>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><ul>
<li>函数有个<code>__name__</code>属性，可以拿到函数的名字：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     print(&apos;2016-3-3&apos;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = now</span><br><span class="line">&gt;&gt;&gt; now.__name__</span><br><span class="line">&apos;now&apos;</span><br><span class="line">&gt;&gt;&gt; f.__name__</span><br><span class="line">&apos;now&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>不修改now函数，实现在执行now之前打印日志：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;call %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line">    </span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2016-3-3&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。实际上就是一个返回函数的高阶函数。</li>
<li>把<code>@log</code>放在<code>now()</code>定义处，相当于执行了：<code>now = log(now)</code>，实际上调用的是wrapper()函数，根据定义，它可以接受任意参数的调用。</li>
<li>如果decorator本身需要传入参数，需要再编写一个返回decorator的高阶函数。比如要自定义log的文本：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&apos;%s %s():&apos; % &#123;text, func.__name__&#125;)</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@log(&apos;execute&apos;)</span><br><span class="line">def now():</span><br><span class="line">    print(&apos;2016-3-3&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>相当于：<code>now = log(&#39;execute&#39;)(now)</code>。</li>
<li>注意：这时函数的<code>__name__</code>已经由<code>&#39;now&#39;</code>变成了<code>&#39;wrapper&#39;</code>。如果代码依赖函数签名，需要避免这一点，不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，而可以直接这么写：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&apos;cal %s():&apos; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>
<p>或者针对带参数的decorator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(...)</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br></pre></td></tr></table></figure>
<h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><ul>
<li>对某个函数的个别参数设定默认值，得到一个新的函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;12345&apos;, base=8)</span><br><span class="line">5349</span><br><span class="line"></span><br><span class="line">#常规方法</span><br><span class="line">def int8(x, base=8):</span><br><span class="line">    return int(x, base)</span><br><span class="line"></span><br><span class="line">#使用偏函数的写法</span><br><span class="line">import functools</span><br><span class="line">int2 = functools.partial(int, base=2)</span><br><span class="line"></span><br><span class="line">int2(&apos;10010&apos;)</span><br><span class="line">#就相当于固定了一个关键字参数：</span><br><span class="line">kw = &#123;&apos;base&apos;: 2&#125;</span><br><span class="line">int(&apos;10010&apos;, **kw)</span><br><span class="line"></span><br><span class="line">#也可接受*args：</span><br><span class="line">max2 = functools.partial(max, 10)</span><br><span class="line">max2(5, 6, 7)</span><br><span class="line">#就相当于：</span><br><span class="line">args = (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li>文件<code>abc.py</code>就是一个名字叫<code>abc</code>的模块（Module）。</li>
<li>多个模块可以放在同一个模块下组成一个包（Package）。包名即目录名。</li>
<li>包下一定要有一个<code>__init__.py</code>的文件。</li>
<li>引入包后，模块的名字就变成了<code>包名.模块名</code>。</li>
<li>不要和自带的模块冲突，如<code>sys</code>模块。</li>
</ul>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">&apos; a test module &apos;</span><br><span class="line"></span><br><span class="line">__author__ = &apos;Meng Fanze&apos;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    if len(args) == 1:</span><br><span class="line">        print(&apos;Hello world&apos;)</span><br><span class="line">    elif len(args) == 2:</span><br><span class="line">        print(&apos; Hello %s&apos; % args[1])</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;Too many arguments&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个字符串：文档注释。</li>
<li><code>__author__</code>：作者。</li>
<li>导入了sys模块后，就有了变量sys指向该模块。它有一个<code>argv</code>变量，用list存储了所有参数，且至少有一个元素，即文件名。如：<code>python3 hello.py</code>获得的<code>sys.argv</code>就是[‘hello.py’]。</li>
<li>最后一个if可以让模块从命令行运行时执行一段额外的代码，常用于测试。原理是Python解释器会把<code>__name__</code>置为<code>__main__</code>。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>公开的：正常的函数和变量名。</li>
<li>特殊的：<code>__author__</code>、<code>__name__</code>、<code>__doc__</code>（文档注释），可以被直接饮用，但有特殊用途。</li>
<li>非公开的：<code>_xxx</code>、<code>__xxx</code>，<em>不应该</em>被直接引用。</li>
</ul>
<h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><ul>
<li>包管理工具：pip（Mac和Linux已自带）</li>
<li>第三方库会在Python官方的pypi.python.org注册，如安装Pillow（基于Python Imaging Library，PIL的处理图像的工具库）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure>
<ul>
<li>使用import：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from PIL import Image</span><br><span class="line">&gt;&gt;&gt; im = Image.open(&apos;test.jpg&apos;)</span><br><span class="line">&gt;&gt;&gt; print(im.format, im.size, im.mode)</span><br><span class="line">PNG (400, 300) RGB</span><br><span class="line">&gt;&gt;&gt; im.thumbnail((200,100))</span><br><span class="line">&gt;&gt;&gt; im.save(&apos;thumb.jpg&apos;, &apos;JPEG&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块。搜索路径位于<code>sys</code>模块的<code>sys.path</code>变量中。</p>
</li>
<li><p>临时添加自己的搜索目录：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&apos;/....&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>永久添加自己的搜索路径：设置环境变量<code>PYTHONPATH</code>，在其中只放置自己添加的路径即可。</li>
</ul>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        </span><br><span class="line">    def print_score(self):</span><br><span class="line">        print(&apos;%s: %s&apos; % (self.name, self.score))</span><br><span class="line">        </span><br><span class="line">&gt;&gt;&gt; bart = Student()</span><br></pre></td></tr></table></figure>
<ul>
<li>object表示基类，object是最基本的基类。</li>
<li>可以自由地给实例绑定属性。</li>
<li><code>__init__</code>相当于构造函数，第一个参数永远是self，表示实例本身。</li>
<li>有了<strong>init</strong>之后，创建实例时就要按照对应的参数表传参了，但self不用传。</li>
<li>实际上所有类中的方法都带有这样的self。</li>
</ul>
<h3 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h3><ul>
<li>private变量前加上两个下划线。</li>
<li>注意，特殊变量（即<code>__xxx__</code>）不是私有变量。</li>
<li>加一个下划线的约定俗成为“不推荐访问”的变量。</li>
<li>private变量其实是可以从外部访问的……（什么鬼= =!），比如，Python会把<code>__name</code>解析成<code>_Student__name</code>，通过它即可来实现访问。但是，不同版本的解释器可能不同。</li>
<li>Python本身没有任何机制阻止你干坏事，一切靠自觉。</li>
</ul>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><ul>
<li>思想同C++。</li>
<li>“开闭原则”：对扩展开发，对修改封闭。</li>
<li><code>isinstance(dog, Animal)</code>返回True。</li>
<li>和静态语言不同的是，调用一个对象的方法，这个对象不一定必须要是基类或者其派生类，还可以是任何具有该方法的类。着一定决定了继承不像静态语言那样是必须的。</li>
</ul>
<h3 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h3><ul>
<li><code>type()</code>可以返回对象类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(123) == type(456)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(123) == int</span><br><span class="line">True</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; def fn():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(fn) == types.FunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(abs) == types.BuiltinFunctionType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(lambda x: x) == types.LambdaType</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type((x for x in range(10))) == types.GeneratorType</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<ul>
<li><code>isinstance()</code>可以判断对象是否属于某类型或某类型的派生类，还可以判断是否是某些类型中的一种：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<ul>
<li><code>dir()</code>可以获得一个对象的所有属性和方法。返回一个list。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(&apos;ABC&apos;)</span><br><span class="line">[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>len(&#39;ABC&#39;)</code>实际上就是调用对象的<code>__len__()</code>方法，所以自己写的类中实现该方法就也可以使用len()进行调用。</p>
</li>
<li><p><code>getattr(obj, &#39;attr1&#39;)</code>可以获取属性。</p>
</li>
<li><code>setattr(obj, &#39;attr1&#39;, &#39;value&#39;)</code>可以设置属性。</li>
<li><code>hasattr(obj, &#39;attr1&#39;)</code>可以判断属性是否存在。</li>
<li>如果试图获取不存在的属性，会报AttributeError。</li>
<li><code>getattr(obj, &#39;attr1&#39;, &#39;defaultValue&#39;)</code>可以获取属性，若属性不存在，返回默认值。</li>
<li>以上，属性也可以是方法。</li>
</ul>
<h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><ul>
<li>直接为类定义属性视作类的静态成员。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    name = &apos;Student&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用<code>Student.name</code>访问，也可以用其实例对象访问，如<code>s.name</code>，前提是s没有name成员。</li>
</ul>
<h2 id="面向对象高级编程"><a href="#面向对象高级编程" class="headerlink" title="面向对象高级编程"></a>面向对象高级编程</h2><h3 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h3><ul>
<li>给实例绑定方法，对另一个实例是不起作用的：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def set_age(self, age):</span><br><span class="line">    self.age = age</span><br><span class="line">    </span><br><span class="line">from types import MethodType</span><br><span class="line">s.set_age = MethodType(set_age, s)</span><br></pre></td></tr></table></figure>
<ul>
<li>为了给所有实例绑定方法，可以给class绑定方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def set_score(self, score):</span><br><span class="line">    self.score = score</span><br><span class="line"></span><br><span class="line">Student.set_score = set_score</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想要限制实例的属性，比如只允许添加name和age属性：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    __slots__ = (&apos;name&apos;, &apos;age&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这样只对当前类起作用，子类无效。</li>
</ul>
<h3 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h3><ul>
<li>如果对属性的取值有要求，通常的做法是写成set_xxx函数。</li>
<li>利用@property装饰器可以实现将一个方法变成属性调用的形式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def score(self):</span><br><span class="line">        return self._score</span><br><span class="line">    </span><br><span class="line">    @score.setter</span><br><span class="line">    def score(self, value):</span><br><span class="line">        if not isinstance(value, int):</span><br><span class="line">            raise ValueError(&apos;score must be an integer&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100&apos;)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不定义setter方法，就是一个只读属性。</li>
</ul>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>Python允许使用多重继承，MixIn就是一种常见的设计。</p>
<h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><h4 id="str"><a href="#str" class="headerlink" title="__str__()"></a><code>__str__()</code></h4><p>重写该函数，可以在print(对象)的时候输出自定义的内容。这是为用户服务的。</p>
<h4 id="repr"><a href="#repr" class="headerlink" title="__repr__()"></a><code>__repr__()</code></h4><p>重写该函数，可以在交互界面直接执行该对象时输出自定义的内容。这是为开发者服务的。往往应该与上者一致。偷懒的写法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;%s&apos; % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>
<h4 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a><code>__iter__</code></h4><p>返回一个迭代对象，以用于for…in循环。for循环会不断地调用<code>__next__()</code>拿到下一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Fib(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.a, self.b = 0, 1 # 初始化两个计数器a，b</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self # 实例本身就是迭代对象，故返回自己</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b # 计算下一个值</span><br><span class="line">        if self.a &gt; 100000: # 退出循环的条件</span><br><span class="line">            raise StopIteration();</span><br><span class="line">        return self.a # 返回下一个值</span><br><span class="line">        </span><br><span class="line">&gt;&gt;&gt; for n in Fib():</span><br><span class="line">...     print(n)</span><br></pre></td></tr></table></figure>
<h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__()"></a><code>__getitem__()</code></h4><ul>
<li>重写该方法，使之支持下标访问。参数是(self, n)。但是想实现切片、负数和步距，还需要更多代码。比如判断isinstance(n, slice)来处理切片的情况。</li>
<li>如果把对象看成dict， 这个函数的参数还可能是一个可以作为key的object，比如str。</li>
<li><code>__setitem__()</code>方法把对象视作list或者dict来对集合复制。</li>
<li><code>__delitem__()</code>方法用于删除某个元素。</li>
</ul>
<h4 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__()"></a><code>__getattr__()</code></h4><ul>
<li>调用不存在的成员时会触发。默认抛出AttributeError异常。可以复写这个函数来处理某些情况，注意让别的情况继续抛出该异常，否则的话会默认返回None。</li>
<li>作用：可以针对完全动态的情况作调用。比如REST API。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Chain(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, path = &apos;&apos;):</span><br><span class="line">        self._path = path</span><br><span class="line">        </span><br><span class="line">    def __getattr__(self, path):</span><br><span class="line">        return Chain(&apos;%s/%s&apos; % (self._path, path))</span><br><span class="line">        </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self._path</span><br><span class="line">        </span><br><span class="line">    __repr__ = __str__</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; Chain().status.user.timeline.list</span><br><span class="line">&apos;/status/user/timeline/list&apos;</span><br></pre></td></tr></table></figure>
<h4 id="call"><a href="#call" class="headerlink" title="__call__()"></a><code>__call__()</code></h4><ul>
<li>把实例看作函数进行调用。</li>
<li><code>callable(object)</code>可以用来判断一个对象是否可以被调用。</li>
</ul>
<h3 id="使用枚举类"><a href="#使用枚举类" class="headerlink" title="使用枚举类"></a>使用枚举类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(&apos;Month&apos;, (&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;, &apos;May&apos;, &apos;Jun&apos;, &apos;Jul&apos;, &apos;Aug&apos;, &apos;Sep&apos;, &apos;Oct&apos;, &apos;Nov&apos;, &apos;Dec&apos;))</span><br><span class="line"></span><br><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &apos;=&gt;&apos;, member, &apos;,&apos;, member.value)</span><br></pre></td></tr></table></figure>
<ul>
<li>这样就可以直接使用<code>Month.Jan</code>来应用一个常量。</li>
<li>value是自动赋给成员的int常量，默认从1开始。</li>
<li>如果需要更精确地控制枚举类型，要派生Enum类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0</span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue)</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&apos;Tue&apos;])</span><br><span class="line">&gt;&gt;&gt; print(Weekday(2))</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &apos;=&gt;&apos;, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure>
<ul>
<li>@unique装饰器检查重复值。</li>
</ul>
<h3 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h3><h4 id="使用type-动态创建类"><a href="#使用type-动态创建类" class="headerlink" title="使用type()动态创建类"></a>使用type()动态创建类</h4><ul>
<li>动态语言本身支持运行期动态创建类。</li>
<li>假设Hello类有一个hello方法，一个实例为h。</li>
<li>type(Hello)返回type：<class 'type'></li>
<li>type(h)返回class Hello：<class 'hello.Hello'></li>
<li>type()还可以创建出新的对象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fn(self, name = &apos;world&apos;):</span><br><span class="line">    print(&apos;Hello, %s.&apos; % name)</span><br><span class="line">    </span><br><span class="line">Hello = type(&apos;Hello&apos;, (object,), dict(hello = fn))</span><br></pre></td></tr></table></figure>
<p>唯一不同的是：<code>print(type(h))</code>输出的是<code>&lt;class &#39;__main__.Hello&#39;&gt;</code></p>
<h4 id="使用metaclass控制类的创建行为"><a href="#使用metaclass控制类的创建行为" class="headerlink" title="使用metaclass控制类的创建行为"></a>使用metaclass控制类的创建行为</h4><ul>
<li>类似我们要“先定义类，然后创建实例”，我们要“先定义metaclass， 然后创建类”。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ListMetaclass(type):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        attrs[&apos;add&apos;] = lambda self, value: self.append(value)</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br><span class="line">        </span><br><span class="line">class MyList(list, metaclass = ListMetaclass):</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; L = MyList()</span><br><span class="line">&gt;&gt;&gt; L.add(1)</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[1]</span><br></pre></td></tr></table></figure>
<ul>
<li>约定类名以Metaclass结尾。</li>
<li>必须从type类型派生。</li>
<li>定义类时传入关键字参数metaclass。</li>
<li><p><code>__new__()</code>的参数：</p>
<ul>
<li>准备创建的类的对象；</li>
<li>类的名字；</li>
<li>类继承的父类集合；</li>
<li>类的方法集合。</li>
</ul>
</li>
<li><p>应用：ORM（Object Relational Mapping），即对象-关系映射。编写一个ORM框架，所有类都只能动态定义。<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000">简单实现方式</a></p>
</li>
</ul>
<h2 id="错误、调试、测试"><a href="#错误、调试、测试" class="headerlink" title="错误、调试、测试"></a>错误、调试、测试</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&apos;try...&apos;)</span><br><span class="line">    r = 10 / int(&apos;2&apos;)</span><br><span class="line">    print(&apos;result:&apos;, r)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&apos;ValueError:&apos;, e)</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&apos;ZeroDivisionError:&apos;, e)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;no error!&apos;)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;finally...&apos;)</span><br><span class="line">print(&apos;END&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>else：没有错误时执行。</li>
<li>根据错误类型不同执行不同的except语句，所有错误类型都来自BaseException。</li>
<li>根据继承关系，把更宽泛的错误类型写后面。</li>
<li>try…except…finally可以跨越多层调用捕获错误。通过调用堆栈可以找到根源。</li>
<li>在except中使用<code>logging.exception(e)</code>来记录错误而不退出程序。通过配置，可以记录到日志文件。</li>
<li>派生错误类型类，然后用raise语句可以抛出自定义错误。</li>
<li>如果当前try…catch无法处理某个错误，可以交给上级去处理：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    if n==0:</span><br><span class="line">        raise ValueError(&apos;invalid value: %s&apos; % s)</span><br><span class="line">    return 10 / n</span><br><span class="line"></span><br><span class="line">def bar():</span><br><span class="line">    try:</span><br><span class="line">        foo(&apos;0&apos;)</span><br><span class="line">    except ValueError as e:</span><br><span class="line">        print(&apos;ValueError!&apos;)</span><br><span class="line">        raise</span><br><span class="line"></span><br><span class="line">bar()</span><br></pre></td></tr></table></figure>
<ul>
<li>这里raise如果不带参数，就把错误原样抛出。也可以加参数转换错误类型，只要是合理的转换逻辑。</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul>
<li>使用print()。</li>
<li>使用assert：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(s):</span><br><span class="line">    n = int(s)</span><br><span class="line">    assert n != 0, &apos;n is zero!&apos;</span><br><span class="line">    return 10 / n</span><br><span class="line">    </span><br><span class="line">def main():</span><br><span class="line">    foo(&apos;0&apos;)</span><br></pre></td></tr></table></figure>
<p>如果断言失败，就会抛出AssertionError。启动Python编辑器时可以用-O参数来关闭assert（看作pass）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -O err.py</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用logging：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level = logging.INFO)</span><br><span class="line"></span><br><span class="line">s = &apos;0&apos;</span><br><span class="line">n = int (s)</span><br><span class="line">logging.info(&apos;n = %d&apos; % n)</span><br><span class="line">print(10 / n)</span><br></pre></td></tr></table></figure>
<p>使用logging可以指定记录信息的级别：debug、info、warning、error。也可以轻易配置输出到不同位置。</p>
<ul>
<li>使用pdb：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pdb err.py</span><br></pre></td></tr></table></figure>
<p>命令<code>1</code>：查看代码<br>命令<code>n</code>：单步执行<br>命令<code>p 变量名</code>：查看变量<br>命令<code>q</code>：结束调试</p>
<ul>
<li><p>使用pdb.set_trace()<br><code>import pdb</code>，然后用<code>pdb.set_trace()</code>来设置断点。再使用pdb调试。遇到断点会停下，命令<code>c</code>可以继续运行。</p>
</li>
<li><p>使用IDE，如PyCharm、Eclipse + pydev。固然方便，但最后你会发现，logging才是终极武器。</p>
</li>
</ul>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul>
<li>测试驱动开发：TDD、Test-Driven Development。</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Dict(dict):</span><br><span class="line">   #编写一个可以使用属性来访问的Dict。利用__getattr__和__setattr__。</span><br><span class="line"></span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">from mydict import Dict</span><br><span class="line"></span><br><span class="line">class TestDict(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">   def test_init(self):</span><br><span class="line">       d = Dict(a = 1, b = &apos;test&apos;)</span><br><span class="line">       self.assertEqual(d.a, 1)</span><br><span class="line">       self.assertEquel(d.b, &apos;test)</span><br><span class="line">       self.assertTrue(isinstance(d,dict))</span><br><span class="line">       </span><br><span class="line">   def test_key(self):</span><br><span class="line">       d = Dict()</span><br><span class="line">       d[&apos;key&apos;] = &apos;value&apos;</span><br><span class="line">       self.assertEqual(d.key, &apos;value&apos;)</span><br><span class="line">       </span><br><span class="line">   def test_attr(self):</span><br><span class="line">       d = Dict()</span><br><span class="line">       d.key = &apos;value&apos;</span><br><span class="line">       self.assertTrue(&apos;key&apos; in d)</span><br><span class="line">       self.assertERqual(d[&apos;key&apos;], &apos;value&apos;)</span><br><span class="line">       </span><br><span class="line">   def test_keyerror(self):</span><br><span class="line">       d = Dict()</span><br><span class="line">       with self.assertRaises(KeyError):</span><br><span class="line">           value = d[&apos;empty&apos;]</span><br><span class="line">           </span><br><span class="line">   def test_attrerror(self):</span><br><span class="line">       d = Dict()</span><br><span class="line">       with self.assertRaises(AttributeError):</span><br><span class="line">           value = d.empty</span><br></pre></td></tr></table></figure>
<ul>
<li>测试类要从unittest.TestCase继承，测试方法要以test_开头。</li>
<li>主要利用assertEqual和assertRaises来处理情况。</li>
<li>运行方式一：在文件最后加上下面这段当做正常python脚本运行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<ul>
<li>运行方式二：通过参数：<code>-m unittest</code>。</li>
<li>两个特殊的方法：setUp(self)和tearDown(self)，相当于构造和析构。</li>
<li>总结：单元测试用例要覆盖常用的输入组合、边界条件、异常。</li>
</ul>
<h3 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h3><ul>
<li>Python内置的文档测试模块（doctest）可以提取注释中的代码并执行调试。</li>
<li>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。</li>
<li>最后三行代码保证只有直接从命令行运行才执行测试。</li>
<li>如果有文档中的用例没通过会报错。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Dict(dict):</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    Simple dict but also support access as x.y style.</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; d1 = Dict()</span><br><span class="line">    &gt;&gt;&gt; d1[&apos;x&apos;] = 100</span><br><span class="line">    &gt;&gt;&gt; d1.x</span><br><span class="line">    100</span><br><span class="line">    &gt;&gt;&gt; d1.y = 200</span><br><span class="line">    &gt;&gt;&gt; d1[&apos;y&apos;]</span><br><span class="line">    200</span><br><span class="line">    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&apos;3&apos;)</span><br><span class="line">    &gt;&gt;&gt; d2.c</span><br><span class="line">    &apos;3&apos;</span><br><span class="line">    &gt;&gt;&gt; d2[&apos;empty&apos;]</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    KeyError: &apos;empty&apos;</span><br><span class="line">    &gt;&gt;&gt; d2.empty</span><br><span class="line">    Traceback (most recent call last):</span><br><span class="line">        ...</span><br><span class="line">    AttributeError: &apos;Dict&apos; object has no attribute &apos;empty&apos;</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    </span><br><span class="line">    def __init__(self, **kw):</span><br><span class="line">        super(Dict, self).__init__(**kw)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        try:</span><br><span class="line">            return self[key]</span><br><span class="line">        except KeyError:</span><br><span class="line">            raise AttributeError(r&quot;&apos;Dict&apos; object has no attribute &apos;%s&apos;&quot; % key)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        self[key] = value</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></table></figure>
<h2 id="IO编程"><a href="#IO编程" class="headerlink" title="IO编程"></a>IO编程</h2><ul>
<li>同步IO、异步IO。</li>
<li>异步IO的性能远高于同步IO，但是编程模型复杂，如需要考虑用回调模式还是轮询模式。</li>
</ul>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#一般情况</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;/Users/Fanze/test.txt&apos;, &apos;r&apos;)      #若文件不存在会抛出IOError错误。</span><br><span class="line">&gt;&gt;&gt; f.read()                                    #一次性读取文件的全部内容，适用于小文件。          </span><br><span class="line">&apos;Hello, world&apos;</span><br><span class="line">&gt;&gt;&gt; f.read(size)                                #每次最多读取size个字节的内容。</span><br><span class="line">&gt;&gt;&gt; f.readline()                                #读取一行内容。</span><br><span class="line">&gt;&gt;&gt; f.readlines()                               #一次性读取所有内容，按行返回一个list。</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line"></span><br><span class="line">#错误处理</span><br><span class="line">try:</span><br><span class="line">    f = open(&apos;path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br><span class="line">        </span><br><span class="line">#推荐用法</span><br><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    print(f.read())</span><br><span class="line"></span><br><span class="line">#读取二进制文件</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;/path/to/file&apos;, &apos;rb&apos;)             #读取二进制文件。</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">b&apos;\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...&apos;      #十六进制表示的字节。</span><br><span class="line"></span><br><span class="line">#按指定字符编码打开文件。遇到不规范的文件，会遇到UnicodeDecodeError。设置errors可以处理它。</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;/path/to/gbk.txt&apos;, &apos;r&apos;, encoding = &apos;gbk&apos;, errors = &apos;ignore&apos;)</span><br><span class="line">&gt;&gt;&gt; f.read()</span><br><span class="line">&apos;测试&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>写文件与读文件相同，用’w’替换’r’，用f.write替换f.read。一定要用f.close()否则缓存中的数据可能不会完成写入。</li>
</ul>
<h3 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h3><h4 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h4><ul>
<li>在内存中读写str。使用write()和getValue()方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import StringIO</span><br><span class="line">&gt;&gt;&gt; f = StringIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;hello&apos;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; f.write(&apos; &apos;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(f.getValue())</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<ul>
<li>StringIO对象也可以用str作为参数进行构造，然后像文件一样用readline()等函数读取。</li>
</ul>
<h4 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h4><ul>
<li>在内存中操作二进制数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from io import BytesIO</span><br><span class="line">&gt;&gt;&gt; f = BytesIO()</span><br><span class="line">&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; printf(f.getvalue())</span><br><span class="line">b&apos;\xe4\xb8\xad\xe6\x96\x87&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>同样的，BytesIO对象也可以用bytes作为参数进行构造，然后像文件对象一样进行操作。</li>
</ul>
<h3 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h3><ul>
<li>使用os模块直接调用操作系统提供的接口函数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.name</span><br><span class="line">&apos;posix&apos;                         #posix：Linux、Unix、OS X。nt：Windows。</span><br><span class="line">&gt;&gt;&gt; os.uname()                  #查看系统的详细信息。但是在windows上不提供。</span><br><span class="line">&gt;&gt;&gt; os.environ                  #查看系统的环境变量</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&apos;PATH&apos;)      #获取某个环境变量的值</span><br><span class="line">&gt;&gt;&gt; os.environ.get(&apos;x&apos;, &apos;default&apos;)</span><br><span class="line"></span><br><span class="line">#对路径的操作</span><br><span class="line">&gt;&gt;&gt; os.path.abspath(&apos;.&apos;)        #查看绝对路径</span><br><span class="line">&gt;&gt;&gt; os.path.join(&apos;/Users/Fanze&apos;, &apos;testDir&apos;) #得到完整目录，这是因为Windows下用的是&apos;\&apos;，Linux等用的是&apos;/&apos;</span><br><span class="line">&apos;/Users/Fanze/testDir&apos;</span><br><span class="line">&gt;&gt;&gt; os.path.split(&apos;/Users/Fanze/testDir/file.txt&apos;)  #拆分路径字符串。</span><br><span class="line">(&apos;/Users/Fanze/testDir&apos;, &apos;file.txt&apos;)</span><br><span class="line">&gt;&gt;&gt; os.path.splitext(&apos;/path/to/file.txt&apos;)           #拆分到文件扩展名</span><br><span class="line">(&apos;/path/to/file&apos;, &apos;.txt&apos;)</span><br><span class="line"></span><br><span class="line">#对目录的操作</span><br><span class="line">&gt;&gt;&gt; os.mkdir(&apos;/Users/Fanze/testDir&apos;)</span><br><span class="line">&gt;&gt;&gt; os.rmdir(&apos;/Users/Fanze/testDir&apos;)</span><br><span class="line"> </span><br><span class="line">#对文件的操作</span><br><span class="line">&gt;&gt;&gt; os.rename(&apos;test.txt&apos;, &apos;test.py&apos;)</span><br><span class="line">&gt;&gt;&gt; os.remove(&apos;test.py&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>复制文件的函数在os模块中不存在，因为这并非是操作系统提供的系统调用。但是可以借助shutil模块中的copyfile()，这个模块可以看做是os的补充。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#列出当前目录下的所有目录</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isdir(x)]</span><br><span class="line">#列出所有的.py文件</span><br><span class="line">&gt;&gt;&gt; [x for x in os.listdir(&apos;.&apos;) if os.path.isfile(x) and os.path.splitext(x)[1] == &apos;.py&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="序列化（pickling）"><a href="#序列化（pickling）" class="headerlink" title="序列化（pickling）"></a>序列化（pickling）</h3><ul>
<li>在其他语言里一般称之为serialization、marshalling、flatterning。</li>
<li>使用pickle模块.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; d = dict(name = &apos;Bob&apos;, age = 20, score = 88)</span><br><span class="line">&gt;&gt;&gt; pickle.dumps(d)</span><br><span class="line">b&apos;\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.&apos;</span><br><span class="line"></span><br><span class="line">#直接写入一个file-like Object：</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;wb&apos;)</span><br><span class="line">&gt;&gt;&gt; pickle.dump(d, f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line"></span><br><span class="line">#读入到内存</span><br><span class="line">&gt;&gt;&gt; f = open(&apos;dump.txt&apos;, &apos;rb&apos;)</span><br><span class="line">&gt;&gt;&gt; d = pickle.load(f)</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;age&apos;: 20, &apos;score&apos;: 88, &apos;name&apos;: &apos;Bob&apos;&#125;</span><br><span class="line">#还可以使用pickle.loads()方法从bytes中反序列化出对象。</span><br></pre></td></tr></table></figure>
<ul>
<li>使用json模块。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json </span><br><span class="line">&gt;&gt;&gt; d = dict(name = &apos;Bob&apos;, age = 20, score = 88)</span><br><span class="line">&gt;&gt;&gt; json.dumps(d)</span><br><span class="line">&apos;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&apos;</span><br><span class="line">#同样的，dump()方法可以直接把JSON写入一个file-like Object。load和loads方法可以读取file-like Object或者字符串并反序列化。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>JSON标准规定编码是UTF-8，所以我们总是能正确地在Python中实现str和JSON字符串之间进行转换。</p>
</li>
<li><p>Python的dict对象序列化为JSON的<code>{}</code>，但是class默认是不能序列化的。需要利用dumps()的可选参数default，为他制定类中一个返回dict的方法。如：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def student2dict(std):</span><br><span class="line">    return &#123;</span><br><span class="line">        &apos;name&apos;: std.name,</span><br><span class="line">        &apos;age&apos;: std.age</span><br><span class="line">        &apos;score&apos;: std.score</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&gt;&gt; print(json.dumps(s, default = student2dict))</span><br><span class="line"></span><br><span class="line">#利用__dict__属性（有些类例外，比如定义了__slot__），可以有个偷懒的写法：</span><br><span class="line">&gt;&gt;&gt; print(json.dumps(s, default = lambda obj: obj.__dict__))</span><br></pre></td></tr></table></figure>
<ul>
<li>如果想反序列化成class，要在loads()中传入object_hook函数来把dict转换为object：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def dict2student(d):</span><br><span class="line">    return Student(d[&apos;name&apos;], d[&apos;age&apos;], d[&apos;score&apos;])</span><br><span class="line">&gt;&gt;&gt; print(json.loads(json_str, object_hook = dict2student))</span><br></pre></td></tr></table></figure>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><ul>
<li>fork()函数：调用一次，返回两次。操作系统把当前进程复制一份，父进程里返回子进程的ID，子进程返回0。子进程中可以调用getppid()得到父进程的ID。</li>
<li>os模块对fork等进行了封装。包括：os.fork()、os.getpid()、os.getppid()等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os </span><br><span class="line">print(&apos;Process (%s) start...&apos; % os.getpid())</span><br><span class="line">pid = os.fork()</span><br><span class="line">if pid == 0:</span><br><span class="line">    print(&apos;I am child (%s) , my parent is (%s)&apos; % (os.getpid(), os.getppid()))</span><br><span class="line">else:</span><br><span class="line">    print(&apos;I (%s) created a child (%s)&apos; % (os.getpid(), pid))</span><br></pre></td></tr></table></figure>
<ul>
<li>fork只能在Unix/Linux上使用，想要使用跨平台版本的多进程要使用multiprocessing模块。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#启动一个子进程并等待其结束</span><br><span class="line">from multiprocessing import Process</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def run_proc(name):</span><br><span class="line">    print(&apos;this is child %s&apos; % name)</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&apos;this is parent&apos;)</span><br><span class="line">    p = Process(target = run_proc, args = (&apos;test&apos;,))</span><br><span class="line">    print(&apos;child start.&apos;)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    print(&apos;child end.&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用进程池（Pool）启动大量子进程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Pool</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line">def long_time_task(name):</span><br><span class="line">    start = time.tem()</span><br><span class="line">    time.sleep(random.random() * 3)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print(&apos;%s : %0.2f seconds.&apos; % (name, (end - start)))</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    p = Pool(4)     #指定最多同时执行的进程数。默认值是CPU的核数。</span><br><span class="line">    for i in range(5):      #创建5个进程。</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    print(&apos;Waiting&apos;)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()        #调用之前必须先调用close，调用close()之后就不能继续添加新的进程了。</span><br><span class="line">    print(&apos;Done&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用子进程：子进程一般并不是自身，而是一个外部进程。创建之后还需要控制其输入和输出。使用subprocess模块。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">r = subprocess.call([&apos;nslookup&apos;, &apos;www.python.org&apos;])     </span><br><span class="line">print(&apos;Exit code:&apos;, r)                                  #返回0</span><br><span class="line"></span><br><span class="line">#如果子进程还需要输入，则通过communicate()方法：</span><br><span class="line">import subprocess</span><br><span class="line"></span><br><span class="line">p = subprocess.Popen([&apos;nslookup&apos;], stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE)</span><br><span class="line">output, err = p.communicate(b&apos;set q=mx\npython.org\nexit\n&apos;)</span><br><span class="line">print(output.decode(&apos;utf-8&apos;))</span><br><span class="line">print(&apos;Exit code:&apos;, p.returncode)</span><br></pre></td></tr></table></figure>
<ul>
<li>Python封装了进程间通讯的底层机制，可以使用Queue、Pipies等来交换数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#创建两个子进程，一个写Queue，一个读Queue。</span><br><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os, time, random</span><br><span class="line"></span><br><span class="line"># 写数据进程执行的代码:</span><br><span class="line">def write(q):</span><br><span class="line">    print(&apos;Process to write: %s&apos; % os.getpid())</span><br><span class="line">    for value in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</span><br><span class="line">        print(&apos;Put %s to queue...&apos; % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"># 读数据进程执行的代码:</span><br><span class="line">def read(q):</span><br><span class="line">    print(&apos;Process to read: %s&apos; % os.getpid())</span><br><span class="line">    while True:</span><br><span class="line">        value = q.get(True)</span><br><span class="line">        print(&apos;Get %s from queue.&apos; % value)</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    # 父进程创建Queue，并传给各个子进程：</span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    # 启动子进程pw，写入:</span><br><span class="line">    pw.start()</span><br><span class="line">    # 启动子进程pr，读取:</span><br><span class="line">    pr.start()</span><br><span class="line">    # 等待pw结束:</span><br><span class="line">    pw.join()</span><br><span class="line">    # pr进程里是死循环，无法等待其结束，只能强行终止:</span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure>
<ul>
<li>multiprocessing在Windows下模拟实现fork()效果是通过pickle序列化实现的。</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul>
<li>Python的线程是真正的Posix Thread，而不是模拟出来的线程。</li>
<li>两个模块：_thread和threading，后者是对前者的封装。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import time, threading</span><br><span class="line"></span><br><span class="line"># 新线程执行的代码:</span><br><span class="line">def loop():</span><br><span class="line">    print(&apos;thread %s is running...&apos; % threading.current_thread().name)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;thread %s &gt;&gt;&gt; %s&apos; % (threading.current_thread().name, n))</span><br><span class="line">        time.sleep(1)</span><br><span class="line">    print(&apos;thread %s ended.&apos; % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">print(&apos;thread %s is running...&apos; % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop, name=&apos;LoopThread&apos;)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line">print(&apos;thread %s ended.&apos; % threading.current_thread().name)</span><br></pre></td></tr></table></figure>
<ul>
<li>threading.current_thread()永远返回当前线程的实例。主线程为MainThread，子线程在创建时指定（默认是Thread-1、Thread-2…）。</li>
<li>多进程中，每个进程的变量互不影响。多线程中，所有变量由所有线程共享。使用锁来控制冲突：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">balance = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def run_thread(n):</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        # 先要获取锁:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        try:</span><br><span class="line">            # 放心地改吧:</span><br><span class="line">            change_it(n)</span><br><span class="line">        finally:</span><br><span class="line">            # 改完了一定要释放锁:</span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure>
<ul>
<li>因为GIL锁（Global Interpreter Lock）的存在，Python无法像其它语言（C、C++、Java）让多线程充分利用多核处理器，除非使用扩展或者重写一个不带GIL的解释器。但是可以通过多进程实现多核任务。</li>
<li>GIL：任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul>
<li>让同一个全局变量在每个线程中都有一个副本。常用于每个线程绑定一个数据库连接、HTTP请求、用户身份信息等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line"># 创建全局ThreadLocal对象，可以把它看作dict来绑定其它变量:</span><br><span class="line">local_school = threading.local()</span><br><span class="line"></span><br><span class="line">def process_student():</span><br><span class="line">    # 获取当前线程关联的student:</span><br><span class="line">    std = local_school.student</span><br><span class="line">    print(&apos;Hello, %s (in %s)&apos; % (std, threading.current_thread().name))</span><br><span class="line"></span><br><span class="line">def process_thread(name):</span><br><span class="line">    # 绑定ThreadLocal的student:</span><br><span class="line">    local_school.student = name</span><br><span class="line">    process_student()</span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target= process_thread, args=(&apos;Alice&apos;,), name=&apos;Thread-A&apos;)</span><br><span class="line">t2 = threading.Thread(target= process_thread, args=(&apos;Bob&apos;,), name=&apos;Thread-B&apos;)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br></pre></td></tr></table></figure>
<h3 id="多进程对比多线程"><a href="#多进程对比多线程" class="headerlink" title="多进程对比多线程"></a>多进程对比多线程</h3><ul>
<li>多进程：稳定，子进程崩溃不影响其它进程。但是创建进程代价大，进程数不能太多。Apache早期采用。</li>
<li><p>多线程：比多进程稍快。一个线程的崩溃会影响整个进程。Windows下效率比多进程高。IIS采用。</p>
</li>
<li><p>计算密集型任务：需要进行大量计算，消耗CPU资源。同时进行的任务数等同于CPU核心数效率最高，适合用C语言编写。</p>
</li>
<li><p>IO密集型任务：大部分时间在等待网络、磁盘IO。CPU消耗很少。在一定限度内，任务越多，CPU效率越高。C和Python运行效率差别不大，应注重开发效率选择Python。</p>
</li>
<li><p>异步IO：用单进程单线程执行多任务，称之为事件驱动模型，Python里称为协程。如Nginx就是支持异步IO的Web服务器。</p>
</li>
</ul>
<h3 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h3><ul>
<li>Thread和Process应优选Process。</li>
<li>Process可以分布到多台机器上，Thread不行。利用multiprocessing模块中的managers子模块。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># task_master.py</span><br><span class="line"></span><br><span class="line">import random, time, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 发送任务的队列:</span><br><span class="line">task_queue = queue.Queue()</span><br><span class="line"># 接收结果的队列:</span><br><span class="line">result_queue = queue.Queue()</span><br><span class="line"></span><br><span class="line"># 从BaseManager继承的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span><br><span class="line">QueueManager.register(&apos;get_task_queue&apos;, callable=lambda: task_queue)</span><br><span class="line">QueueManager.register(&apos;get_result_queue&apos;, callable=lambda: result_queue)</span><br><span class="line"># 绑定端口5000, 设置验证码&apos;abc&apos;:</span><br><span class="line">manager = QueueManager(address=(&apos;&apos;, 5000), authkey=b&apos;abc&apos;)</span><br><span class="line"># 启动Queue:</span><br><span class="line">manager.start()</span><br><span class="line"># 获得通过网络访问的Queue对象:</span><br><span class="line">task = manager.get_task_queue()</span><br><span class="line">result = manager.get_result_queue()</span><br><span class="line"># 放几个任务进去:</span><br><span class="line">for i in range(10):</span><br><span class="line">    n = random.randint(0, 10000)</span><br><span class="line">    print(&apos;Put task %d...&apos; % n)</span><br><span class="line">    task.put(n)</span><br><span class="line"># 从result队列读取结果:</span><br><span class="line">print(&apos;Try get results...&apos;)</span><br><span class="line">for i in range(10):</span><br><span class="line">    r = result.get(timeout=10)</span><br><span class="line">    print(&apos;Result: %s&apos; % r)</span><br><span class="line"># 关闭:</span><br><span class="line">manager.shutdown()</span><br><span class="line">print(&apos;master exit.&apos;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># task_worker.py</span><br><span class="line"></span><br><span class="line">import time, sys, queue</span><br><span class="line">from multiprocessing.managers import BaseManager</span><br><span class="line"></span><br><span class="line"># 创建类似的QueueManager:</span><br><span class="line">class QueueManager(BaseManager):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span><br><span class="line">QueueManager.register(&apos;get_task_queue&apos;)</span><br><span class="line">QueueManager.register(&apos;get_result_queue&apos;)</span><br><span class="line"></span><br><span class="line"># 连接到服务器，也就是运行task_master.py的机器:</span><br><span class="line">server_addr = &apos;127.0.0.1&apos;</span><br><span class="line">print(&apos;Connect to server %s...&apos; % server_addr)</span><br><span class="line"># 端口和验证码注意保持与task_master.py设置的完全一致:</span><br><span class="line">m = QueueManager(address=(server_addr, 5000), authkey=b&apos;abc&apos;)</span><br><span class="line"># 从网络连接:</span><br><span class="line">m.connect()</span><br><span class="line"># 获取Queue的对象:</span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"># 从task队列取任务,并把结果写入result队列:</span><br><span class="line">for i in range(10):</span><br><span class="line">    try:</span><br><span class="line">        n = task.get(timeout=1)</span><br><span class="line">        print(&apos;run task %d * %d...&apos; % (n, n))</span><br><span class="line">        r = &apos;%d * %d = %d&apos; % (n, n, n*n)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        result.put(r)</span><br><span class="line">    except Queue.Empty:</span><br><span class="line">        print(&apos;task queue is empty.&apos;)</span><br><span class="line"># 处理结束:</span><br><span class="line">print(&apos;worker exit.&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li><code>a</code>：精确匹配。</li>
<li><code>\d</code>：匹配一个数字。</li>
<li><code>\w</code>：匹配一个字母或数字。</li>
<li><code>\s</code>：匹配一个空白符。</li>
<li><code>.</code>：匹配任意字符。</li>
<li><p><code>*</code>：匹配任意个字符。</p>
</li>
<li><p><code>+</code>：匹配至少一个字符。</p>
</li>
<li><code>?</code>：匹配0或1个字符。</li>
<li><code>{n}</code>：匹配n个字符。</li>
<li><p><code>{n,m}</code>：匹配n~m个字符。</p>
</li>
<li><p><code>[0-9a-zA-Z\_]</code>：匹配一个数字、字母或下划线。</p>
</li>
<li><p><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串。</p>
</li>
<li><p><code>A|B</code>：匹配A或B。</p>
</li>
<li><code>^\d</code>：必须以数字开头。</li>
<li><p><code>\d$</code>：必须以数字结束。</p>
</li>
<li><p>强烈建议Python中描述正则表达式的字符串用<code>r&#39;xxxx&#39;</code>。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;-\d&#123;3,8&#125;$&apos;, &apos;010-12345&apos;)       //成功，返回Match对象。</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0,9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;-\d&#123;3,8&#125;$&apos;, &apos;010 12345&apos;)       //失败，返回None。</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">test = &apos;xxxxxx&apos;</span><br><span class="line">if re.match(r&apos;exp&apos;, test):</span><br><span class="line">    print(&apos;ok&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;failed&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式的应用"><a href="#正则表达式的应用" class="headerlink" title="正则表达式的应用"></a>正则表达式的应用</h3><ul>
<li>用于切分字符串。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#正常切分：</span><br><span class="line">&gt;&gt;&gt; &apos;a b  c&apos;.split(&apos; &apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">#使用正则表达式：</span><br><span class="line">&gt;&gt;&gt; re.split(r&apos;\s+&apos;, &apos;a b  c&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; re.split(r&apos;[\s\,\;]+&apos;, &apos;a,b, c;; d&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure>
<ul>
<li>用于分组。使用<code>()</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; m.group(0)      #永远是原始字符串</span><br><span class="line">&apos;010-12345&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(1)</span><br><span class="line">&apos;010&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(2)</span><br><span class="line">&apos;12345&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>贪婪匹配：匹配尽可能多的字符。默认开启。加<code>?</code>可关闭。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 匹配数字后面的0</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;102300&apos;, &apos;&apos;)</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;1023&apos;, &apos;00&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>处于效率的考虑，要重复使用的正则表达式可以先进行预编译，使用时也不用再次书写正则表达式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;8086&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="常用内建模块"><a href="#常用内建模块" class="headerlink" title="常用内建模块"></a>常用内建模块</h2><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#当前时间</span><br><span class="line">&gt;&gt;&gt; from datetime import datetime       #注意是datetime模块中的datetime类</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()                #类型是datetime.datetime</span><br><span class="line">&gt;&gt;&gt; print(now)</span><br><span class="line">2015-05-18 16:28:07.198690</span><br><span class="line"></span><br><span class="line">#构造时间</span><br><span class="line">&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20)</span><br><span class="line"></span><br><span class="line">#与timestamp互转</span><br><span class="line">&gt;&gt;&gt; dt.timestamp()</span><br><span class="line">1429417200.0            #小数表示毫秒，Java、JS等语言不使用小数，整数值是Python的1000倍。</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(1429417200.0))</span><br><span class="line">2015-04-19 12:20:00     #本地时间，即2015-04-19 12:20:00 UTC+8:00</span><br><span class="line">&gt;&gt;&gt; print(datetime.utcfromtimestamp(1429417200.0))</span><br><span class="line">2015-04-19 04:20:00     #UTC+0:00的时间。</span><br><span class="line"></span><br><span class="line">#与str互转</span><br><span class="line">&gt;&gt;&gt; cday = datetime.strptime(&apos;2015-6-1 18:19:59&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)</span><br><span class="line">&gt;&gt;&gt; print(datetime.now().strftime(&apos;%a, %b %d %H:%M&apos;))</span><br><span class="line">Mon, May 05 16:28</span><br><span class="line"></span><br><span class="line">#运算</span><br><span class="line">&gt;&gt;&gt; from datetime import timedelta</span><br><span class="line">&gt;&gt;&gt; datetime.now() + timedelta(days = 2, hours = 12)</span><br><span class="line"></span><br><span class="line">#强制设置时区属性（默认tzinfo为None）</span><br><span class="line">&gt;&gt;&gt; from datetime import timezone</span><br><span class="line">&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours = 8))</span><br><span class="line">&gt;&gt;&gt; datetime.now().replace(tzinfo = tz_utc_8)</span><br><span class="line"></span><br><span class="line">#时区转换（拿到一个datetime，要获知其正确的时区，然后强制设置时区，再转换）</span><br><span class="line">&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo = timezone.utc)</span><br><span class="line">&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours = 8)))</span><br></pre></td></tr></table></figure>
<h3 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h3><h4 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h4><ul>
<li>把tuple简单封装成一个类（是tuple的子类），限制元素个数，并可通过属性访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import namedtuple</span><br><span class="line">&gt;&gt;&gt; Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])</span><br><span class="line">&gt;&gt;&gt; p = Point(1, 2)</span><br></pre></td></tr></table></figure>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><ul>
<li>链表？解决list作为线性存储插入和删除效率低的问题。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt; q.append(&apos;x&apos;)</span><br><span class="line">&gt;&gt;&gt; q.appendleft(&apos;y&apos;)</span><br><span class="line">&gt;&gt;&gt; q.pop()</span><br><span class="line">&gt;&gt;&gt; q.popleft()</span><br></pre></td></tr></table></figure>
<h4 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h4><ul>
<li>让访问dict中不存在的key时，不抛出KeyError而是返回默认值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(lambda: &apos;N/A&apos;)     #注意参数是函数</span><br></pre></td></tr></table></figure>
<h4 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h4><ul>
<li>有序的dict，按Key得插入顺序排列。可用于实现FIFO。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line">class LastUpdatedOrderedDict(OrderedDict):</span><br><span class="line"></span><br><span class="line">    def __init__(self, capacity):</span><br><span class="line">        super(LastUpdatedOrderedDict, self).__init__()</span><br><span class="line">        self._capacity = capacity</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        containsKey = 1 if key in self else 0</span><br><span class="line">        if len(self) - containsKey &gt;= self._capacity:</span><br><span class="line">            last = self.popitem(last=False)</span><br><span class="line">            print(&apos;remove:&apos;, last)</span><br><span class="line">        if containsKey:</span><br><span class="line">            del self[key]</span><br><span class="line">            print(&apos;set:&apos;, (key, value))</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;add:&apos;, (key, value))</span><br><span class="line">        OrderedDict.__setitem__(self, key, value)</span><br></pre></td></tr></table></figure>
<h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><ul>
<li>计数器，比如统计字符出现个数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Counter</span><br><span class="line">&gt;&gt;&gt; c = Counter()</span><br><span class="line">&gt;&gt;&gt; for ch in &apos;programming&apos;:</span><br><span class="line">...     c[ch] = c[ch] + 1</span><br></pre></td></tr></table></figure>
<h4 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h4><ul>
<li>把每3字节的二进制数据编码为4字节的文本数据。文本包括<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]</code>。</li>
<li>如果末尾有剩余1或2个直接，则补<code>\x00</code>，再在编码末尾加上1或2个<code>=</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(b&apos;binary\x00string&apos;)</span><br><span class="line">b&apos;YmluYXJ5AHN0cmluZw==&apos;</span><br><span class="line">&gt;&gt;&gt; base64.b64decode(b&apos;YmluYXJ5AHN0cmluZw==&apos;)</span><br><span class="line">b&apos;binary\x00string&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为’+’和’/‘不能在URL中直接作为参数，所以又有一种”url safe”的base64编码，把他们分别替换成’-‘和’_’：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)</span><br><span class="line">b&apos;abcd++//&apos;</span><br><span class="line">&gt;&gt;&gt; base64.urlsafe_b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)</span><br><span class="line">b&apos;abcd--__&apos;</span><br><span class="line">&gt;&gt;&gt; base64.urlsafe_b64decode(&apos;abcd--__&apos;)</span><br><span class="line">b&apos;i\xb7\x1d\xfb\xef\xff&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用自定义的编码表，但通常没必要。</li>
<li>Base64不能用于加密，即使使用自定义的编码表。</li>
<li>Base64适用于小段内容，如数字证书签名、Cookie。</li>
<li>因为<code>=</code>也不能出现在URL中，所以有些地方会把<code>=</code>去掉，可以根据4的倍数的原理推算出。</li>
</ul>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>实现任意类型到bytes的转换。(略，用到时再查)</p>
<h3 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h3><ul>
<li>摘要算法：又称哈希算法、散列算法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(&apos;how to use md5&apos;.encode(&apos;utf-8&apos;))    //可将字符串分割，再多次调用update。</span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure>
<ul>
<li>要使用SHA1算法的话只要把md5换成sha1。</li>
</ul>
<h3 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h3><ul>
<li>得到有限或无限的迭代器。（继而用for…in遍历）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; natuals = itertools.count(1)    //无限的自然数序列</span><br><span class="line">&gt;&gt;&gt; cs = itertools.cycle(&apos;ABC&apos;)     //无限的&apos;ABCABCABC...&apos;</span><br><span class="line">&gt;&gt;&gt; ns = itertools.repeat(&apos;A&apos;, 3)   //&apos;AAA&apos;，如果没有第二个参数就是无限的</span><br><span class="line">&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)    //从无限的序列中截取一部分</span><br><span class="line">&gt;&gt;&gt; itertools.chain(&apos;ABC&apos;, &apos;XYZ&apos;)   //串联一组迭代对象</span><br><span class="line"></span><br><span class="line">#分组</span><br><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AAABBBCCAAA&apos;):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</span><br><span class="line">C [&apos;C&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AaaBBbcCAAa&apos;, lambda c: c.upper()):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;a&apos;, &apos;a&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;b&apos;]</span><br><span class="line">C [&apos;c&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;a&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>操作XML的两种方法：</p>
<ul>
<li>DOM：把整个XML读入内存，解析为树。</li>
<li>SAX：流模式，边读边解析。需要自己处理事件。主要使用三个事件：start_element，end_element，char_data。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from xml.parsers.expat import ParserCreate</span><br><span class="line"></span><br><span class="line">class DefaultSaxHandler(object):</span><br><span class="line">    def start_element(self, name, attrs):</span><br><span class="line">        print(&apos;sax:start_element: %s, attrs: %s&apos; % (name, str(attrs)))</span><br><span class="line"></span><br><span class="line">    def end_element(self, name):</span><br><span class="line">        print(&apos;sax:end_element: %s&apos; % name)</span><br><span class="line"></span><br><span class="line">    def char_data(self, text):</span><br><span class="line">        print(&apos;sax:char_data: %s&apos; % text)</span><br><span class="line"></span><br><span class="line">xml = r&apos;&apos;&apos;&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">handler = DefaultSaxHandler()</span><br><span class="line">parser = ParserCreate()</span><br><span class="line">parser.StartElementHandler = handler.start_element</span><br><span class="line">parser.EndElementHandler = handler.end_element</span><br><span class="line">parser.CharacterDataHandler = handler.char_data</span><br><span class="line">parser.Parse(xml)</span><br></pre></td></tr></table></figure>
<h3 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from html.parser import HTMLParser</span><br><span class="line">from html.entities import name2codepoint</span><br><span class="line"></span><br><span class="line">class MyHTMLParser(HTMLParser):</span><br><span class="line"></span><br><span class="line">    def handle_starttag(self, tag, attrs):</span><br><span class="line">        print(&apos;&lt;%s&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_endtag(self, tag):</span><br><span class="line">        print(&apos;&lt;/%s&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_startendtag(self, tag, attrs):</span><br><span class="line">        print(&apos;&lt;%s/&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_data(self, data):</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line">    def handle_comment(self, data):</span><br><span class="line">        print(&apos;&lt;!--&apos;, data, &apos;--&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def handle_entityref(self, name):</span><br><span class="line">        print(&apos;&amp;%s;&apos; % name)</span><br><span class="line"></span><br><span class="line">    def handle_charref(self, name):</span><br><span class="line">        print(&apos;&amp;#%s;&apos; % name)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(&apos;&apos;&apos;&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- test html parser --&gt;</span><br><span class="line">    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;&apos;&apos;&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>抓取GET请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">with request.urlopen(&apos;https://api.douban.com/v2/book/2129650&apos;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, data.decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status: 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 26 May 2015 10:02:27 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 2049</span><br><span class="line">Connection: close</span><br><span class="line">Expires: Sun, 1 Jan 2006 01:00:00 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: must-revalidate, no-cache, private</span><br><span class="line">X-DAE-Node: pidl1</span><br><span class="line">Data: &#123;&quot;rating&quot;:&#123;&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0&#125;,&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,&quot;tags&quot;:[&#123;&quot;count&quot;:20,&quot;name&quot;:&quot;spring&quot;,&quot;title&quot;:&quot;spring&quot;&#125;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模拟iPhone 6发送GET请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">req = request.Request(&apos;http://www.douban.com/&apos;)</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)</span><br><span class="line">with request.urlopen(req) as f:</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h4><ul>
<li>模拟微博登录：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">print(&apos;Login to weibo.cn...&apos;)</span><br><span class="line">email = input(&apos;Email: &apos;)</span><br><span class="line">passwd = input(&apos;Password: &apos;)</span><br><span class="line">login_data = parse.urlencode([</span><br><span class="line">    (&apos;username&apos;, email),</span><br><span class="line">    (&apos;password&apos;, passwd),</span><br><span class="line">    (&apos;entry&apos;, &apos;mweibo&apos;),</span><br><span class="line">    (&apos;client_id&apos;, &apos;&apos;),</span><br><span class="line">    (&apos;savestate&apos;, &apos;1&apos;),</span><br><span class="line">    (&apos;ec&apos;, &apos;&apos;),</span><br><span class="line">    (&apos;pagerefer&apos;, &apos;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">req = request.Request(&apos;https://passport.weibo.cn/sso/login&apos;)</span><br><span class="line">req.add_header(&apos;Origin&apos;, &apos;https://passport.weibo.cn&apos;)</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)</span><br><span class="line">req.add_header(&apos;Referer&apos;, &apos;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)</span><br><span class="line"></span><br><span class="line">with request.urlopen(req, data=login_data.encode(&apos;utf-8&apos;)) as f:</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure>
<p>成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status: 200 OK</span><br><span class="line">Server: nginx/1.2.0</span><br><span class="line">...</span><br><span class="line">Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn</span><br><span class="line">...</span><br><span class="line">Data: &#123;&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:&#123;...,&quot;uid&quot;:&quot;1658384301&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Data: &#123;&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:&#123;&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>比如通过Proxy去访问网站……</p>
<h2 id="常用第三方模块"><a href="#常用第三方模块" class="headerlink" title="常用第三方模块"></a>常用第三方模块</h2><h3 id="PIL（Python-Imaging-Library）"><a href="#PIL（Python-Imaging-Library）" class="headerlink" title="PIL（Python Imaging Library）"></a>PIL（Python Imaging Library）</h3><ul>
<li>PIL只支持到Python 2.7，要使用Pillow兼容3.x。</li>
</ul>
<h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><ul>
<li>为不同应用创建隔离的Python环境。</li>
</ul>
<h2 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h2><ul>
<li>原生库：Tkinter（封装了访问Tk的接口）。</li>
<li>第三方库：Tk（使用Tcl语言开发，支持多个OS）、wxWidgets、Qt、GTK等。</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h3><ul>
<li>客户端：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 导入socket库:</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 创建一个socket:</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)       #AF_INET表示ipv4，ipv6使用AF_INET6。</span><br><span class="line"># 建立连接:</span><br><span class="line">s.connect((&apos;www.sina.com.cn&apos;, 80))</span><br><span class="line"># 发送数据:</span><br><span class="line">s.send(b&apos;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&apos;)</span><br><span class="line"># 接收数据:</span><br><span class="line">buffer = []</span><br><span class="line">while True:</span><br><span class="line">    # 每次最多接收1k字节:</span><br><span class="line">    d = s.recv(1024)</span><br><span class="line">    if d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br><span class="line">data = b&apos;&apos;.join(buffer)</span><br><span class="line"># 关闭连接:</span><br><span class="line">s.close()</span><br><span class="line"># 把HTTP头和网页分离，把HTTP头打印出来，网页内容保存到文件：</span><br><span class="line">header, html = data.split(b&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">print(header.decode(&apos;utf-8&apos;))</span><br><span class="line"># 把接收的数据写入文件:</span><br><span class="line">with open(&apos;sina.html&apos;, &apos;wb&apos;) as f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 监听端口:</span><br><span class="line">s.bind((&apos;127.0.0.1&apos;, 9999)) </span><br><span class="line"># 开始监听：</span><br><span class="line">s.listen(5)                 #参数是等待连接的最大数目</span><br><span class="line">print(&apos;Waiting for connection...&apos;)</span><br><span class="line"># 等待接受连接请求：</span><br><span class="line">while True:</span><br><span class="line">    # 接受一个新连接:</span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    # 创建新线程来处理TCP连接:</span><br><span class="line">    t = threading.Thread(target=tcplink, args=(sock, addr))</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line"># 新线程处理请求：</span><br><span class="line">def tcplink(sock, addr):</span><br><span class="line">    print(&apos;Accept new connection from %s:%s...&apos; % addr)</span><br><span class="line">    sock.send(b&apos;Welcome!&apos;)</span><br><span class="line">    while True:</span><br><span class="line">        data = sock.recv(1024)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        if not data or data.decode(&apos;utf-8&apos;) == &apos;exit&apos;:</span><br><span class="line">            break</span><br><span class="line">        sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;))</span><br><span class="line">    sock.close()</span><br><span class="line">    print(&apos;Connection from %s:%s closed.&apos; % addr)</span><br></pre></td></tr></table></figure>
<p>说明：我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p>
<p>配套的客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 建立连接:</span><br><span class="line">s.connect((&apos;127.0.0.1&apos;, 9999))</span><br><span class="line"># 接收欢迎消息:</span><br><span class="line">print(s.recv(1024).decode(&apos;utf-8&apos;))</span><br><span class="line">for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]:</span><br><span class="line">    # 发送数据:</span><br><span class="line">    s.send(data)</span><br><span class="line">    print(s.recv(1024).decode(&apos;utf-8&apos;))</span><br><span class="line">s.send(b&apos;exit&apos;)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<h3 id="UDP编程："><a href="#UDP编程：" class="headerlink" title="UDP编程："></a>UDP编程：</h3><p>服务器端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"># 绑定端口:</span><br><span class="line">s.bind((&apos;127.0.0.1&apos;, 9999))</span><br><span class="line"># 不用调用listen()方法，直接接受来自客户端的数据。</span><br><span class="line">print(&apos;Bind UDP on 9999...&apos;)</span><br><span class="line">while True:</span><br><span class="line">    # 接收数据，省略了多线程:</span><br><span class="line">    data, addr = s.recvfrom(1024)</span><br><span class="line">    print(&apos;Received from %s:%s.&apos; % addr)</span><br><span class="line">    s.sendto(b&apos;Hello, %s!&apos; % data, addr)</span><br></pre></td></tr></table></figure>
<p>客户端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"># 不需要connect()</span><br><span class="line">for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]:</span><br><span class="line">    # 发送数据:</span><br><span class="line">    s.sendto(data, (&apos;127.0.0.1&apos;, 9999))</span><br><span class="line">    # 接收数据:</span><br><span class="line">    print(s.recv(1024).decode(&apos;utf-8&apos;))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p>注意：UDP端口和TCP端口互不冲突。</p>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><ul>
<li>MUA：Mail User Agent，邮件用户代理，如Outlook、Foxmail</li>
<li>MTA：Mail Transfer Agent，邮件传输代理</li>
<li>MDA：Mail Delivery Agent，邮件投递代理</li>
<li>一封电子邮件的旅程：<code>发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人</code></li>
</ul>
<p>编程就是为了实现：</p>
<ul>
<li>MUA把邮件发到MTA。（SMTP）</li>
<li>MUA从MDA上收邮件。（POP3、IMAP4）</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Meng Fanze</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2016/05/09/Python学习笔记/">http://ifanze.cn/2016/05/09/Python学习笔记/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请在评论区说明。</li></ul></div><br><div class="tags"><a href="/tags/python/">python</a></div><div class="post-nav"><a class="pre" href="/2016/12/08/AppleScript学习笔记/">AppleScript 学习笔记</a><a class="next" href="/2016/01/15/Git学习笔记/">Git 学习笔记</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'kfIuT7r4gG6hnmNl3uQ5vOqp-gzGzoHsz',
  appKey:'59tx3uBM3K1Ao4JFH5oE3VEK',
  placeholder:'Welcome~',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ifanze.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/《C-Primer》/">《C++ Primer》</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/homebrew/" style="font-size: 15px;">homebrew</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/libevent/" style="font-size: 15px;">libevent</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/python/" style="font-size: 15px;">python</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ifanze.cn" title="欢迎友链～" target="_blank">欢迎友链～</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Meng Fanze's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>