<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng Fanze&#39;s Blog</title>
  
  <subtitle>C++、Web、Game</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ifanze.cn/"/>
  <updated>2018-06-26T14:15:37.898Z</updated>
  <id>http://ifanze.cn/</id>
  
  <author>
    <name>Meng Fanze</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《代码大全》读书笔记 7</title>
    <link href="http://ifanze.cn/2018/06/26/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(7)/"/>
    <id>http://ifanze.cn/2018/06/26/《代码大全2》(7)/</id>
    <published>2018-06-26T09:32:16.000Z</published>
    <updated>2018-06-26T14:15:37.898Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全》读书笔记 第七章 高质量的子程序</p><a id="more"></a><!-- toc --><h1 id="7-高质量的子程序"><a href="#7-高质量的子程序" class="headerlink" title="7 高质量的子程序"></a>7 高质量的子程序</h1><h2 id="7-1-创建子程序的正当理由"><a href="#7-1-创建子程序的正当理由" class="headerlink" title="7.1 创建子程序的正当理由"></a>7.1 创建子程序的正当理由</h2><ul><li>降低复杂度。</li><li>引入中间、易懂的抽象。</li><li>避免代码重复。</li><li>支持子类化。（重载）</li><li>隐藏顺序。</li><li>隐藏指针操作。</li><li>提高可移植性。</li><li>简化复杂的布尔判断。</li><li>改善性能。</li><li><p>创建类的很多理由也是创建子程序的理由。</p></li><li><p>心理障碍：不情愿为一个简单的目的而编写一个简单的子程序。</p></li></ul><h2 id="7-2-在子程序层上设计"><a href="#7-2-在子程序层上设计" class="headerlink" title="7.2 在子程序层上设计"></a>7.2 在子程序层上设计</h2><p>内聚性（cohesion）：</p><ul><li>功能上的内聚性（functional cohesion）：最强也最好的一种内聚性。子程序只执行一项功能。</li></ul><p>不够理想的内聚性：</p><ul><li>顺序上的内聚性（sequential cohesion）：子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有全部完成才完成一项功能。</li><li>通信上的内聚性（communicational cohesion）：一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系。</li><li>临时的内聚性（temporal cohesion）：含有一些因为需要同时执行才放到一起的操作的子程序。</li></ul><p>不可取的内聚性：</p><ul><li>过程上的内聚性（procedural cohesion）：一个子程序中的操作是按特定顺序进行的。</li><li>逻辑上的内聚性（logical cohesion）：若干操作被放入同一个子程序中，通过传入的标志选择执行一项操作。</li><li>巧合的内聚性（coincidental cohesion）：子程序中的各个操作之间没有任何可以看到的关联。（无内聚性、混乱的内聚性）。</li></ul><h2 id="7-3-好的子程序名字"><a href="#7-3-好的子程序名字" class="headerlink" title="7.3 好的子程序名字"></a>7.3 好的子程序名字</h2><ul><li>描述子程序所做的所有事情。</li><li>避免使用无意义的、模糊或表述不清的动词。</li><li>不要仅通过数字来区分不同的子程序。</li><li>根据需要确定子程序名字的长度。</li><li>要对返回值有所描述。</li><li>用语气强烈的动词加宾语。</li><li>准确使用对仗词。</li><li>为常用操作确立命名规则。</li></ul><h2 id="7-4-子程序可以写多长"><a href="#7-4-子程序可以写多长" class="headerlink" title="7.4 子程序可以写多长"></a>7.4 子程序可以写多长</h2><ul><li>……200行顶多了。</li></ul><h2 id="7-5-如何使用子程序参数"><a href="#7-5-如何使用子程序参数" class="headerlink" title="7.5 如何使用子程序参数"></a>7.5 如何使用子程序参数</h2><ul><li>参数顺序：输入、修改、输出。</li><li>考虑创建<code>IN</code>、<code>OUT</code>关键字。</li><li>如果几个子程序都用了类似参数，让他们的排列一致。</li><li>使用所有的参数。</li><li>把状态或出错变量放在最后。</li><li>不要把子程序的参数用作工作变量。</li><li><p>在接口中对参数的断言加以说明。包括：</p><ul><li>参数时仅用于输入、要被修改的、还是仅用于输出的。</li><li>参数的单位。</li><li>没有用枚举的话，状态代码和错误值的含义。</li><li>所能接受的数值的范围。</li><li>不该出现的特定数值。</li></ul></li><li><p>参数数量限制在7个以内。</p></li><li>采用某种命名规则。</li><li>为子程序传递用以维持其接口抽象的变量或对象。（传整个对象还是其中特定几个参数。）</li><li>使用具名参数。（需语言支持）</li><li>确保实参和形参匹配。</li></ul><h2 id="7-6-使用函数时要特别考虑的问题"><a href="#7-6-使用函数时要特别考虑的问题" class="headerlink" title="7.6 使用函数时要特别考虑的问题"></a>7.6 使用函数时要特别考虑的问题</h2><ul><li><p>语义上：</p><ul><li>函数：有返回值。</li><li>过程：无返回值。</li></ul></li></ul><h2 id="7-7-宏子程序和内联子程序"><a href="#7-7-宏子程序和内联子程序" class="headerlink" title="7.7 宏子程序和内联子程序"></a>7.7 宏子程序和内联子程序</h2><ul><li>把宏表达式整个包含在括号内。</li><li>把含有多条语句的宏用大括号括起来。</li><li>除非必要，避免使用宏。</li><li>用给子程序命名的方法给宏命名，以便需要时用子程序替换宏。</li><li>C++中，可以用<code>const</code>、<code>inline</code>、<code>template</code>、<code>enum</code>、<code>typedef</code>等替代宏。</li><li>节制使用 inline 子程序。因为它违反了封装原则，也增加了整体代码的长度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全》读书笔记 第七章 高质量的子程序&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全》读书笔记 6</title>
    <link href="http://ifanze.cn/2018/06/26/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(6)/"/>
    <id>http://ifanze.cn/2018/06/26/《代码大全2》(6)/</id>
    <published>2018-06-26T04:32:16.000Z</published>
    <updated>2018-06-26T14:15:37.898Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全》读书笔记 第六章 可以工作的类</p><a id="more"></a><!-- toc --><h1 id="6-可以工作的类"><a href="#6-可以工作的类" class="headerlink" title="6 可以工作的类"></a>6 可以工作的类</h1><h2 id="6-1-类的基础：抽象数据类型（ADTs）"><a href="#6-1-类的基础：抽象数据类型（ADTs）" class="headerlink" title="6.1 类的基础：抽象数据类型（ADTs）"></a>6.1 类的基础：抽象数据类型（ADTs）</h2><h3 id="使用-ADT-的益处"><a href="#使用-ADT-的益处" class="headerlink" title="使用 ADT 的益处"></a>使用 ADT 的益处</h3><ul><li>隐藏实现细节。</li><li>增加功能和改动不会影响到整个程序。</li><li>让接口提供更多的信息。</li><li>更容易提高性能。</li><li>让程序的正确性显而易见。</li><li>程序更具有自我说明性。</li><li>无须在程序内到处传递数据。</li><li>你可以像在现实世界中那样操作实体，而不用在底层实现上操作它。</li></ul><h3 id="指导建议"><a href="#指导建议" class="headerlink" title="指导建议"></a>指导建议</h3><ul><li>把常见的底层数据类型创建为 ADT 并使用他们，而不再使用底层数据类型。</li><li>把像文件这样的常用对象当成 ADT。</li><li>简单的事物也可当作 ADT。</li><li>不要让 ADT 依赖于存储介质。</li></ul><h3 id="如何在非面向对象环境中使用-ADT-处理多分数据实例"><a href="#如何在非面向对象环境中使用-ADT-处理多分数据实例" class="headerlink" title="如何在非面向对象环境中使用 ADT 处理多分数据实例"></a>如何在非面向对象环境中使用 ADT 处理多分数据实例</h3><ul><li>做法一：每次使用 ADT 服务子程序时都传入实例的ID。（需要进行一次查询）</li><li>做法二：传入整个实例。（暴露了不需要的数据）</li><li>做法三：使用隐含实例，执行前调用<code>SetCurrentInstance(instID);</code>。（不推荐）</li></ul><h2 id="6-2-良好的类接口"><a href="#6-2-良好的类接口" class="headerlink" title="6.2 良好的类接口"></a>6.2 良好的类接口</h2><h3 id="好的抽象"><a href="#好的抽象" class="headerlink" title="好的抽象"></a>好的抽象</h3><ul><li>类的接口应该展现一致的抽象层次。</li><li>一定要理解类所实现的抽象是什么。（一些类非常相像。）</li><li>提供成对的服务。（有开就有关。）</li><li>把不相关的信息转移到其他类中。</li><li>尽可能让接口可编程，而不是表达语义。（一个接口中任何无法通过编译器强制实施的语义部分，就是一个可能被误用的部分，需要用注释或者断言指出。）</li><li>谨防在修改时破坏接口的抽象。</li><li>不要添加与接口抽象不一致的共用成员。</li><li>同时考虑抽象性和内聚性。</li></ul><h3 id="良好的封装"><a href="#良好的封装" class="headerlink" title="良好的封装"></a>良好的封装</h3><ul><li>尽可能地限制类和成员地可访问性。</li><li>不要公开暴露成员数据。</li><li>避免把私用的实现细节放入类的接口。<ul><li>如果你甚至不想把<code>private</code>的字段放到头文件中暴露给其他人开，可以使用一个<code>XXXImplement</code>类的指针。</li></ul></li><li>不要对类的使用者作出任何假设。</li><li>多数场合下应避免使用友元类。</li><li>不要因为一个程序里仅使用公用子程序，就把它归入公开接口。</li><li>让阅读代码比编写代码更方便。</li><li>要格外警惕从语义上破坏封装性。</li><li>留意过于紧密的耦合关系。</li></ul><h2 id="6-3-有关设计和实现的问题"><a href="#6-3-有关设计和实现的问题" class="headerlink" title="6.3 有关设计和实现的问题"></a>6.3 有关设计和实现的问题</h2><ul><li>包含才是面向对象编程中的主力技术，而不是继承。</li></ul><h3 id="包含（Containment）：-has-a"><a href="#包含（Containment）：-has-a" class="headerlink" title="包含（Containment）：... has a ..."></a>包含（Containment）：<code>... has a ...</code></h3><ul><li>包含用于实现<code>has a</code>关系。</li><li>万不得已时才通过<code>private</code>继承来实现<code>has a</code>关系。</li><li>警惕有超过约7个数据成员的类。（7±2）</li></ul><h3 id="继承（Inheritance）：-is-a"><a href="#继承（Inheritance）：-is-a" class="headerlink" title="继承（Inheritance）：...is a ..."></a>继承（Inheritance）：<code>...is a ...</code></h3><ul><li>继承用于实现<code>is a</code>关系。基类对派生类将会做什么既设定了预期，也给出了限制。</li><li>要么使用继承并进行详细说明，要么就不要用它。</li><li>遵循里氏代换原则（LSP，Liskvo Substitution Principle）。“派生类必须能通过基类的接口而被使用，且使用者无须了解两者之间的差异。”</li><li><p>确保只继承需要继承的部分。根据是否可覆盖、是否提供默认实现，可以分为：</p><ul><li>抽象且可覆盖的子程序。</li><li>可覆盖的子程序。</li><li>不可覆盖的子程序。</li></ul></li><li><p>不要覆盖一个不可覆盖的成员函数。</p></li><li>把共用的接口、数据及操作放到继承树中尽可能高的位置。</li><li>只有一个实例的类是值得怀疑的。（使用单件模式）</li><li>只有一个派生类的基类也是值得怀疑的。（提前设计）</li><li>派生后覆盖了某个子程序，但在其中没做任何操作（基类中有操作），这种情况也值得怀疑。（基类的设计问题。）</li><li>避免让继承体系过深。</li><li>尽量使用多态，避免大量的类型检查。（如果出现较为复杂的switch，就考虑一下多态。）</li><li>让所有数据都是<code>private</code>而非<code>protected</code>。“继承会破坏封装”，如果真的需要私有数据，就提供<code>protected</code>访问器函数。</li><li>慎用多重继承，设计良好的多重继承是能避免菱形继承的。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>如果多个类共享数据而非行为，应该共用对象，被这些类包含。</li><li>如果多个类共享行为而非数据，应该定义基类，被这些类继承。</li><li>如果多个类既共享数据又共享行为，应该定义基类，基类中定义共用数据和子程序，被这些类继承。</li><li>当你想由基类控制接口时，使用继承。</li><li>当你想自己控制接口时，使用包含。</li></ul><h3 id="成员函数和数据成员"><a href="#成员函数和数据成员" class="headerlink" title="成员函数和数据成员"></a>成员函数和数据成员</h3><ul><li>让类中子程序的数量尽可能少。</li><li>尽量隐式地产生你不需要地成员函数和运算符。</li><li>减少类所调用的不同子程序的数量。</li><li>对其他类的子程序的间接调用要尽可能少。</li><li><p>一般来说，应尽量减少类和类之间相互合作的范围。包括：</p><ul><li>所实例化的对象的种类。</li><li>在被实例化对象上直接调用的不同子程序的数量。</li><li>调用由其他对象返回的对象的子程序的数量。</li></ul></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>如果可能，应该在所有的构造函数中初始化所有的数据成员。（防御式编程）</li><li>用私有构造函数来强制实现单件属性。</li><li><p>优先采用深层复本（deep copies），除非论证可行，才采用浅层副本（shallow copies）。</p><ul><li>深层：开发和维护较为简单，性能也往往不会损失太多。</li><li>浅层：更快，但是增加了复杂度，容易出错。</li></ul></li></ul><h2 id="6-4-创建类的原因"><a href="#6-4-创建类的原因" class="headerlink" title="6.4 创建类的原因"></a>6.4 创建类的原因</h2><h3 id="创建原因"><a href="#创建原因" class="headerlink" title="创建原因"></a>创建原因</h3><ul><li>为现实世界中的对象建模。</li><li>为抽象的对象建模。</li><li>降低复杂度。</li><li>隔离复杂度。</li><li>隐藏实现细节。</li><li>限制变动的影响范围。</li><li>隐藏全局变量。（使用访问器子程序 access routine）</li><li>让参数传递更顺畅。</li><li>建立中心控制点。</li><li>让代码更易于重用。</li><li>为程序族做计划。</li><li>将相关操作包装到一起。</li><li>实现某种特定的重构。</li></ul><h3 id="应该避免的类"><a href="#应该避免的类" class="headerlink" title="应该避免的类"></a>应该避免的类</h3><ul><li>避免创建万能类。</li><li>消除无关紧要的类。</li><li>避免用动词命名的类。</li></ul><h2 id="6-5-与具体编程语言相关的问题"><a href="#6-5-与具体编程语言相关的问题" class="headerlink" title="6.5 与具体编程语言相关的问题"></a>6.5 与具体编程语言相关的问题</h2><p>不同语言之间可能有差异的地方：</p><ul><li>在继承层次中被覆盖的构造函数、析构函数的行为。</li><li>在异常处理时构造函数、析构函数的行为。</li><li>默认构造函数的重要性。</li><li>析构函数的调用时机。</li><li>覆盖运算符相关。</li><li>对象被创建和销毁时，或被声明时，或退出作用域时，处理内存的方式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全》读书笔记 第六章 可以工作的类&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Shell CheatSheet</title>
    <link href="http://ifanze.cn/2018/06/24/Shell-CheatSheet/"/>
    <id>http://ifanze.cn/2018/06/24/Shell-CheatSheet/</id>
    <published>2018-06-24T08:17:10.000Z</published>
    <updated>2018-06-26T14:15:37.897Z</updated>
    
    <content type="html"><![CDATA[<p>经常需要编写 shell 脚本进行一些自动化操作或者简单的处理，这里记录一些小技巧。</p><a id="more"></a><!-- toc --><h2 id="写好shell脚本的13个技巧"><a href="#写好shell脚本的13个技巧" class="headerlink" title="写好shell脚本的13个技巧"></a>写好shell脚本的13个技巧</h2><blockquote><p>引用：<a href="https://codeburst.io/13-tips-tricks-for-writing-shell-scripts-with-awesome-ux-19a525ae05ae">https://codeburst.io/13-tips-tricks-for-writing-shell-scripts-with-awesome-ux-19a525ae05ae</a><br>中文版：<a href="https://mp.weixin.qq.com/s/ZaIX8jv9LMWmrHQb4ew-dQ">https://mp.weixin.qq.com/s/ZaIX8jv9LMWmrHQb4ew-dQ</a></p></blockquote><h3 id="1-提供-help"><a href="#1-提供-help" class="headerlink" title="1. 提供--help"></a>1. 提供<code>--help</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -ne 0 ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;@#"--help"&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'...help...\n'</span>;</span><br><span class="line">  <span class="built_in">exit</span> 0;</span><br><span class="line"><span class="keyword">fi</span>;</span><br></pre></td></tr></table></figure><ul><li><p>学到了：</p><ul><li><code>$@</code>输出所有参数。</li><li><code>$#</code>或<code>${ #@ }</code>输出参数长度。<em>（hexo报错，这里多加了空格）</em></li><li><code>#</code>用于按最短截断字符串，<code>##</code>用于按最长截断。</li><li><code>-eq</code>、<code>-ne</code>等只能用于数值，不能用于字符串。</li><li>字符串操作：<a href="https://blog.csdn.net/dongwuming/article/details/50605911">https://blog.csdn.net/dongwuming/article/details/50605911</a></li><li>命令行参数识别：<a href="https://www.jianshu.com/p/761b19247979">https://www.jianshu.com/p/761b19247979</a></li></ul></li></ul><h3 id="2-检查所有使用命令的可用性"><a href="#2-检查所有使用命令的可用性" class="headerlink" title="2. 检查所有使用命令的可用性"></a>2. 检查所有使用命令的可用性</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">_=$(<span class="built_in">command</span> -v docker);</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">exit</span> 127;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"start..."</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>command -v</code>寻找命令，弱寻找到该命令返回0。</li><li>使用<code>$?</code>获取上条命令的退出值。</li></ul><h3 id="3-独立于当前工作目录"><a href="#3-独立于当前工作目录" class="headerlink" title="3. 独立于当前工作目录"></a>3. 独立于当前工作目录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">CURR_DIR=<span class="string">"<span class="variable">$(dirname $0)</span>"</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;CURR_DIR&#125;</span></span><br><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><ul><li><code>dirname file</code>可获取到当前目录到目标文件的相对路径。</li></ul><h3 id="4-输入使用环境变量还是参数？"><a href="#4-输入使用环境变量还是参数？" class="headerlink" title="4. 输入使用环境变量还是参数？"></a>4. 输入使用环境变量还是参数？</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do this</span></span><br><span class="line">AWS_ACCESS_TOKEN=<span class="string">'xxxxxxxxxxxx'</span> ./provision-everything</span><br><span class="line"><span class="comment"># and not</span></span><br><span class="line">./provisiong-everything --token <span class="string">'xxxxxxxxxxx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># do this</span></span><br><span class="line">./provision-everything --async --instance-count 400</span><br><span class="line"><span class="comment"># and not</span></span><br><span class="line">INSTANCE_COUNT=400 ASYNC=<span class="literal">true</span> ./provision-everything</span><br></pre></td></tr></table></figure><h3 id="5-打印对系统进行的所有操作"><a href="#5-打印对系统进行的所有操作" class="headerlink" title="5. 打印对系统进行的所有操作"></a>5. 打印对系统进行的所有操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Downloading required document to ./downloaded... '</span>;</span><br><span class="line">wget -o ./downloaded https://some.site.com/downloaded;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Moving ./downloaded to /opt/downloaded...'</span>;</span><br><span class="line">mv ./downloaded /opt/;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Creating symlink to /opt/downloaded...'</span>;</span><br><span class="line">ln -s /opt/downloaded /usr/bin/downloaded;</span><br></pre></td></tr></table></figure><ul><li><code>printf -- &quot;xxxxx&quot;</code>可以让后面的字符串原样打印。</li></ul><h3 id="6-silent模式"><a href="#6-silent模式" class="headerlink" title="6. --silent模式"></a>6. <code>--silent</code>模式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -ne 0 ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;@#"--silent"&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  stty -<span class="built_in">echo</span>;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># before point of intended output:</span></span><br><span class="line">stty +<span class="built_in">echo</span> &amp;&amp; <span class="built_in">printf</span> -- <span class="string">'intended output\n'</span>;</span><br><span class="line"><span class="comment"># silence it again till end of script</span></span><br><span class="line">stty -<span class="built_in">echo</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">stty +<span class="built_in">echo</span>;</span><br><span class="line"><span class="built_in">exit</span> 0;</span><br></pre></td></tr></table></figure><ul><li>利用<code>stty -echo</code>和<code>stty +echo</code>控制屏幕回显。但要注意如果程序中途异常状态没有设置回来。</li></ul><h3 id="7-捕获异常恢复输出显示"><a href="#7-捕获异常恢复输出显示" class="headerlink" title="7. 捕获异常恢复输出显示"></a>7. 捕获异常恢复输出显示</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">error_handle</span></span>() &#123;</span><br><span class="line">  stty <span class="built_in">echo</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -ne 0 ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;@#"--silent"&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  stty -<span class="built_in">echo</span>;</span><br><span class="line">  <span class="built_in">trap</span> error_handle INT;</span><br><span class="line">  <span class="built_in">trap</span> error_handle TERM;</span><br><span class="line">  <span class="built_in">trap</span> error_handle KILL;</span><br><span class="line">  <span class="built_in">trap</span> error_handle EXIT;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="8-动态进度条"><a href="#8-动态进度条" class="headerlink" title="8. 动态进度条"></a>8. 动态进度条</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Performing asynchronous action..'</span>;</span><br><span class="line">./trigger-action;</span><br><span class="line">DONE=0;</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$DONE</span> -eq 0 ]; <span class="keyword">do</span></span><br><span class="line">  ./async-checker;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"$?"</span> = <span class="string">"0"</span> ]; <span class="keyword">then</span> DONE=1; <span class="keyword">fi</span>;</span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'.'</span>;</span><br><span class="line">  sleep 1;</span><br><span class="line"><span class="keyword">done</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">' DONE!\n'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="http://mywiki.wooledge.org/BashFAQ/034">http://mywiki.wooledge.org/BashFAQ/034</a></p></blockquote><h3 id="9-用颜色编码输出"><a href="#9-用颜色编码输出" class="headerlink" title="9. 用颜色编码输出"></a>9. 用颜色编码输出</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"doing something... \n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[37m someone else\s output \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[32m SUCCESS: yay \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[33m WARNING: hmm \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[31m ERROR: fubar \033[0m\n"</span>;</span><br></pre></td></tr></table></figure><ul><li>有些脚本使用<code>\e</code>而不是<code>\033</code>，但要注意<code>\e</code>不适用于所有的 UNIX 系统。</li><li>所有可用颜色：<a href="https://misc.flogisoft.com/bash/tip_colors_and_formatting">https://misc.flogisoft.com/bash/tip_colors_and_formatting</a></li></ul><h3 id="10-出现错误立即退出脚本"><a href="#10-出现错误立即退出脚本" class="headerlink" title="10. 出现错误立即退出脚本"></a>10. 出现错误立即退出脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> +e;</span><br><span class="line">./script-1;</span><br><span class="line">./script-2; <span class="comment"># does not depend on ./script-1</span></span><br><span class="line">./script-3; <span class="comment"># does not depend on ./script-2</span></span><br><span class="line"><span class="built_in">set</span> -e;</span><br><span class="line">./script-4;</span><br><span class="line">./script-5; <span class="comment"># depends on success of ./script-4</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="11-自己执行清理工作"><a href="#11-自己执行清理工作" class="headerlink" title="11. 自己执行清理工作"></a>11. 自己执行清理工作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">handle_exit_code</span></span>() &#123;</span><br><span class="line">  ERROR_CODE=<span class="string">"$?"</span>;</span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">"an error occurred. cleaning up now... "</span>;</span><br><span class="line">  <span class="comment"># ... cleanup code ...</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">"DONE.\nExiting with error code <span class="variable">$&#123;ERROR_CODE&#125;</span>.\n"</span>;</span><br><span class="line">  <span class="built_in">exit</span> <span class="variable">$&#123;ERROR_CODE&#125;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"handle_exit_code"</span> EXIT;</span><br><span class="line"><span class="comment"># ... actual script...</span></span><br></pre></td></tr></table></figure><h3 id="12-在退出时使用不同的错误码"><a href="#12-在退出时使用不同的错误码" class="headerlink" title="12. 在退出时使用不同的错误码"></a>12. 在退出时使用不同的错误码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'X happened. Exiting with status code 1.\n'</span>;</span><br><span class="line">  <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'Y happened. Exiting with status code 2.\n'</span>;</span><br><span class="line">  <span class="built_in">exit</span> 2;</span><br><span class="line"><span class="keyword">fi</span>;</span><br></pre></td></tr></table></figure><h3 id="13-在结束时打印一个新行"><a href="#13-在结束时打印一个新行" class="headerlink" title="13. 在结束时打印一个新行"></a>13. 在结束时打印一个新行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># ... your awesome script ...</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">exit</span> 0;</span><br></pre></td></tr></table></figure><ul><li>最好用<code>printf</code>代替<code>echo</code>，因为后者在不同系统中行为有差别。</li><li><code>printf</code>不会像<code>echo</code>那样在命令结束后添加一个换行符。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常需要编写 shell 脚本进行一些自动化操作或者简单的处理，这里记录一些小技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="macOS" scheme="http://ifanze.cn/tags/macOS/"/>
    
      <category term="参考" scheme="http://ifanze.cn/tags/%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全2》读书笔记 5</title>
    <link href="http://ifanze.cn/2018/06/23/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(5)/"/>
    <id>http://ifanze.cn/2018/06/23/《代码大全2》(5)/</id>
    <published>2018-06-23T03:33:11.000Z</published>
    <updated>2018-06-24T12:14:07.253Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全2》读书笔记 第五章 软件构建中的设计。</p><a id="more"></a><!-- toc --><h1 id="5-软件构建中的设计"><a href="#5-软件构建中的设计" class="headerlink" title="5 软件构建中的设计"></a>5 软件构建中的设计</h1><h2 id="设计的层次"><a href="#设计的层次" class="headerlink" title="设计的层次"></a>设计的层次</h2><ol><li><p>软件系统</p><ul><li>比起直接从系统层次开始设计类，从子系统或包这些类的更高组织层次来思考往往会更好。</li></ul></li><li><p>分解为子系统和包</p><ul><li>如数据库、用户界面、业务规则、命令解释器、报表引擎等。</li><li>注意不同子系统之间的通讯规则，限制过多通信。</li><li><p>简化子系统之间的交互关系。由简单到复杂依次是：</p><ul><li>子系统A调用子系统B的子程序。</li><li>子系统A包含子系统B的类。</li><li>子系统A继承自子系统B。</li></ul></li><li><p>子系统应该是无环的。</p></li><li>程序较小时，谨慎跳过这一层的设计。</li><li><p>常见子系统：</p><ul><li>业务规则。</li><li>用户界面。</li><li>数据库访问。</li><li>对系统的依赖性。</li></ul></li></ul></li><li><p>分解为包中的类</p><ul><li>尤其要确定好接口。</li></ul></li><li><p>分解为类中的数据和子程序</p><ul><li>细化出类的私有子程序。</li></ul></li><li><p>子程序内部的设计</p><ul><li>编写伪代码。</li><li>选择算法。</li><li>组织子程序内部的代码块。</li><li>代码编写。</li></ul></li></ol><h2 id="设计构造块：启发式方法（Design-Building-Blocks-Heuristics）"><a href="#设计构造块：启发式方法（Design-Building-Blocks-Heuristics）" class="headerlink" title="设计构造块：启发式方法（Design Building Blocks: Heuristics）"></a>设计构造块：启发式方法（Design Building Blocks: Heuristics）</h2><h3 id="找到现实中的对象"><a href="#找到现实中的对象" class="headerlink" title="找到现实中的对象"></a>找到现实中的对象</h3><ul><li><p>步骤：</p><ul><li>辨识对象及其属性。</li><li>定义可对对象执行的操作。</li><li>确定每个对象可以对其他对象进行的操作。（包含、继承）</li><li>确定对象的哪些部分对其他对象可见。</li><li>定义每个对象的接口。（public接口：对其他所有对象，protected接口：对继承对象。）</li></ul></li><li><p>迭代方向：</p><ul><li>高层次的系统组织结构上。</li><li>对定义好的类进行细化。</li></ul></li></ul><h3 id="形成一定的抽象"><a href="#形成一定的抽象" class="headerlink" title="形成一定的抽象"></a>形成一定的抽象</h3><ul><li>子程序接口的层次上。</li><li>类接口的层次上。</li><li>包接口的层次上。</li></ul><h3 id="封装实现细节"><a href="#封装实现细节" class="headerlink" title="封装实现细节"></a>封装实现细节</h3><ul><li>除了从高层的细节来看待一个对象，你不能看到它的其他细节层次。</li><li>封装帮你管理复杂度的方法是不让你看到那些复杂度。</li></ul><h3 id="当继承能简化设计时就继承"><a href="#当继承能简化设计时就继承" class="headerlink" title="当继承能简化设计时就继承"></a>当继承能简化设计时就继承</h3><ul><li>继承的好处在于它能很好地辅佐抽象地概念。</li><li>技能能简化编程的工作。</li><li>使用不当也会带来很大弊端。</li></ul><h2 id="隐藏秘密（信息隐藏）"><a href="#隐藏秘密（信息隐藏）" class="headerlink" title="隐藏秘密（信息隐藏）"></a>隐藏秘密（信息隐藏）</h2><ul><li>设计类时，一个关键性的决策就是确定类的哪些特性应该对外可见，哪些应该隐藏。</li><li>类的接口应该尽可能少地暴露其内部工作机制。</li><li>设计类的接口也是一个迭代的过程。</li><li>一个例子：<code>typedef int IdType;</code>。</li><li>信息隐藏所说的秘密主要分为两大类：隐藏复杂度、隐藏变化源。</li></ul><h3 id="信息隐藏的障碍"><a href="#信息隐藏的障碍" class="headerlink" title="信息隐藏的障碍"></a>信息隐藏的障碍</h3><ul><li><strong>信息过度分散</strong>。如常量未使用宏或常量定义。</li><li><strong>循环依赖</strong>。如类A和类B调用彼此的子程序。</li><li><strong>把类内数据误认为全局数据</strong>。</li><li><strong>性能损耗</strong>。编码阶段，不用担心信息隐藏带来的性能损耗。</li></ul><h3 id="信息隐藏的价值"><a href="#信息隐藏的价值" class="headerlink" title="信息隐藏的价值"></a>信息隐藏的价值</h3><ul><li>方便修改。</li><li>启发设计。对比：使用面向对象的思想会定义<code>IdType</code>类，使设计复杂化。</li><li>有助于设计类的公开接口。不要为了追求方便暴露类的私有数据，多写代码来保护类的秘密。</li></ul><h2 id="找出容易改变的区域"><a href="#找出容易改变的区域" class="headerlink" title="找出容易改变的区域"></a>找出容易改变的区域</h2><ul><li><p>好的程序设计要适应变化，措施：</p><ul><li>找出看起来容易变化的项目。</li><li>把容易变化的项目分离出来，单独划分成类，或者集合成类。</li><li>把看起来容易变化的项目隔离开来。</li></ul></li><li><p>容易发生变化的区域：</p><ul><li>业务规则。</li><li>对硬件的依赖性。</li><li>输入和输出。</li><li>非标准的语言特性。</li><li>困难的设计区域和构建区域。</li><li><p>状态变量。</p><ul><li>将布尔换作枚举。</li><li>使用访问器子程序（access routine）取代对状态变量的直接检查。</li></ul></li><li><p>数据量的限制。</p></li></ul></li><li><p>预料不同程度的变化：</p><ul><li>让这些变化的影响或范围与发生该变化的可能性成正比。</li><li>优秀的设计者还能预料应对变化所需的成本。</li><li>好方法：找出程序中可能对用户有用的最小子集，接下来用微小的步伐扩充这个系统。</li></ul></li></ul><h2 id="保持松散耦合"><a href="#保持松散耦合" class="headerlink" title="保持松散耦合"></a>保持松散耦合</h2><ul><li><p>耦合标准：</p><ul><li><strong>规模</strong>。指模块之间的连接数，如：参数个数，公有方法个数。</li><li><strong>可见性</strong>。如：通过参数表传递优于修改全局数据。</li><li><strong>灵活性</strong>。指模块间的连接是否容易改动，包括新增一个模块使用这个连接。</li></ul></li><li><p>耦合的种类：</p><ul><li>简单的数据参数耦合：通过简单数据类型的参数来传递数据。</li><li>简单对象耦合：一个模块实例化一个对象。</li><li>对象参数耦合：对象A要求对象B传给它一个对象C。这种耦合关系比较紧密，要求对象B也了解对象C。</li><li><p>语义上的耦合：最难缠。一个模块使用了另一个模块的语法元素，还使用了它内部工作细节的语义知识。如：</p><ul><li>A向B传递一个控制标志，用它告诉B该做什么。（A需要了解B对该标志的使用）</li><li>B在A修改了某个全局数据之后使用该全局数据。（B假设A的修改符合B的要求，且A已经在恰当的时间被调用过）</li><li>A的接口要求A.init()必须先于A.proc()调用，B知道A.proc()无论如何都会调用A.init()，就没去调用A.init()。</li><li>A向B传C，因为A知道B只需要C的部分信息，就没有完全初始化C。</li><li>A向B传基类，B知道A实际传的是派生类，就直接当作派生类来用。</li></ul></li></ul></li><li><p>松散耦合使得你对一个模块的使用不用同时关注几件事——内部工作细节、全局数据修改、不确定的功能点等。否则就失去了抽象的意义，模块具有的管理复杂度的功能就丧失了。</p></li></ul><h2 id="查阅常用的设计模式"><a href="#查阅常用的设计模式" class="headerlink" title="查阅常用的设计模式"></a>查阅常用的设计模式</h2><ul><li><p>设计模式的益处：</p><ul><li>通过提供现成的抽象来减少复杂度。</li><li>把常见解决方案的细节予以制度化来减少出错。</li><li>通过提供多种设计方案带来启发。</li><li>把设计对话提升一个层次来简化交流。</li></ul></li><li><p>潜在陷阱：</p><ul><li>强迫代码适用于某个模式。</li><li>为了模式而模式。</li></ul></li></ul><h2 id="其他启发式方法"><a href="#其他启发式方法" class="headerlink" title="其他启发式方法"></a>其他启发式方法</h2><ul><li><strong>高内聚性</strong>。使类的代码集中在一个中心目标。更容易记住代码功能。</li><li><strong>构造分层结构</strong>。</li><li><strong>严格描述类契约</strong>。“如果你承诺提供数据x，y，z，且答应让这些数据具有特征a，b，c，我就承诺基于约束8，9，10，来执行操作1，2，3。”。</li><li><strong>分配职责</strong>。</li><li><strong>为测试而设计</strong>。</li><li><strong>避免失误</strong>。</li><li><strong>有意识地选择绑定时间</strong>。做早绑定的代码通常比较简单，但也缺乏灵活性。</li><li><strong>创建中央控制点</strong>。</li><li><strong>考虑使用蛮力突破</strong>。</li><li><strong>画一个图</strong>。</li><li><strong>保持设计的模块化</strong>。</li></ul><h1 id="设计实践"><a href="#设计实践" class="headerlink" title="设计实践"></a>设计实践</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全2》读书笔记 第五章 软件构建中的设计。&lt;/p&gt;
    
    </summary>
    
      <category term="《代码大全2》" scheme="http://ifanze.cn/categories/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》读书笔记 2</title>
    <link href="http://ifanze.cn/2018/06/21/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B(2)/"/>
    <id>http://ifanze.cn/2018/06/21/《深入理解计算机系统》(2)/</id>
    <published>2018-06-21T04:09:00.000Z</published>
    <updated>2018-06-24T12:10:14.294Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》读书笔记 第二章 信息的表示和处理。<br><a id="more"></a></p><h1 id="2-信息的表示和处理"><a href="#2-信息的表示和处理" class="headerlink" title="2 信息的表示和处理"></a>2 信息的表示和处理</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><ul><li><strong>字节（byte）</strong>：最小的可寻址的内存单位。</li></ul><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><ul><li>二进制、十进制、十六进制间的相互转化。</li></ul><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><ul><li>每台计算机都有一个 <strong>字长（word size）</strong>，指明指针数据的标称大小（nominal size)。</li><li>虚拟地址是以这样的一个字来编码的，所有字长决定了虚拟地址空间的最大大小（<code>0 ~ 2^w-1</code>）。</li><li>32位字长：4GB。</li><li>64位字长：16EB。</li><li>32位程序和64位程序的区别在于如何编译的，大多数64位机器也可运行32位机器编译的程序（向后兼容）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 prog.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -m64 prog.c</span></span><br></pre></td></tr></table></figure><ul><li>C语言中：<ul><li>即使是64位系统编译，<code>int</code>通常也只有4字节。</li><li>C语言中，<code>long</code>在32位程序中为4字节，在64位程序中为8字节。</li><li>ISO C99 引入了确定大小的数据类型：<code>int32_t</code>、<code>int64_t</code>。</li><li>除非有<code>unsigned</code>，类型默认是有符号的，<code>char</code>是个例外，C标准不保证这一点。</li></ul></li></ul><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x01234567</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                0x100   0x101   0x102   0x103</span></span><br><span class="line"><span class="comment">//大端法    ...     01      23      45      67      ...</span></span><br><span class="line"><span class="comment">//小端法    ...     67      45      23      01      ...</span></span><br></pre></td></tr></table></figure><ul><li><p>字节顺序很重要的场合：</p><ul><li>网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则。</li><li>阅读表示整数数据的字节序列时。如反汇编器（disassembler）生成的代码。</li><li>当编写规避正常的类型系统的程序时。如强制类型转换（cast）或使用联合（union）。</li></ul></li><li><p>值相等的整数和浮点数在字节模式上截然不同，不过一般能够通过移位相匹配。</p></li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><ul><li>以<code>0</code>结尾的字符数组。</li><li>使用ASCII码作字符码将在任何系统上得到相同的结果，与字节顺序和字大小规则无关。</li></ul><h3 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h3><ul><li>二进制代码很少能在不同机器和操作系统组合之间移植。</li></ul><h3 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h3><ul><li><code>~</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>^</code></li></ul><h3 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h3><ul><li><code>~</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>^</code></li></ul><h3 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h3><ul><li><code>&amp;&amp;</code></li><li><code>||</code></li><li><code>!</code></li></ul><h3 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h3><ul><li>左移：丢弃最高的k位，在右端补k个0。</li><li>逻辑右移：在左端补k个0。</li><li><p>算术右移：在左端补k个最高有效位的值。</p></li><li><p>C语言标准并未明确定义有符号数使用哪种右移，但几乎所有的编译器/机器都使用算术右移。</p></li><li>如果移动k位，k超过了该数据类型的长度（w位），在许多机器上，将只考虑移位<code>log(2)w</code>位。</li><li>加减运算符优先级比移位运算符高。</li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><ul><li>典型的C语言有符号整数的正负值范围是不对称的，负数多1个。</li><li>C语言标准定义的有符号整数类型必须能够表示的最小范围的正负值范围是对称的，除了<code>*32_t</code>、<code>*64_t</code>这种。</li></ul><h3 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h3><ul><li>用函数<code>B2U-w</code>表示。</li><li>无符号编码的唯一性：该函数是个双射。</li></ul><h3 id="2-2-3-补码编码（Two’s-complement）"><a href="#2-2-3-补码编码（Two’s-complement）" class="headerlink" title="2.2.3 补码编码（Two’s complement）"></a>2.2.3 补码编码（Two’s complement）</h3><ul><li>用函数<code>B2T-w</code>表示。</li><li>补码编码的唯一性：该函数是个双射。</li></ul><p>有符号数的其他表示方法：</p><ul><li>反码（Ones’ Complement）</li><li>原码（Sign-Magnitude）</li></ul><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><ul><li>用函数<code>T2U-w</code>、<code>U2T-w</code>表示。</li><li>对大多数C语言实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能改变，但位模式不变。</li><li>表现在最终数值上：<ul><li>有符号转无符号：正数不变，负数加<code>2^w</code>。</li><li>无符号转有符号：范围内不变，范围外减<code>2^w</code>。</li></ul></li></ul><h3 id="2-2-5-C语言中的有符号数与无符号数"><a href="#2-2-5-C语言中的有符号数与无符号数" class="headerlink" title="2.2.5 C语言中的有符号数与无符号数"></a>2.2.5 C语言中的有符号数与无符号数</h3><ul><li>无符号数添加后缀<code>u</code>。</li><li>显式类型转换。</li><li>隐式类型转换。</li><li>格式化输出。</li><li>运算数的转换：有符号和无符号运算，将转为无符号并假设二者都是非负的。</li><li>C语言中<code>INT_MIN</code>往往定义成<code>-INT_MAX-1</code>。</li></ul><h3 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h3><ul><li>无符号数的零扩展：添加0。</li><li>补码数的符号扩展：添加最高有效位的值。</li><li>如果即需要扩展有需要改变符号，C语言标准要求：先改变大小，再完成符号转换。</li></ul><h3 id="2-2-7-截断数值"><a href="#2-2-7-截断数值" class="headerlink" title="2.2.7 截断数值"></a>2.2.7 截断数值</h3><ul><li>截断无符号数：丢弃高位。新值为<code>x mod 2^k</code>。</li><li>截断补码数值：丢弃高位，重新解释符号位。新值为<code>U2T-k(x mod 2^k)</code></li></ul><h3 id="2-2-8-关于有符号数与无符号数的建议"><a href="#2-2-8-关于有符号数与无符号数的建议" class="headerlink" title="2.2.8 关于有符号数与无符号数的建议"></a>2.2.8 关于有符号数与无符号数的建议</h3><ul><li>可以要求绝不使用无符号数。</li><li>如果仅仅想把数字作为位的集合，无符号数是非常有用的。</li></ul><h2 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h2><h3 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h3><ul><li><code>x+y</code>若溢出，最终结果相当于<code>x+y-2^w</code>。</li><li>判断<code>x+y</code>是否溢出的方法是与<code>x</code>或<code>y</code>进行比较。</li><li>无符号数取反，<code>-x</code>，最终结果相当于<code>2^w-x</code>。（<code>0</code>除外，依然是0）。</li></ul><h3 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h3><ul><li><code>x+y</code>若溢出，最终结果相当于<code>x+y-2^w</code>（正溢出）或<code>x+y+2^w</code>（负溢出）。</li><li>当且仅当<code>x&gt;0, y&gt;0, s&lt;=0</code>时，发生了正溢出。</li><li>当且仅当<code>x&lt;0, y&lt;0, s&gt;=0</code>时，发生了负溢出。</li></ul><h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><ul><li><code>-TMin-w</code>还是<code>TMin-W</code>。其他数正常。</li><li>补码非得位级计算方式一：<code>-x</code> -&gt; <code>~x+1</code>。</li><li>补码非得位级计算方式二：找到最右边的1，将它左边的所有位取反。</li></ul><h3 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h3><ul><li><code>x*y</code>若溢出，最终结果相当于<code>x*y mod 2^w</code>。</li></ul><h3 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h3><ul><li><code>x*y</code>若溢出，最终结果相当于<code>U2T-w(x*y mod 2^w)</code>。</li><li>无符号和补码乘法的位级等价性：同样的位向量，无论是做无符号乘法还是补码乘法，最终结果的位向量都是一样的。</li></ul><h3 id="2-3-6-乘以整数"><a href="#2-3-6-乘以整数" class="headerlink" title="2.3.6 乘以整数"></a>2.3.6 乘以整数</h3><ul><li>乘以2的幂：左移。(无论是无符号还是补码，无论是否溢出)</li><li>C语言编译器会试图用移位和加法替代乘法，如<code>x*14 = (x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1);</code>，因为<code>14 = 2^3 + 2^2 + 2^1</code>，或者<code>x*14 = (x&lt;&lt;4) - (x&lt;&lt;1)</code>，因为<code>14 = 2^4 - 2^1</code>。</li></ul><h3 id="2-3-7-除以2的幂"><a href="#2-3-7-除以2的幂" class="headerlink" title="2.3.7 除以2的幂"></a>2.3.7 除以2的幂</h3><ul><li>整数的除法的结果总是向0舍入，即会向下舍入一个正值，或者向上舍入一个负值。</li><li>无符号：逻辑移位即可，即<code>x / 2^k = x &gt;&gt; k</code>，结果是向下舍入的。</li><li>补码：如果仅仅算术移位，对负数来说结果依然是向下舍入的。因此需要做点偏移：<code>x / 2^k = (x+(1&lt;&lt;k)-1) &gt;&gt; k</code>。</li></ul><h3 id="2-3-8-关于整数运算的最后思考"><a href="#2-3-8-关于整数运算的最后思考" class="headerlink" title="2.3.8 关于整数运算的最后思考"></a>2.3.8 关于整数运算的最后思考</h3><ul><li>计算机的整数运算实际上是一种模运算形式。</li><li>结果运算可能溢出。</li><li>补码提供了一种既能表示整数又能表示负数的灵活方法。</li><li>某些规定和数据类型让程序产生意想不到的行为。</li></ul><h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><ul><li>IEEE浮点标准。</li></ul><h3 id="2-4-1-二进制小数"><a href="#2-4-1-二进制小数" class="headerlink" title="2.4.1 二进制小数"></a>2.4.1 二进制小数</h3><ul><li>我们不能准确地表示一个二进制小数，只能近似地表示。</li><li>小数点左边位的权是2的正幂，右边是2的负幂。</li><li>用<code>1-ε</code>表示能表示的距离1最近且小于1的浮点数。</li></ul><h3 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h3><ul><li><p><code>V = (-1)^s * M * 2^E</code></p><ul><li>符号s（sign）。</li><li>尾数M（significand），一个二进制小数，范围在<code>1~2-ε</code>或<code>0~1-ε</code>。</li><li>阶码E（exponent）。</li></ul></li><li><p>浮点数的位表示分成三段：</p><ul><li>1位符号位。</li><li>k位阶码。<ul><li>float：8，范围：-126 ~ +127。</li><li>double：11，范围：-1022 ~ +1023。</li></ul></li><li>n位尾数。<ul><li>float：23</li><li>dobule：52</li></ul></li></ul></li><li><p>根据阶码的值，可以分为三种情况：</p><ol><li>规格化的（<code>E != 0 &amp;&amp; E != 255</code>）<ul><li>阶码部分表示成无符号数得到的值<code>e</code>并不是阶码，<code>E = e - Bias</code>，其中偏置码<code>Bias = 2^(k-1) - 1</code>。</li><li>尾数部分表示成浮点数得到的值<code>f</code>（0.xxxx）并不是尾数，为了获得额外一个精度，<code>M = f + 1</code>。即隐含的以1开头（implied leading 1）的表示。</li></ul></li><li>非规格化的（<code>E == 0</code>）<ul><li><code>E = 1 - Bias</code></li><li><code>M = f</code></li></ul></li><li>无穷大（<code>E == 0x1111..1111 &amp;&amp; M == 0</code>）、NaN（<code>E == 0x1111..1111 &amp;&amp; M != 0</code>）</li></ol></li></ul><h3 id="2-4-3-数值示例"><a href="#2-4-3-数值示例" class="headerlink" title="2.4.3 数值示例"></a>2.4.3 数值示例</h3><p><img src="http://static.ifanze.cn/CD54EFF3-B554-46AE-9124-DC2D532DA5EE.jpeg" alt=""></p><ul><li><p>比较浮点值的大小可以转化成比较无符号整型的大小。（负数时需要一些技巧，见练习2.84）</p></li><li><p>一般属性：</p><ul><li>值+0.0总有一个全为0的位表示。</li><li>最小的正非规格化值的位表示：0 000..000 000..001。其中，<code>M = f = 2^(-n)</code>，<code>E = -2^(k-1) + 2</code>。</li><li>最大的非规格化值的位表示：0 000..000 111..111。其中，<code>M = f = 1 - 2^(-n)</code>，<code>E = -2^(k-1) + 2</code>。（仅仅比最小正规格化值小一点）</li><li>最小的正规格化值的位表示：0 000..001 000..000。其中，<code>M = 1+f = 1</code>，<code>E = -2^(k-1) + 2</code>。</li><li>值1.0的位表示：0 100..000 000..000。其中，<code>M = 1+f = 1</code>，<code>E = 0</code>。</li><li>最大的正规格化值的位表示：0 111..110 111..111。其中，<code>M = 1+f = 2 - 2^(-n)</code>，<code>E = 2^(k-1) - 1</code>。</li></ul></li><li><p>练习把整数值转换成浮点形式对理解浮点表示非常有用。</p></li></ul><h3 id="2-4-4-舍入（rounding）"><a href="#2-4-4-舍入（rounding）" class="headerlink" title="2.4.4 舍入（rounding）"></a>2.4.4 舍入（rounding）</h3><ul><li>四种舍入方式：<ul><li>向偶数舍入。（可避免统计偏差。浮点数同样可用。二进制同样可用。）</li><li>向零舍入。</li><li>向下舍入。</li><li>向上舍入。</li></ul></li></ul><h3 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h3><ul><li>IEEE标准定义了一些规则，如：1/-0 = 负无穷，1/+0 = 正无穷。</li><li>实数的加法可能由于溢出得到无穷值，实数加法是可交换、不可结合的。</li><li>大多数值在浮点加法下都有逆元，无穷和NaN是例外。</li><li>浮点加法满足了单调性属性。若<code>a&gt;=b</code>，对任意<code>x</code>，<code>x+a &gt;= x+b</code>。无符号或补码加法不具备这个实数（和整数）加法的属性。</li><li>浮点乘法是可交换、不可结合的，在加法上也不具备分配性。</li><li>对于任何a、b、c（均不为NaN），浮点乘法满足如下单调性：<code>a&gt;=b &amp;&amp; c &gt;=0 =&gt; a*c &gt;= b*c</code>、<code>a&gt;=b &amp;&amp; c&lt;=0 =&gt; a*c &lt;= b*c</code>。无符号或补码的乘法没有这些单调性属性。</li><li>只要<code>a!=NaN</code>，就有<code>a * a &gt;= 0</code>。无符号或补码的乘法没有这些单调性属性。</li></ul><h3 id="2-4-6-C语言中的浮点数"><a href="#2-4-6-C语言中的浮点数" class="headerlink" title="2.4.6 C语言中的浮点数"></a>2.4.6 C语言中的浮点数</h3><ul><li>单精度和双精度使用向偶数舍入的舍入方式。</li><li>C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到无穷、NaN、-0等数值。</li><li>GCC字长引入<code>#define _GNU_SOURCE 1 #include &lt;math.h&gt;</code>来定义<code>INFINITHY</code>和<code>NAN</code>。</li><li><code>int</code>、<code>float</code>、<code>doublie</code>的互转：<ul><li><code>int</code>转<code>float</code>：不会溢出，但可能被舍入。</li><li><code>int</code>或<code>float</code>转<code>double</code>：能保留精确的数值。</li><li><code>double</code>转<code>float</code>：可能舍入，可能溢出成无穷。</li><li><code>float</code>或<code>double</code>转<code>int</code>：向零舍入，也可能溢出。C标准没对溢出做要求，Intel系微处理器指定位模式[10…00]为整数不确定值（integer indefinite），如<code>(int)+1e10</code>会得到<code>-21483648</code>。</li></ul></li></ul><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 2.1 二进制/十六进制转换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.2 二进制/十进制/十六进制转换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.3 二进制/十进制/十六进制转换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.4 十六进制加减运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.5 整数的大小端存储。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.6 值相等的整数和浮点数在字节模式上的比较。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.7 字符串的字节模式。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.8 位向量的布尔运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.9 布尔运算与三原色。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.10 使用<code>^</code>实现两数交换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.11 使用<code>^</code>交换同一地址的值时导致的问题。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.12 使用掩码提取或设置个别位上的状态。</li><li style="list-style: none"><input type="checkbox"></input> 2.13 使用“设置位”、“清除位”操作实现“或”和“异或”运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.14 布尔运算和逻辑运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.15 只使用位级和逻辑运算实现<code>x==y</code>。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.16 移位运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.17 无符号数的编码和补码编码。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.18 十六进制转补码转十进制。</li><li style="list-style: none"><input type="checkbox"></input> 2.19 有符号数转无符号数。</li><li style="list-style: none"><input type="checkbox"></input> 2.20 分析2.19。</li><li style="list-style: none"><input type="checkbox"></input> 2.21 有符号和无符号进行运算。</li><li style="list-style: none"><input type="checkbox"></input> 2.22 验证补码数的符号扩展规则。</li><li style="list-style: none"><input type="checkbox"></input> 2.23 移位和符号转换的综合运用。</li><li style="list-style: none"><input type="checkbox"></input> 2.24 截断数值。</li><li style="list-style: none"><input type="checkbox"></input> 2.25 有符号数和无符号数混用导致的错误。</li><li style="list-style: none"><input type="checkbox"></input> 2.26 有符号数和无符号数混用导致的错误。</li><li style="list-style: none"><input type="checkbox"></input> 2.27 判断两个无符号数相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.28 无符号数求反。</li><li style="list-style: none"><input type="checkbox"></input> 2.29 可能溢出的补码加法。</li><li style="list-style: none"><input type="checkbox"></input> 2.30 判断两个补码相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.31 判断两个补码相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.32 判断两个补码相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.33 补码的非。</li><li style="list-style: none"><input type="checkbox"></input> 2.34 无符号乘法和补码乘法。</li><li style="list-style: none"><input type="checkbox"></input> 2.35 判断乘法是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.36 判断乘法是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.37 修复XDR库乘法漏洞。</li><li style="list-style: none"><input type="checkbox"></input> 2.38 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.39 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.40 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.41 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.42 实现一个“除以16”的函数。</li><li style="list-style: none"><input type="checkbox"></input> 2.43 乘除综合练习。</li><li style="list-style: none"><input type="checkbox"></input> 2.44 整数运算综合练习。</li><li style="list-style: none"><input type="checkbox"></input> 2.45 二进制小数的表示。</li><li style="list-style: none"><input type="checkbox"></input> 2.46 二进制小数不精确引发的灾难性后果。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.47 填表，浮点数值范围。</li><li style="list-style: none"><input type="checkbox"></input> 2.48 推导浮点的位。</li><li style="list-style: none"><input type="checkbox"></input> 2.49 浮点精度。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.50 二进制浮点数舍入到偶数</li><li style="list-style: none"><input type="checkbox"></input> 2.51 二进制浮点数舍入引发的灾难性后果。</li><li style="list-style: none"><input type="checkbox"></input> 2.52 二进制浮点数表示与舍入综合。</li><li style="list-style: none"><input type="checkbox"></input> 2.53 定义双精度无穷和0值的宏。</li><li style="list-style: none"><input type="checkbox"></input> 2.54 整数和浮点混合计算题</li></ul><h1 id="3-程序的机器级结构"><a href="#3-程序的机器级结构" class="headerlink" title="3 程序的机器级结构"></a>3 程序的机器级结构</h1><h1 id="4-处理器体系结构"><a href="#4-处理器体系结构" class="headerlink" title="4 处理器体系结构"></a>4 处理器体系结构</h1><h1 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5 优化程序性能"></a>5 优化程序性能</h1><h1 id="6-存储器层次结构"><a href="#6-存储器层次结构" class="headerlink" title="6 存储器层次结构"></a>6 存储器层次结构</h1><h1 id="7-链接"><a href="#7-链接" class="headerlink" title="7 链接"></a>7 链接</h1><h1 id="8-异常控制流"><a href="#8-异常控制流" class="headerlink" title="8 异常控制流"></a>8 异常控制流</h1><h1 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9 虚拟内存"></a>9 虚拟内存</h1><h1 id="10-系统级I-O"><a href="#10-系统级I-O" class="headerlink" title="10 系统级I/O"></a>10 系统级I/O</h1><h1 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11 网络编程"></a>11 网络编程</h1><h1 id="12-并发编程"><a href="#12-并发编程" class="headerlink" title="12 并发编程"></a>12 并发编程</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》读书笔记 第二章 信息的表示和处理。&lt;br&gt;
    
    </summary>
    
      <category term="《深入理解计算机系统》" scheme="http://ifanze.cn/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》读书笔记 1</title>
    <link href="http://ifanze.cn/2018/06/21/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B(1)/"/>
    <id>http://ifanze.cn/2018/06/21/《深入理解计算机系统》(1)/</id>
    <published>2018-06-21T03:09:00.000Z</published>
    <updated>2018-06-24T12:10:17.283Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》读书笔记 第一章 计算机系统漫游。<br><a id="more"></a></p><h1 id="1-计算机系统漫游"><a href="#1-计算机系统漫游" class="headerlink" title="1 计算机系统漫游"></a>1 计算机系统漫游</h1><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h2><p>从一个 Hello World 程序开始。</p><h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p><img src="http://static.ifanze.cn/059DE969-4B39-4DD9-90DD-D7A19456C064.jpeg" alt=""></p><h2 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h2><ul><li>优化程序性能。</li><li>理解链接错误。</li><li>避免安全漏洞。</li></ul><h2 id="1-4-处理器读并解释存储在内存中的指令"><a href="#1-4-处理器读并解释存储在内存中的指令" class="headerlink" title="1.4 处理器读并解释存储在内存中的指令"></a>1.4 处理器读并解释存储在内存中的指令</h2><p>shell 是一个命令行解释器。</p><h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><ol><li><p>总线</p><ul><li>携带信息字节并负责在各个部件间传递。</li><li>通常设计成传送定长的字节块，也就是 <strong>字（word）</strong>。</li><li>大多数机器字长要么是4字节（32位），要么是8字节（64位）。</li></ul></li><li><p>I/O设备</p><ul><li>系统与外部世界的联系通道。</li><li>每个I/O设备都通过 <strong>控制器</strong> 或者 <strong>适配器</strong> 与I/O总线相连。</li><li>控制器是I/O设备本身或者系统的主印制电路板（主板）上的芯片组。</li><li>适配器是一块插在主板上的卡。</li></ul></li><li><p>主存</p><ul><li>临时存储设备，处理器执行程序时，用来存放程序和程序处理的数据。</li><li>物理上，由一组 <strong>动态随机存取存储器（DRAM）</strong> 芯片组成。</li><li>逻辑上，是一个线性的字节数组，每个字节都有唯一的地址（从0开始）。</li></ul></li><li><p>处理器</p><ul><li>CPU，解释（或执行）存储在主存中指令的引擎。</li><li>核心是一个大小为一个字的存储设备（或寄存器），称为 <strong>程序计数器（PC）</strong>。</li><li>任何时刻，PC都指向主存中的某条机器语言指令。</li><li>处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由 <strong>指令集架构</strong> 决定的。</li><li><p>指令所对应的简单操作并不多，它们围绕着 <strong>主存</strong>、<strong>寄存器文件（register file）</strong> 和 <strong>算术/逻辑单元（ALU）</strong> 进行。这些操作包括：</p><ul><li>加载。</li><li>存储。</li><li>操作。</li><li>跳转。</li></ul></li><li><p>现代处理器使用了非常复杂的机制来加速程序的执行。注意区分：</p><ul><li><strong>处理器的指令集架构</strong>：每条机器代码指令的效果。</li><li><strong>处理器的微体系架构</strong>：处理器实际是如何实现的。</li></ul></li></ul></li></ol><h3 id="1-4-2-运行Hello程序"><a href="#1-4-2-运行Hello程序" class="headerlink" title="1.4.2 运行Hello程序"></a>1.4.2 运行Hello程序</h3><ol><li>shell将我们输入的<code>./hello</code>逐一读入寄存器，再把它放入内存。</li><li>敲回车时，shell知道我们结束了命令的输入。shell将执行一系列指令来加载可执行的<code>hello</code>文件，将目标文件中的代码和数据从磁盘复制到主存。<ul><li>注：利用 直接存储器存取（DMA）技术，数据可以不通过处理器而字节从磁盘到达主存。</li></ul></li><li>处理器开始执行main中的机器语言指令，这些指令将字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。</li></ol><h2 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h2><ul><li>系统花费了大量时间把信息从一个地方挪到另一个地方。</li><li>根据机械原理，较大存储设备要比较小存储设备运行得慢，快速设备得造价远高于同类的低速设备。</li><li><strong>高速缓存存储器（cache memory）</strong>：作为暂时的集结区域，存放处理器近期可能会需要的信息。分为L1、L2、L3。</li></ul><h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p><img src="http://static.ifanze.cn/3DD2FD2F-67B1-4F21-A61B-5C13C9CD3ED5.jpeg" alt=""></p><h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><ul><li>shell 和 hello 程序都没有直接访问键盘、显示器、磁盘、主存等硬件，而是依靠操作系统提供服务。</li><li>操作系统的两个基本功能：<ul><li>防止硬件被失控的应用程序滥用。</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ul></li><li>操作系统使用以下几个抽象概念来实现这两个基本功能：<ul><li><strong>文件</strong>：对I/O设备的抽象。</li><li><strong>虚拟内存</strong>：对主存和磁盘I/O设备的抽象。</li><li><strong>进程</strong>：对处理器、主存和I/O设备的抽象。</li></ul></li></ul><h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><ul><li>操作系统为程序提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。</li><li><strong>并发运行</strong>：一个进程的指令和另一个进程的指令是交错执行的。</li><li><strong>上下文</strong>：操作系统保持跟踪进程运行所需的所有状态信息。</li><li><strong>上下文切换</strong>：操作系统把处理器的控制权从当前进程转移到某个新进程。它是由内核（kernel）管理的。</li><li><strong>内核</strong>：操作系统代码常驻内存的部分，不是一个独立的进程，时系统管理全部进程所用代码和数据结构的集合。</li><li>当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的 <strong>系统调用（system call）</strong> 指令，将控制权传递给内核，内核执行请求并返回应用程序。</li></ul><h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><ul><li>多线程比多进程更容易共享数据。</li><li>往往比进程更高效。</li></ul><h3 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h3><ul><li>Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的。</li></ul><p><img src="http://static.ifanze.cn/6C8172FF-0CB9-42A7-BCD6-9388D1DAEB11.jpeg" alt=""></p><ul><li>区：<ul><li><strong>程序代码和数据</strong>。代码从一个固定地址开始，紧接着C全局变量。是直接按照可执行目标文件的内容初始化的。</li><li><strong>堆</strong>。</li><li><strong>共享库</strong>。</li><li><strong>栈</strong>。</li><li><strong>内核虚拟内存</strong>。为内核保留，不允许应用程序读写或直接调用内核代码定义的函数，必须调用内核来执行这些操作。</li></ul></li></ul><h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><ul><li>文件就是字节序列。</li><li>每个I/O设备，包括磁盘、键盘、显示器、网络，等可以看成文件。</li></ul><h2 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h2><p><img src="http://static.ifanze.cn/65C98DBF-964A-42AA-AA0D-D99FB6B74B92.jpeg" alt=""></p><h2 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h2><h3 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h3><ul><li>思想：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li></ul><blockquote><p>若系统执行某应用程序需要时间为<code>T-old</code>，假设系统某部分所需执行时间与该时间的比例为<code>a</code>，而该部分性能提升比例为<code>k</code>。由此计算加速比：<br><code>S = T-old/T-new = 1 / ((1-a) + a/k)</code></p></blockquote><h3 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h3><ul><li><strong>并发（concurrency）</strong>：同时具有多个活动的系统。</li><li><strong>并行（parallelism）</strong>：用并发来使一个系统运行得更快。</li></ul><p>并行可以用在计算机系统的多个抽象层次上：</p><ol><li><p>线程级并发</p><ul><li>单处理器系统。</li><li>多处理系统。<ul><li>多核处理器。<img src="http://static.ifanze.cn/6CBC7CD7-5628-480C-A7FC-E9F9CF441ACA.jpeg" alt=""></li><li>超线程（hyperthreading），或称同时多线程（simultaneous multi-threading）。允许一个CPU执行多个控制流，它涉及到CPU某些硬件有多个备份，如程序计数器、寄存器文件。</li></ul></li></ul></li><li><p>指令级并行</p><ul><li>早期处理器，执行一条指令需要3~10个时钟周期。</li><li>现在的处理器使用了许多聪明的技巧来同时处理多达100条指令。</li><li><strong>流水线（piplining）</strong>：将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤，这些阶段可以并行地操作。</li><li>如果处理器可以达到比一个周期一条指令更快地执行速率，就称之为 <strong>超标量（super-scalar）处理器</strong>。</li></ul></li><li><p>单指令、多数据并行（SIMD并行）</p><ul><li>在最低层次上，许多现代处理器拥有特殊地硬件，允许一条指令产生多个可以并行执行地操作。</li><li>可以提高对影像、声音、视频数据地处理效率。</li><li>有些编译器会试图从C程序中自动抽取SIMD并行性，但更好地方法是用编译器支持地特殊向量数据类型来写程序。</li></ul></li></ol><h3 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h3><ul><li>再增加一个抽象：虚拟机，是对整个计算机的抽象，包括操作系统、处理器和程序。</li></ul><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 1.1 Amdahl定律公式的应用</li><li style="list-style: none"><input type="checkbox" checked></input> 1.2 Amdahl定律公式的应用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》读书笔记 第一章 计算机系统漫游。&lt;br&gt;
    
    </summary>
    
      <category term="《深入理解计算机系统》" scheme="http://ifanze.cn/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>libevent笔记</title>
    <link href="http://ifanze.cn/2018/04/16/libevent%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifanze.cn/2018/04/16/libevent笔记/</id>
    <published>2018-04-16T03:18:48.000Z</published>
    <updated>2018-06-24T09:57:47.952Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/nmathewson/libevent-book">https://github.com/nmathewson/libevent-book</a></p><a id="more"></a><!-- toc --><p>Libevent is a library for writing fast portable nonblocking IO. </p><h1 id="1-Design-Goals"><a href="#1-Design-Goals" class="headerlink" title="1 Design Goals"></a>1 Design Goals</h1><ul><li>Portability</li><li>Speed</li><li>Scalability</li><li>Convenience</li></ul><h1 id="2-Components"><a href="#2-Components" class="headerlink" title="2 Components"></a>2 Components</h1><ul><li>evutil</li><li>event &amp; event_base</li><li>bufferevent</li><li>evbuffer</li><li>evhttp</li><li>evdns</li><li>evrpc</li></ul><h1 id="3-Libraries"><a href="#3-Libraries" class="headerlink" title="3 Libraries"></a>3 Libraries</h1><ul><li>libevent_core</li><li>libevent_extra</li><li>libevent [outdated]</li><li>libevent_pthreads</li><li>libevent_openssl</li></ul><h1 id="4-Headers"><a href="#4-Headers" class="headerlink" title="4 Headers"></a>4 Headers</h1><ul><li>API headers</li><li>Compatibility headers</li><li>Structure headers</li></ul><h1 id="5-Setup"><a href="#5-Setup" class="headerlink" title="5 Setup"></a>5 Setup</h1><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_log_callback</span><span class="params">(event_log_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_log_cb)(int severity, const char *msg);</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_DEBUG 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_MSG   1</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_WARN  2 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_ERR   3 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_logging</span><span class="params">(<span class="keyword">ev_uint32_t</span> which)</span></span>;</span><br><span class="line"><span class="comment">// #define EVENT_DBG_NONE 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_DBG_ALL 0xffffffffu</span></span><br></pre></td></tr></table></figure><h2 id="Handle-Error"><a href="#Handle-Error" class="headerlink" title="Handle Error"></a>Handle Error</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_fatal_callback</span><span class="params">(event_fatal_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_fatal_cb)(int err);</span></span><br></pre></td></tr></table></figure><h2 id="Manage-Memory"><a href="#Manage-Memory" class="headerlink" title="Manage Memory"></a>Manage Memory</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_mem_functions</span><span class="params">(</span></span></span><br><span class="line">    void *(*malloc_fn)(size_t sz),</span><br><span class="line">    <span class="keyword">void</span> *(*realloc_fn)(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz),</span><br><span class="line">    <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr));</span><br></pre></td></tr></table></figure><h2 id="Locks-and-threading"><a href="#Locks-and-threading" class="headerlink" title="Locks and threading"></a>Locks and threading</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef WIN32</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_windows_threads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef _EVENT_HAVE_PTHREAD</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_pthreads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_PTHREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_lock_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_lock_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_lock_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int lock_api_version; </span></span><br><span class="line"><span class="comment">//     unsigned supported_locktypes; </span></span><br><span class="line"><span class="comment">//     void *(*alloc)(unsigned locktype); </span></span><br><span class="line"><span class="comment">//     void (*free)(void *lock, unsigned locktype); </span></span><br><span class="line"><span class="comment">//     int (*lock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">//     int (*unlock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define EVTHREAD_WRITE  0x04 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_READ   0x08 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_TRY    0x10</span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_RECURSIVE 1 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_READWRITE 2 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCK_API_VERSION 1 </span></span><br><span class="line"></span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_condition_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_condition_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_condition_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int condition_api_version; </span></span><br><span class="line"><span class="comment">//     void *(*alloc_condition)(unsigned condtype); </span></span><br><span class="line"><span class="comment">//     void (*free_condition)(void *cond); </span></span><br><span class="line"><span class="comment">//     int (*signal_condition)(void *cond, int broadcast); </span></span><br><span class="line"><span class="comment">//     int (*wait_condition)(void *cond, void *lock, const struct timeval *timeout); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_enable_lock_debugging</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_debug_unassign</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Detect-Version"><a href="#Detect-Version" class="headerlink" title="Detect Version"></a>Detect Version</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION_NUMBER 0x02000300 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION <span class="meta-string">"2.0.3-alpha"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_get_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">ev_uint32_t</span> event_get_version_number(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h2 id="Free-global-structures"><a href="#Free-global-structures" class="headerlink" title="Free global structures"></a>Free global structures</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">libevent_global_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="6-event-base"><a href="#6-event-base" class="headerlink" title="6 event_base"></a>6 event_base</h1><h2 id="Recognized-backend"><a href="#Recognized-backend" class="headerlink" title="Recognized backend"></a>Recognized backend</h2><ul><li>select</li><li>poll</li><li>epoll</li><li>kqueue</li><li>devpoll</li><li>evport</li><li>win32</li></ul><h2 id="Turn-off"><a href="#Turn-off" class="headerlink" title="Turn off"></a>Turn off</h2><ul><li>Set environment variables. e.g. <code>EVENT_NOKQUEUE</code>.</li><li>Call <code>event_config_avoid_method()</code> below.</li></ul><h2 id="New-amp-free-amp-reinit"><a href="#New-amp-free-amp-reinit" class="headerlink" title="New &amp; free &amp; reinit"></a>New &amp; free &amp; reinit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_free</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;      <span class="comment">// call after fork() in child proc</span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure><h2 id="New-with-event-config"><a href="#New-with-event-config" class="headerlink" title="New with event_config"></a>New with event_config</h2><p>To avoid specific available backend by name, or by feature.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_config *<span class="title">event_config_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct event_base <span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_config_free</span><span class="params">(struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg,<span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_require_features</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_method_feature feature)</span></span>;</span><br><span class="line"><span class="comment">// enum event_method_feature &#123;     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_ET = 0x01,     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_O1 = 0x02,     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_FDS = 0x04, </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_flag</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_base_config_flag flag)</span></span>;</span><br><span class="line"><span class="comment">// enum event_base_config_flag &#123;</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NOLOCK = 0x01,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_IGNORE_ENV = 0x02, </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_num_cpus_hint</span><span class="params">(struct event_config *cfg, <span class="keyword">int</span> cpus)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_max_dispatch_interval</span><span class="params">(struct event_config *cfg, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timeval *max_interval, <span class="keyword">int</span> max_callbacks, <span class="keyword">int</span> min_priority)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">event_get_supported_methods</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">enum</span> event_method_feature <span class="title">event_base_get_features</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>;</span><br><span class="line">event_get_method()          <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure><h2 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> n_priorities)</span></span>;    <span class="comment">// 1 ~ EVENT_MAX_PRIORITIES</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_get_npriorities</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line">event_priority_init()       <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure><h1 id="7-Event-loop"><a href="#7-Event-loop" class="headerlink" title="7 Event loop"></a>7 Event loop</h1><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>default: run until no more events registered in it.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="comment">// #define EVLOOP_ONCE             0x01 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NONBLOCK         0x02 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br></pre></td></tr></table></figure><h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct timeval *tv)</span></span>;     <span class="comment">// exit after all active events cb done.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;  <span class="comment">// exit after current one cb done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_exit</span><span class="params">(struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_break</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopcontinue</span><span class="params">(struct event_base *)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="internal-time-cache"><a href="#internal-time-cache" class="headerlink" title="internal time cache"></a>internal time cache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_gettimeofday_cached</span><span class="params">(struct event_base *base, struct timeval *tv_out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_update_cache_time</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="dump-status"><a href="#dump-status" class="headerlink" title="dump status"></a>dump status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_dump_events</span><span class="params">(struct event_base *base, FILE *f)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="iterate-events"><a href="#iterate-events" class="headerlink" title="iterate events"></a>iterate events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_foreach_event</span><span class="params">(struct event_base *base, event_base_foreach_event_cb fn, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// typedef int (*event_base_foreach_event_cb)(const struct event_base *, const struct event *, void *)</span></span><br></pre></td></tr></table></figure><h2 id="obsolete-methods"><a href="#obsolete-methods" class="headerlink" title="obsolete methods"></a>obsolete methods</h2><ul><li><code>event_dispatch()</code></li><li><code>event_loop()</code></li><li><code>event_loopexit()</code></li><li><code>event_loopbreak()</code></li></ul><h1 id="8-Events"><a href="#8-Events" class="headerlink" title="8 Events"></a>8 Events</h1><h2 id="conditions"><a href="#conditions" class="headerlink" title="conditions:"></a>conditions:</h2><ul><li>fd being ready to read from or write to.</li><li>fd becoming ready to read from or write to (Edge-triggered IO only).</li><li>a timeout expiring.</li><li>a signal occuring.</li><li>a user-triggered event.</li></ul><h2 id="status"><a href="#status" class="headerlink" title="status:"></a>status:</h2><ul><li>initialized -&gt; pending (by <code>add</code>)</li><li>pending -&gt; active (condition trigger an event occur, cb run)</li><li>active -&gt; pending (persistent) -&gt; <code>delete</code> -&gt; non-pending -&gt; <code>add</code> -&gt; pending</li><li>active -&gt; non-pending (non-persistent)</li></ul><h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, event_callback_fn cb, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="comment">// typedef void (*event_callback_fn)(evutil_socket_t, short, void *); </span></span><br><span class="line"><span class="comment">// #define EV_TIMEOUT      0x01 </span></span><br><span class="line"><span class="comment">// #define EV_READ         0x02 </span></span><br><span class="line"><span class="comment">// #define EV_WRITE        0x04 </span></span><br><span class="line"><span class="comment">// #define EV_SIGNAL       0x08 </span></span><br><span class="line"><span class="comment">// #define EV_PERSIST      0x10 </span></span><br><span class="line"><span class="comment">// #define EV_ET           0x20 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>You can’t create an event that receives itself as a cb argument. Instead:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_self_cbarg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Timeout-only-events"><a href="#Timeout-only-events" class="headerlink" title="Timeout-only events"></a>Timeout-only events</h2><p>no benefit beyond clarifying your code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(base, callback, arg) \     </span></span><br><span class="line">event_new((base), <span class="number">-1</span>, <span class="number">0</span>, (callback), (arg)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv) \    </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_pending(ev, tv_out) \     </span></span><br><span class="line">event_pending((ev), EV_TIMEOUT, (tv_out))</span><br></pre></td></tr></table></figure><h2 id="Signal-events"><a href="#Signal-events" class="headerlink" title="Signal events"></a>Signal events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(base, signum, cb, arg) \     </span></span><br><span class="line">event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv) \     </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, what, tv_out) \     </span></span><br><span class="line">event_pending((ev), (what), (tv_out))</span><br></pre></td></tr></table></figure><ul><li>Don’t set a timeout on a signal event.</li><li>It’s safe to call functions that you aren’t supposed to call from a regulat POSIX signal handler.</li><li>With most backends, only one event_base per process at a time can be listening for signals. If you add signal events to two event_base at once - even if the signals are different - only one event_base will receive signals. (kqueue doesn’t have this limitation.)</li></ul><h2 id="Heap-allocation-events"><a href="#Heap-allocation-events" class="headerlink" title="Heap-allocation events"></a>Heap-allocation events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int event_assign(struct event *event, struct event_base *base, evutil_socket_t fd, short what, void (*callback)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_assign(event, base, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, <span class="number">-1</span>, <span class="number">0</span>, callback, arg) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(event, base, signum, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, signum, EV_SIGNAL|EV_PERSIST, callback, arg)</span><br></pre></td></tr></table></figure><ul><li>Your code won’t be binary-compatible with future versions of libevent as the size of a event may differ. To check, make use of this function:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> event_get_struct_event_size(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li>May return a value less than <code>sizeof(event)</code> because of padding bytes at the end.</li><li>Never call <code>event_assign</code> on an event that is already pending. call <code>event_del()</code> first.</li></ul><h2 id="Pending-and-Non-pending"><a href="#Pending-and-Non-pending" class="headerlink" title="Pending and Non-pending"></a>Pending and Non-pending</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_remove_timer</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *event, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Inspecting-Event-Status"><a href="#Inspecting-Event-Status" class="headerlink" title="Inspecting Event Status"></a>Inspecting Event Status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, <span class="keyword">short</span> what, struct timeval *tv_out)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> event_get_fd(<span class="keyword">const</span> struct event *ev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; <span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event, struct event_base **base_out, <span class="keyword">evutil_socket_t</span> *fd_out, <span class="keyword">short</span> *events_out, event_callback_fn *callback_out, <span class="keyword">void</span> **arg_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event *<span class="title">event_base_get_running_event</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="One-off-events"><a href="#One-off-events" class="headerlink" title="One-off events"></a>One-off events</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure><ul><li>If you don’t need to add an event more than once, or delete it once it has been added, and it doesn’t have to persistent, use <code>event_base_once</code>.</li><li>It doesn’t support <code>EV_SIGNAL</code> or <code>EV_PERSIST</code>.</li><li>Can’t be deleted or manually activated.</li></ul><h2 id="Manually-activating-an-event"><a href="#Manually-activating-an-event" class="headerlink" title="Manually activating an event"></a>Manually activating an event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *ev, <span class="keyword">int</span> what, <span class="keyword">short</span> ncalls)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Don’t calling <code>event_active</code> recursively on the same event.</li></ul><h2 id="Optimizing-common-timeouts"><a href="#Optimizing-common-timeouts" class="headerlink" title="Optimizing common timeouts"></a>Optimizing common timeouts</h2><ul><li>Libevent use a binary algorithm to keep track of pending events’ timeouts, which gives performance of O(lg n) for adding and deleting each event timeout.</li><li>If you have a large number of events with the same timeout, a doubly-linked queue will be better.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct timeval *<span class="title">event_base_init_common_timeout</span><span class="params">( struct event_base *base, <span class="keyword">const</span> struct timeval *duration)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Distinguish-an-initialized-event-and-a-cleared-event"><a href="#Distinguish-an-initialized-event-and-a-cleared-event" class="headerlink" title="Distinguish an initialized event and a cleared event"></a>Distinguish an initialized event and a cleared event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_initialized</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_initialized(ev) event_initialized(ev) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_initialized(ev) event_initialized(ev)</span></span><br></pre></td></tr></table></figure><h1 id="9-Helper"><a href="#9-Helper" class="headerlink" title="9 Helper"></a>9 Helper</h1><h2 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h2><ul><li><p>evutil_socket_t  </p></li><li><p>ev_uint64_t       EV_UINT64_MAX       0</p></li><li>ev_int64_t        EV_INT64_MAX        EV_INT64_MIN</li><li>ev_uint32_t       EV_UINT32_MAX       0</li><li>ev_int32_t        EV_INT32_MAX        EV_INT32_MIN</li><li>ev_uint16_t       EV_UINT16_MAX       0</li><li>ev_int16_t        EV_INT16_MAX        EV_INT16_MIN</li><li>ev_uint8_t        EV_UINT8_MAX        0</li><li><p>ev_int8_t         EV_INT8_MAX         EV_INT8_MIN</p></li><li><p>ev_ssize_t        EV_SSIZE_MIN        EV_SSIZE_MAX</p></li><li>ev_off_t          </li><li>ev_socket_t</li><li>ev_intptr_t</li><li>ev_uintptr_t</li></ul><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timeradd(tvp, uvp, vvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timersub(tvp, uvp, vvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerisset(tvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timercmp(tvp, uvp, cmp)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_closesocket</span><span class="params">(<span class="keyword">evutil_socket_t</span> s)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SOCKET_ERROR() </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SET_SOCKET_ERROR(errcode) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_geterror(sock) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_error_to_string(errcode)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_nonblocking</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_listen_socket_reuseable</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_closeonexec</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">evutil_socket_t</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_int64_t</span> evutil_strtoll(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">char</span> **endptr, <span class="keyword">int</span> base);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_snprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strcasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strncasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">evutil_inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_parse_sockaddr_port</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, struct sockaddr *out, <span class="keyword">int</span> *outlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_sockaddr_cmp</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa1, <span class="keyword">const</span> struct sockaddr *sa2, <span class="keyword">int</span> include_port)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_offsetof(type, field) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_get_bytes</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_secure_rng_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_add_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dat, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="10-Bufferevents"><a href="#10-Bufferevents" class="headerlink" title="10 Bufferevents"></a>10 Bufferevents</h1><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><ul><li>socket-based bufferevents</li><li>asynchronous-IO bufferevents (Windows only, experimental)</li><li>filtering bufferevents</li><li>paired bufferevents</li></ul><h2 id="Watermarks"><a href="#Watermarks" class="headerlink" title="Watermarks"></a>Watermarks</h2><ul><li>Read low-water mark</li><li>Read high-water mark</li><li>Write low-water mark</li><li>Write high-water mark</li></ul><h2 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h2><ul><li><code>BEV_EVENT_READING</code></li><li><code>BEV_EVENT_WRITING</code></li><li><code>BEV_EVENT_ERROR</code></li><li><code>BEV_EVENT_TIMEOUT</code></li><li><code>BEV_EVENT_EOF</code></li><li><code>BEV_EVENT_CONNECTED</code></li></ul><h2 id="Option-Flags"><a href="#Option-Flags" class="headerlink" title="Option Flags"></a>Option Flags</h2><ul><li><code>BEV_OPT_CLOSE_ON_FREE</code></li><li><code>BEV_OPT_THREADSAFE</code></li><li><code>BEV_OPT_DEFER_CALLBACKS</code></li><li><code>BEV_OPT_UNLOCK_CALLBACKS</code></li></ul><h1 id="11-Socket-based-Bufferevents"><a href="#11-Socket-based-Bufferevents" class="headerlink" title="11 Socket-based Bufferevents"></a>11 Socket-based Bufferevents</h1><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">enum</span> bufferevent_options options)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>fd 需要时 non-blocking 的，可以使用<code>evutil_make_socket_nonblocking()</code>。</li><li>不想现在指定 fd 可以将其设为 -1。</li></ul><h2 id="Launch"><a href="#Launch" class="headerlink" title="Launch"></a>Launch</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, struct sockaddr *address, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect_hostname</span><span class="params">(struct bufferevent *bev, struct evdns_base *dns_base, <span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">int</span> port)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_get_dns_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>If no socket set, it will allocates a new nonblocking one.</li></ul><h2 id="Generic-operations"><a href="#Generic-operations" class="headerlink" title="Generic operations"></a>Generic operations</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_getcb</span><span class="params">(struct bufferevent *bufev, bufferevent_data_cb *readcb_ptr, bufferevent_data_cb *writecb_ptr, bufferevent_event_cb *eventcb_ptr, <span class="keyword">void</span> **cbarg_ptr)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx); </span></span><br><span class="line"><span class="comment">// typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>; <span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>; <span class="comment">// EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>; <span class="comment">// EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setwatermark</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events, <span class="keyword">size_t</span> lowmark, <span class="keyword">size_t</span> highmark)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>bufferevent_free</code> will free the bufferevent as soon as possible, probably won’t flush data on write buffer.</li><li><code>BEV_OPT_CLOSE_ON_FREE</code> will close its transport underlying it - such as socket - when free.</li><li>By default, a newly created bufferevent has writing enabled, but not reading. </li></ul><h2 id="Manipulate-Data"><a href="#Manipulate-Data" class="headerlink" title="Manipulate Data"></a>Manipulate Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_input</span><span class="params">(struct bufferevent *bufev)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_output</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> bufferevent_read(struct bufferevent *bufev, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size); </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_read_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_set_timeouts</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> struct timeval *timeout_read, <span class="keyword">const</span> struct timeval *timeout_write)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_flush</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> iotype, <span class="keyword">enum</span> bufferevent_flush_mode state)</span></span>; </span><br><span class="line"><span class="comment">// iotype: EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="comment">// state: BEV_NORMAL, BEV_FLUSH, or BEV_FINISHED</span></span><br></pre></td></tr></table></figure><ul><li>It won’t be timeout if r/w is disabled or no data to r/w.</li><li>If timeout, invoke cb with <code>BEV_EVENT_TIMEOUT|BEV_EVENT_READING</code> or <code>BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING</code>.</li></ul><h2 id="Type-specific-functions"><a href="#Type-specific-functions" class="headerlink" title="Type-specific functions"></a>Type-specific functions</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket-based only</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_priority_set</span><span class="params">(struct bufferevent *bufev, <span class="keyword">int</span> pri)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_get_priority</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_setfd</span><span class="params">(struct bufferevent *bufev, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="keyword">evutil_socket_t</span> bufferevent_getfd(struct bufferevent *bufev);</span><br><span class="line"></span><br><span class="line"><span class="function">struct event_base *<span class="title">bufferevent_get_base</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_get_underlying</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Locking-and-Unlocking"><a href="#Locking-and-Unlocking" class="headerlink" title="Locking and Unlocking"></a>Locking and Unlocking</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_lock</span><span class="params">(struct bufferevent *bufev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_unlock</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Required threading support activated and <code>BEV_OPT_THREADSAFE</code> on creation.</li></ul><h1 id="12-Bufferevents-Advanced-topics"><a href="#12-Bufferevents-Advanced-topics" class="headerlink" title="12 Bufferevents: Advanced topics"></a>12 Bufferevents: Advanced topics</h1><h2 id="Paired-bufferevents"><a href="#Paired-bufferevents" class="headerlink" title="Paired bufferevents"></a>Paired bufferevents</h2><p>All bytes written on one are received on the other, without via the network stack.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_pair_new</span><span class="params">(struct event_base *base, <span class="keyword">int</span> options, struct bufferevent *pair[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_pair_get_partner</span><span class="params">(struct bufferevent *bev)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>BEV_OPT_CLOSE_ON_FREE</code> has no effect.</li><li><code>BEV_OPT_DEFER_CALLBACKS</code> is always on.</li></ul><h2 id="Filtering-bufferevents"><a href="#Filtering-bufferevents" class="headerlink" title="Filtering bufferevents"></a>Filtering bufferevents</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct bufferevent *bufferevent_filter_new(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void (*free_context)(void *), void *ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum bufferevent_filter_result &#123;         </span></span><br><span class="line"><span class="comment">//     BEV_OK = 0,         </span></span><br><span class="line"><span class="comment">//     BEV_NEED_MORE = 1,         </span></span><br><span class="line"><span class="comment">//     BEV_ERROR = 2 </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"><span class="comment">// typedef enum bufferevent_filter_result (*bufferevent_filter_cb)( </span></span><br><span class="line"><span class="comment">//     struct evbuffer *source, </span></span><br><span class="line"><span class="comment">//     struct evbuffer *destination, </span></span><br><span class="line"><span class="comment">//     ev_ssize_t dst_limit, </span></span><br><span class="line"><span class="comment">//     enum bufferevent_flush_mode mode, </span></span><br><span class="line"><span class="comment">//     void *ctx</span></span><br><span class="line"><span class="comment">// );</span></span><br></pre></td></tr></table></figure><h2 id="Limit-max-single-r-w-size"><a href="#Limit-max-single-r-w-size" class="headerlink" title="Limit max single r/w size"></a>Limit max single r/w size</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_max_single_read</span><span class="params">(struct bufferevent *bev, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_max_single_write</span><span class="params">(struct bufferevent *bev, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_single_read(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_single_write(struct bufferevent *bev);</span><br></pre></td></tr></table></figure><h2 id="Rate-limiting"><a href="#Rate-limiting" class="headerlink" title="Rate-limiting"></a>Rate-limiting</h2><p>algorithm: token bucket.</p><ul><li>read bucket &amp; write bucket.</li><li>refill rate: determines the max average rate.</li><li>max burst size: determines the max number of bytes that will be r/w in a single burst.</li><li>timing unit: smoothness of the traffic.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_RATE_LIMIT_MAX EV_SSIZE_MAX </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ev_token_bucket_cfg</span>;</span> </span><br><span class="line"><span class="function">struct ev_token_bucket_cfg *<span class="title">ev_token_bucket_cfg_new</span><span class="params">(         </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> read_rate, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> read_burst,         </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> write_rate, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> write_burst, c</span></span></span><br><span class="line"><span class="function"><span class="params">    onst struct timeval *tick_len</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_token_bucket_cfg_free</span><span class="params">(struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_rate_limit</span><span class="params">(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Rate-limiting-on-group"><a href="#Rate-limiting-on-group" class="headerlink" title="Rate-limiting on group"></a>Rate-limiting on group</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_rate_limit_group</span>;</span> </span><br><span class="line"><span class="function">struct bufferevent_rate_limit_group *<span class="title">bufferevent_rate_limit_group_new</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_set_cfg</span><span class="params">(struct bufferevent_rate_limit_group *group, <span class="keyword">const</span> struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_free</span><span class="params">(struct bufferevent_rate_limit_group *)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_add_to_rate_limit_group</span><span class="params">(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_remove_from_rate_limit_group</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Inspecting-rate-limiting"><a href="#Inspecting-rate-limiting" class="headerlink" title="Inspecting rate-limiting"></a>Inspecting rate-limiting</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_read_limit(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_write_limit(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_rate_limit_group_get_read_limit( struct bufferevent_rate_limit_group *); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_rate_limit_group_get_write_limit( struct bufferevent_rate_limit_group *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_to_read(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_to_write(struct bufferevent *bev);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_get_totals</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_uint64_t</span> *total_read_out, <span class="keyword">ev_uint64_t</span> *total_written_out)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_reset_totals</span><span class="params">( struct bufferevent_rate_limit_group *grp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Manually-adjusting-rate-limits"><a href="#Manually-adjusting-rate-limits" class="headerlink" title="Manually adjusting rate limits"></a>Manually adjusting rate limits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_decrement_read_limit</span><span class="params">(struct bufferevent *bev, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_decrement_write_limit</span><span class="params">(struct bufferevent *bev, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_decrement_read</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_decrement_write</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_ssize_t</span> decr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Setting-the-smallest-share-possible-in-a-rate-limited-group"><a href="#Setting-the-smallest-share-possible-in-a-rate-limited-group" class="headerlink" title="Setting the smallest share possible in a rate-limited group "></a>Setting the smallest share possible in a rate-limited group </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_set_min_share</span><span class="params">( struct bufferevent_rate_limit_group *group, <span class="keyword">size_t</span> min_share)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Bufferevents-and-SSL"><a href="#Bufferevents-and-SSL" class="headerlink" title="Bufferevents and SSL"></a>Bufferevents and SSL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bufferevent_ssl_state &#123;         </span><br><span class="line">    BUFFEREVENT_SSL_OPEN = <span class="number">0</span>,         </span><br><span class="line">    BUFFEREVENT_SSL_CONNECTING = <span class="number">1</span>,         </span><br><span class="line">    BUFFEREVENT_SSL_ACCEPTING = <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_openssl_filter_new</span><span class="params">(struct event_base *base, struct bufferevent *underlying, SSL *ssl, <span class="keyword">enum</span> bufferevent_ssl_state state, <span class="keyword">int</span> options)</span></span>; </span><br><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_openssl_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, SSL *ssl, <span class="keyword">enum</span> bufferevent_ssl_state state, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SSL *<span class="title">bufferevent_openssl_get_ssl</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">bufferevent_get_openssl_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_ssl_renegotiate</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_openssl_get_allow_dirty_shutdown</span><span class="params">(struct bufferevent *bev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_openssl_set_allow_dirty_shutdown</span><span class="params">(struct bufferevent *bev, <span class="keyword">int</span> allow_dirty_shutdown)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="13-Evbuffers"><a href="#13-Evbuffers" class="headerlink" title="13 Evbuffers"></a>13 Evbuffers</h1><h2 id="Create-amp-free"><a href="#Create-amp-free" class="headerlink" title="Create &amp; free"></a>Create &amp; free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">evbuffer_new</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_free</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Thread-Safety"><a href="#Thread-Safety" class="headerlink" title="Thread-Safety"></a>Thread-Safety</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_enable_locking</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *lock)</span></span>;  <span class="comment">// NULL is legal, it will allocate a new lock.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_lock</span><span class="params">(struct evbuffer *buf)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_unlock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Inspecting-an-evbuffer"><a href="#Inspecting-an-evbuffer" class="headerlink" title="Inspecting an evbuffer"></a>Inspecting an evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_length(<span class="keyword">const</span> struct evbuffer *buf);</span><br><span class="line"><span class="keyword">size_t</span> evbuffer_get_contiguous_space(<span class="keyword">const</span> struct evbuffer *buf);</span><br></pre></td></tr></table></figure><h2 id="Adding-Data"><a href="#Adding-Data" class="headerlink" title="Adding Data"></a>Adding Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_printf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_vprintf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_expand</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Move-Data"><a href="#Move-Data" class="headerlink" title="Move Data"></a>Move Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer *src)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_buffer</span><span class="params">(struct evbuffer *src, struct evbuffer *dst, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Adding-Data-to-the-front"><a href="#Adding-Data-to-the-front" class="headerlink" title="Adding Data to the front"></a>Adding Data to the front</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer* src)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Rearranging-the-internal-layout"><a href="#Rearranging-the-internal-layout" class="headerlink" title="Rearranging the internal layout"></a>Rearranging the internal layout</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">evbuffer_pullup</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Remove-Data"><a href="#Remove-Data" class="headerlink" title="Remove Data "></a>Remove Data </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_drain</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Copying-Data"><a href="#Copying-Data" class="headerlink" title="Copying Data"></a>Copying Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout_from(struct evbuffer *buf, <span class="keyword">const</span> struct evbuffer_ptr *pos, <span class="keyword">void</span> *data_out, <span class="keyword">size_t</span> datlen);</span><br></pre></td></tr></table></figure><h2 id="Line-oriented-Input"><a href="#Line-oriented-Input" class="headerlink" title="Line-oriented Input"></a>Line-oriented Input</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evbuffer_readln</span><span class="params">(struct evbuffer *buffer, <span class="keyword">size_t</span> *n_read_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"><span class="comment">// enum evbuffer_eol_style &#123;         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_ANY,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_CRLF,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_CRLF_STRICT,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_LF,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_NUL </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search</span><span class="params">(struct evbuffer *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_range</span><span class="params">(struct evbuffer *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start, <span class="keyword">const</span> struct evbuffer_ptr *end)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_eol</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *start, <span class="keyword">size_t</span> *eol_len_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"><span class="comment">// struct evbuffer_ptr &#123;         </span></span><br><span class="line"><span class="comment">//     ev_ssize_t pos; </span></span><br><span class="line"><span class="comment">//     struct &#123;                 </span></span><br><span class="line"><span class="comment">//         /* internal fields */        </span></span><br><span class="line"><span class="comment">//     &#125; _internal; </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_ptr_set</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *pos, <span class="keyword">size_t</span> position, <span class="keyword">enum</span> evbuffer_ptr_how how)</span></span>;</span><br><span class="line"><span class="comment">// enum evbuffer_ptr_how &#123;         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_PTR_SET,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_PTR_ADD </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Inspecting-data-without-copying-it"><a href="#Inspecting-data-without-copying-it" class="headerlink" title="Inspecting data without copying it"></a>Inspecting data without copying it</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_peek</span><span class="params">(struct evbuffer *buffer, <span class="keyword">ev_ssize_t</span> len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec_out, <span class="keyword">int</span> n_vec)</span></span>;</span><br><span class="line"><span class="comment">// struct evbuffer_iovec &#123; </span></span><br><span class="line"><span class="comment">//     void *iov_base;         </span></span><br><span class="line"><span class="comment">//     size_t iov_len; </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Adding-data-to-an-evbuffer-directly"><a href="#Adding-data-to-an-evbuffer-directly" class="headerlink" title="Adding data to an evbuffer directly"></a>Adding data to an evbuffer directly</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_reserve_space</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_commit_space</span><span class="params">(struct evbuffer *buf, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Network-IO-with-evbuffers"><a href="#Network-IO-with-evbuffers" class="headerlink" title="Network IO with evbuffers"></a>Network IO with evbuffers</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write_atmost</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">ev_ssize_t</span> howmuch)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_read</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> howmuch)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Evbuffers-and-callbacks"><a href="#Evbuffers-and-callbacks" class="headerlink" title="Evbuffers and callbacks"></a>Evbuffers and callbacks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_entry</span>;</span> </span><br><span class="line"><span class="function">struct evbuffer_cb_entry *<span class="title">evbuffer_add_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);</span></span><br><span class="line"><span class="comment">// struct evbuffer_cb_info &#123;         </span></span><br><span class="line"><span class="comment">//     size_t orig_size;         </span></span><br><span class="line"><span class="comment">//     size_t n_added;         </span></span><br><span class="line"><span class="comment">//     size_t n_deleted; </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb_entry</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *ent)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVBUFFER_CB_ENABLED 1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_set_flags</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_clear_flags</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_defer_callbacks</span><span class="params">(struct evbuffer *buffer, struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Avoiding-data-copies-with-evbuffer-based-IO"><a href="#Avoiding-data-copies-with-evbuffer-based-IO" class="headerlink" title="Avoiding data copies with evbuffer-based IO"></a>Avoiding data copies with evbuffer-based IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_reference</span><span class="params">(struct evbuffer *outbuf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen, evbuffer_ref_cleanup_cb cleanupfn, <span class="keyword">void</span> *extra)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evbuffer_ref_cleanup_cb)(const void *data, size_t datalen, void *extra);</span></span><br></pre></td></tr></table></figure><h2 id="Adding-a-file-to-an-evbuffer"><a href="#Adding-a-file-to-an-evbuffer" class="headerlink" title="Adding a file to an evbuffer"></a>Adding a file to an evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_file</span><span class="params">(struct evbuffer *output, <span class="keyword">int</span> fd, <span class="keyword">ev_off_t</span> offset, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Fine-grained-control-with-file-segments"><a href="#Fine-grained-control-with-file-segments" class="headerlink" title="Fine-grained control with file segments"></a>Fine-grained control with file segments</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_file_segment</span>;</span> </span><br><span class="line"><span class="function">struct evbuffer_file_segment *<span class="title">evbuffer_file_segment_new</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">ev_off_t</span> offset, <span class="keyword">ev_off_t</span> length, <span class="keyword">unsigned</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_file_segment_free</span><span class="params">(struct evbuffer_file_segment *seg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_file_segment</span><span class="params">(struct evbuffer *buf, struct evbuffer_file_segment *seg, <span class="keyword">ev_off_t</span> offset, <span class="keyword">ev_off_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_file_segment_cleanup_cb)</span><span class="params">( struct evbuffer_file_segment <span class="keyword">const</span> *seg, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_file_segment_add_cleanup_cb</span><span class="params">(struct evbuffer_file_segment *seg, evbuffer_file_segment_cleanup_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Adding-an-evbuffer-to-another-by-reference"><a href="#Adding-an-evbuffer-to-another-by-reference" class="headerlink" title="Adding an evbuffer to another by reference"></a>Adding an evbuffer to another by reference</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer_reference</span><span class="params">(struct evbuffer *outbuf, struct evbuffer *inbuf)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Making-an-evbuffer-add-or-remove-only"><a href="#Making-an-evbuffer-add-or-remove-only" class="headerlink" title="Making an evbuffer add- or remove-only"></a>Making an evbuffer add- or remove-only</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_freeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_unfreeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="14-Connection-listeners-evconnlistener"><a href="#14-Connection-listeners-evconnlistener" class="headerlink" title="14 Connection listeners: evconnlistener "></a>14 Connection listeners: evconnlistener </h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">int</span> socklen)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evconnlistener_cb)(struct evconnlistener *listener, evutil_socket_t sock, struct sockaddr *addr, int len, void *ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_disable</span><span class="params">(struct evconnlistener *lev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_enable</span><span class="params">(struct evconnlistener *lev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">evutil_socket_t</span> evconnlistener_get_fd(struct evconnlistener *lev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">evconnlistener_get_base</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_error_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_errorcb errorcb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evconnlistener_errorcb)(struct evconnlistener *lis, void *ptr);</span></span><br></pre></td></tr></table></figure><p>flag:</p><ul><li><code>LEV_OPT_LEAVE_SOCKETS_BLOCKING</code></li><li><code>LEV_OPT_CLOSE_ON_FREE</code></li><li><code>LEV_OPT_CLOSE_ON_EXEC</code></li><li><code>LEV_OPT_REUSEABLE</code></li><li><code>LEV_OPT_THREADSAFE</code></li><li><code>LEV_OPT_DISABLED</code></li><li><code>LEV_OPT_DEFERRED_ACCEPT</code></li></ul><h1 id="15-Use-DNS"><a href="#15-Use-DNS" class="headerlink" title="15 Use DNS"></a>15 Use DNS</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/nmathewson/libevent-book&quot;&gt;https://github.com/nmathewson/libevent-book&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="libevent" scheme="http://ifanze.cn/tags/libevent/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》笔记</title>
    <link href="http://ifanze.cn/2018/04/10/%E3%80%8AEffective%20C++%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifanze.cn/2018/04/10/《Effective C++》笔记/</id>
    <published>2018-04-10T08:53:56.000Z</published>
    <updated>2018-06-24T10:09:09.025Z</updated>
    
    <content type="html"><![CDATA[<p>刚入职时看《Effective C++》记录的笔记</p><a id="more"></a><!-- toc --><h1 id="0-导读"><a href="#0-导读" class="headerlink" title="0 导读"></a>0 导读</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>声明式（declaration）。</li><li>签名式（signature）。</li><li>定义式（definition）。</li><li><p>初始化（initialization）。</p></li><li><p>default 构造函数是一个可被调用而不带任何实参的函数，或者每个参数都有缺省值。</p></li><li>用 <code>explicit</code> 修饰的构造函数不能执行隐式类型转换。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x  = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>);       <span class="comment">//错误</span></span><br><span class="line">doSomething(B(<span class="number">28</span>));    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>copy construction 被用来“以同型对象初始化自我对象”。</li><li>copy assignment 被用来“从另一个同型对象中拷贝其值到自我对象”。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();                                       <span class="comment">// default construction</span></span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);                      <span class="comment">// copy construction</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);           <span class="comment">// copy assignment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w1;                            <span class="comment">// default construction</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;                    <span class="comment">// copy construction</span></span><br><span class="line">Widget w3 = w2;                  <span class="comment">// copy construction</span></span><br><span class="line">w1 = w2;                              <span class="comment">// copy assignment</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doSomething</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">doSomething(w1);              <span class="comment">// copy construction (passed by value)</span></span><br></pre></td></tr></table></figure><ul><li>undefined behavior。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::out &lt;&lt; *p;</span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> c = name[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1 让自己习惯C++"></a>1 让自己习惯C++</h1><h2 id="条款01：View-C-as-a-federation-of-languages"><a href="#条款01：View-C-as-a-federation-of-languages" class="headerlink" title="条款01：View C++ as a federation of languages."></a>条款01：View C++ as a federation of languages.</h2><p>C++ 现在已经是一个多重范型编程语言（multiparadigm programming language），同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式(metaprogramming）。</p><p>可将 C++ 视为由以下几个次语言构成：</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><h2 id="条款02：Prefer-consts-enums-and-inlines-to-defines"><a href="#条款02：Prefer-consts-enums-and-inlines-to-defines" class="headerlink" title="条款02：Prefer consts, enums, and inlines to #defines."></a>条款02：Prefer consts, enums, and inlines to #defines.</h2><p>使用 const 替换 #define 的好处：</p><ul><li>方便追踪编译错误。</li><li>使用 symbolic debugger 时将其记录进符号表。</li></ul><p>注意两点：</p><ul><li>Constant pointers 的 const 有两种形式：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> name = <span class="string">"Scott"</span>;</span><br><span class="line"><span class="comment">// 当然最好用：</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Scott"</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Class的专属常量用 static：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;      <span class="comment">// 声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;     <span class="comment">//定义式，不要放在头文件中，不用给数值。</span></span><br></pre></td></tr></table></figure><p>C++ 通常要求对使用的任何东西提供一个定义式，这里类的 static 的整数类型（integral type: int, char, bool）只要不取他们的地址就可以不用声明式。但如果需要取地址或编译器坚持需要定义式，就必须提供定义式。并且这种“in-class 初值设定”也只允许对整数常量进行。</p><p>旧时编译器可能要将初值设定放在定义式中，如果编译期间一定要知道该常量值，比如这里 scores 数组的声明，可以使用“the enum hack”补偿做法，即<code>enum { NumTurns = 5 };</code>。</p><p>这样做的好处有：</p><ul><li>它的行为更像 #define 而不像 const，比如不支持取地址。</li><li>优秀的编译器不会为“整型 const 对象”设定另外的空间，除非你创建一个指向该对象的 pointer 或 reference，而不够优秀的编译器却可能如此。Enums 不会导致非必要的你内存分配。</li><li>是 template metaprogramming 的基础技术，非常实用。</li></ul><p>另外，#define 的另一个误用情况是用来实现宏（macros），缺点很多。应使用 template inline 函数，可带来宏的效率以及一般函数的所有可预料行为和类型安全性（type safety）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款03：Use-const-whenever-possible"><a href="#条款03：Use-const-whenever-possible" class="headerlink" title="条款03：Use const whenever possible."></a>条款03：Use const whenever possible.</h2><p>const 的一般用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p;     <span class="comment">// 被指物是常量，同 char const * p;</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;    <span class="comment">// 指针自身是常量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;     <span class="comment">//  T* const，指针本身是常量。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter;  <span class="comment">//  const T*，被指物是常量。</span></span><br></pre></td></tr></table></figure><p>const 在函数的返回值、参数、成员函数自身都有很强大的用法。</p><ul><li>函数返回常量值，可在不放弃安全性和高效性的同时降低使用意外。比如，有理数的乘法操作符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"><span class="comment">// 阻止了使用类似 if ( a * b = c ) 这样的代码。</span></span><br></pre></td></tr></table></figure><ul><li>使用 const 参数阻止对参数的改动。</li><li>使用 const 成员函数一可使 class 的接口更容易被理解，二是使操作 const 对象成为可能。</li></ul><p>C++的一个重要特性：两个成员函数如果只是常量性（constness）不同，可以被重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">'x'</span>;        <span class="comment">// 错误。</span></span><br></pre></td></tr></table></figure><p>成员函数如果是 const 意味着什么？</p><ul><li>bitwise constness（physical constness）：成员函数不更改对象的任何成员变量（任何 bit），这是编译器理解的 const。但存在这种情况：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;ctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;            <span class="comment">// 正确。</span></span><br></pre></td></tr></table></figure><ul><li>logical constness（conceptual constness）：成员函数可以修改它所处理的对象内的某些 bits，但只有在客户侦测不出的情况下才得如此。这是编写程序时应具备的习惯。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> TextBlock::length() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);      <span class="comment">// 错误，const 成员函数内不能改变这些变量值。</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是把<code>textLength</code>和<code>lengthIsValid</code>声明为mutable。</p><p>对于第一个 TextBlock 例子，还有个问题，如果函数体很长，如还包括边界检验（bounds checking）、日志访问信息（logged access info）、数据完善性检验等，会有大量的重复代码。</p><p>这时可利用常量性转除（casting away constness），即便一般来说使用 casting 是一个糟糕的想法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; TextBook::<span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[postion];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>&amp; TextBook::<span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先转为 const TextBlock&amp; 再将 const 属性移除。</p><h2 id="条款04：Make-sure-that-objects-are-initialized-before-they’re-used"><a href="#条款04：Make-sure-that-objects-are-initialized-before-they’re-used" class="headerlink" title="条款04：Make sure that objects are initialized before they’re used."></a>条款04：Make sure that objects are initialized before they’re used.</h2><p>初始化（initialization）和赋值（assignment）是两个概念。</p><p>请对类的所有成员变量使用 member initialization list 方式进行初始化。</p><p>如果是有多个构造函数，为避免代码冗长，可将性能差不多的初始化封装到函数中转变成赋值函数，实现伪初始化（pseudo-initialization）。</p><p>初始化的顺序是固定的，按照声明次序，而不是初始化列表的次序。</p><p>对于不同编译单元内定义的 non-local static 对象（包括 global 对象、定义于 namespace 作用域内的对象、在 classes 内、在函数内、在 file 作用域内被声明为 static 的对象），C++ 并无明确定义。为应对这种情况，应以 local static 对象替换 non-local static 对象，这也是 Singleton 模式的思想。</p><h1 id="2-Constructors-Destructors-and-Assignment-Operators"><a href="#2-Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="2 Constructors, Destructors, and Assignment Operators"></a>2 Constructors, Destructors, and Assignment Operators</h1><h2 id="条款05：Know-what-functions-C-silently-writes-and-calls"><a href="#条款05：Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="条款05：Know what functions C++ silently writes and calls."></a>条款05：Know what functions C++ silently writes and calls.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~Empty() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些函数惟有在被需要的时候才会创建。</p><p>注意析构函数是 non-virtual 的，除非基类有 virtual 析构函数。</p><p>默认的 copy 构造函数：使用调用相应成员类型的 copy 构造函数，或者通过拷贝每一个 bits 来对每个成员变量进行初始化。</p><p>默认的 copy assignment：同上，但若生成的代码不合法或者没有机会证明它有意义，则不会生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NamedObject&lt;<span class="keyword">int</span>&gt; p(str1, <span class="number">2</span>);</span><br><span class="line">NamedObject&lt;<span class="keyword">int</span>&gt; s(str2, <span class="number">3</span>);</span><br><span class="line">p = s;                          <span class="comment">// 由于 reference 不能改变指向，const 成员无法被修改，所以不会生成 copy assignment</span></span><br></pre></td></tr></table></figure><h2 id="条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><a href="#条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want" class="headerlink" title="条款06：Explicitly disallow the use of compiler-generated functions you do not want."></a>条款06：Explicitly disallow the use of compiler-generated functions you do not want.</h2><p>定义为 private，可以阻止人们调用它。（编译器报错）</p><p>为了进一步阻止成员函数和 friend 函数调用，应只声明而不去定义这些函数。（连接器报错）</p><p>为了方便使用，可以让它继承这样的 Uncopyable 基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123; &#125;</span><br><span class="line">    ~Uncopyable() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且，使用时不一定要用 public 继承它，析构函数不一定得是 virtual。可能导致多重继承，多重继承有时会阻止这种 empty base class optimization。</p><p>Boost 库里也有相关的版本，叫 noncopyable。</p><h2 id="条款07：Declare-destructors-virtual-in-polymorphic-base-classes"><a href="#条款07：Declare-destructors-virtual-in-polymorphic-base-classes" class="headerlink" title="条款07：Declare destructors virtual in polymorphic base classes."></a>条款07：Declare destructors virtual in polymorphic base classes.</h2><p>基类指针指向派生类，只有在析构函数为虚函数的情况下才能销毁整个派生类对象。</p><p>但也不能因此把所有类的析构函数都声明成 virtual，由于这份信息由 vptr（virtual table pointer）指向的 vtbl（virtual table）维护，这会增大每个对象的大小。许多人的心得是：只有当 class 内含有至少一个 virtual 函数，才为它声明 virtual destructor。</p><p>注意：string 类的析构函数是 non-virtual 的。</p><p>进一步的，可将析构函数声明为 pure virtual 以实现抽象类。注意提供一份定义，因为编译器会在派生类的析构函数中创建对 ~AWOV 的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV( ) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，给 base classes 一个 virtual 析构函数，这个规则只适用于 polymorphic（带多态性质的）base classes 身上。因为有些基类的设计并不是为了多态，甚至不是为了继承。</p><h2 id="条款08：Prevent-exceptions-from-leaving-destructors"><a href="#条款08：Prevent-exceptions-from-leaving-destructors" class="headerlink" title="条款08：Prevent exceptions from leaving destructors."></a>条款08：Prevent exceptions from leaving destructors.</h2><p>不鼓励在析构函数中抛出异常，会导致程序过早结束或不明确行为。</p><p>所以可以将这些逻辑从析构函数转移到普通函数，交由用户进行调用。</p><p>若析构函数必须处理异常，则要在捕捉到异常后吞下不传播或者结束程序。</p><h2 id="条款09：Never-call-virtual-functions-during-construction-or-destruction"><a href="#条款09：Never-call-virtual-functions-during-construction-or-destruction" class="headerlink" title="条款09：Never call virtual functions during construction or destruction"></a>条款09：Never call virtual functions during construction or destruction</h2><p>在基类构造期间，virtual 函数不是 virtual 函数。</p><p>构造函数中调用的函数里调用了 virtual functions 的情况更加难以发现。</p><h2 id="条款10：Have-assignment-operators-return-a-reference-to-this"><a href="#条款10：Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="条款10：Have assignment operators return a reference to *this."></a>条款10：Have assignment operators return a reference to *this.</h2><p>以支持连锁赋值。</p><h2 id="条款11：Handle-assignment-to-self-in-operator"><a href="#条款11：Handle-assignment-to-self-in-operator" class="headerlink" title="条款11：Handle assignment to self in operator="></a>条款11：Handle assignment to self in operator=</h2><p>三种方式：</p><ul><li>证同测试（identity test）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><ul><li>把焦点放在实现异常安全性（exception safety）上。复制指针所指空间前保证别删除原空间。这样甚至不需要进行证同测试，因为证同测试也需要成本。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 copy and swap 技术。（详见条款 29）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);<span class="comment">// 成员函数，交换*this和参数。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以以 by value 的方式进行优化，牺牲清晰性，却可令编译器有时生成更高效的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12：Copy-all-parts-of-an-object"><a href="#条款12：Copy-all-parts-of-an-object" class="headerlink" title="条款12：Copy all parts of an object."></a>条款12：Copy all parts of an object.</h2><p>当为一个类编写 copy constructor 或者 copy assignment 时，请确保：</p><ol><li>赋值所有 local 成员变量。</li><li>调用所有 base classes 内的适当 copying 函数。</li></ol><p>当然，不能在 copy assignment 操作符中调用 copy 构造函数。<br>反之同样无意义。<br>如果重复代码较多，不妨建立一个 init 成员函数。</p><h1 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理</h1><h2 id="条款13：Use-objects-to-manage-resources"><a href="#条款13：Use-objects-to-manage-resources" class="headerlink" title="条款13：Use objects to manage resources."></a>条款13：Use objects to manage resources.</h2><p>把资源放进对象内，在析构函数中确保资源被释放。</p><p>对于单一区块或函数内的资源，应该在控制流离开那个区块或函数时被释放，可以利用标准库中的<code>auto_ptr</code>，即智能指针，其析构函数自动对其所指对象调用 delete。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>体现的思想：</p><ul><li>获得资源后立刻放进管理对象，即资源取得时机便是初始化时机（Resource Acquisition Is Initialization, RAII）。（在构造函数中获得资源）</li><li>运用析构函数确保资源被释放。（在析构函数中释放资源）</li></ul><p>注意：使用<code>auto_ptr</code>时不要让多个该指针指向同一对象，为此，它有个性质：若通过 copy constructor 或 copy assignment 复制它们，它们会变成 null。</p><p>这意味着<code>auto_ptr</code>并非管理动态分配资源的神兵利器，例如，STL 容器要求其元素发挥正常的复制行为，所以这些容器容不得<code>auto_ptr</code>。</p><p>它的一个替代方案是引用计数型智慧指针（reference-counting smart pointer，RCSP）。追踪有多少对象指向该资源，实现类似垃圾回收（garbage collection）的行为，不同的是无法打破环状引用（cycles of references）。它的一种实现就是 TR1 的tr1::shared_ptr。</p><p>注意，这两个方案都是在其析构函数中做 delete 而不是 delete[]。因此不能用在动态分配而得的 array 身上，即便它能通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; aps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; spi(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>]);</span><br></pre></td></tr></table></figure><p>这种时候推荐用 vector 和 string。</p><h2 id="条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="条款14：Think carefully about copying behavior in resource-managing classes."></a>条款14：Think carefully about copying behavior in resource-managing classes.</h2><p>有时你需要简历自己的资源管理类，一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Lock(Mutex* pm) : mutexPtr(pm)&#123;</span><br><span class="line">        lock(mutexptr);<span class="comment">// 构造时加锁</span></span><br><span class="line">    &#125;<span class="comment">// 析构时释放</span></span><br><span class="line">    ~Lock()&#123;</span><br><span class="line">        unlock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Mutex *mutexPtr;<span class="comment">// 互斥器对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这很好，但如果Lock对象被复制（一个RAII对象被复制），会发生什么事？可能的选择：</p><ul><li>禁止复制。</li><li>引用计数法。对这个例子，可以将 mutexPtr 改为 <code>tr1::shared_ptr</code>类型，但由于引用次数为0时默认执行的是释放操作而不是 unlock，需要在构造时为它指定第二个参数：删除器（deleter）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)&#123;// 增加了一个参数</span><br><span class="line">        lock(mutexPtr.get());<span class="comment">// 使用get，条款15。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不用再定义析构函数。</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;<span class="comment">// 互斥器对象使用 shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制底部资源。即深度复制（deep copying）。</li><li>转移底部资源的拥有权。</li></ul><h2 id="条款15：Provide-access-to-raw-resources-in-resource-managing-class"><a href="#条款15：Provide-access-to-raw-resources-in-resource-managing-class" class="headerlink" title="条款15：Provide access to raw resources in resource-managing class"></a>条款15：Provide access to raw resources in resource-managing class</h2><p>例如你使用<code>auto_ptr</code>或<code>tr1::shared_ptr</code>对某类对象进行管理，而 API 要求使用该对象的原始指针。这时可用 get() 成员函数进行显式转换，获得智能指针内部的原始指针（的复件）。当然，这两个类也实现了<code>operator*</code>和<code>operator-&gt;</code>，用于隐式转换。</p><p>如果是自己写的类，也可提供类似 get() 的接口。也最好提供隐式转换的接口，如从<code>auto_ptr&lt;Font&gt;</code>转为<code>FontHandle</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会增加出错的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Font f1(getFont());</span><br><span class="line">FontHandle f2 = f1;<span class="comment">// 会执行隐式转换后复制，而不是直接复制。</span></span><br></pre></td></tr></table></figure><p>所以不太推荐，要权衡。</p><p>RAII 类暴露原始资源与“封装性”并不矛盾，它的存在并不是为了封装而是为了确保一个特殊行为——资源释放——会放生。</p><h2 id="条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="条款16：Use the same form in corresponding uses of new and delete"></a>条款16：Use the same form in corresponding uses of new and delete</h2><p>new 用 delete，new …[x] 用 delete[]，混用会产生未定义的行为。</p><p>尽量避免对数组类型进行 typedef。</p><h2 id="条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="条款17：Store newed objects in smart pointers in standalone statements."></a>条款17：Store newed objects in smart pointers in standalone statements.</h2><p>以独立语句将新对象置于智能指针，否则有资源泄漏的风险。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure><p>因为 C++ 编译器未必是在 shared_ptr 将新对象添加进来之前执行 priority()，若这时 priority() 出错，新资源的指针会遗失。</p><h1 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4 设计与声明"></a>4 设计与声明</h1><h2 id="条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="条款18：Make interfaces easy to use correctly and hard to use incorrectly."></a>条款18：Make interfaces easy to use correctly and hard to use incorrectly.</h2><ul><li>好的接口很容易被正确使用，不容易被误用。</li><li>促进被正确使用的方法包括：接口的一致性、与内置类型的行为兼容。</li><li>阻止误用的方法包括：建立新类型、限制类型上的操作、束缚对象值、消除客户的资源管理责任。</li><li>tr1::shared_ptr 支持定制型删除器，这可防范 cross-DLL problem，即在一个 DLL 中被 new 创建，却在另一个 DLL 中被 delete 销毁。</li><li>使用 tr1::shared_ptr 等消除某些客户错误的同时，也值得我们关注其使用成本。</li></ul><h2 id="条款19：Treat-class-design-as-type-design"><a href="#条款19：Treat-class-design-as-type-design" class="headerlink" title="条款19：Treat class design as type design."></a>条款19：Treat class design as type design.</h2><ul><li>新 type 的对象应该如何被创建和销毁？（构造、析构、new、delete）</li><li>对象的初始化和赋值有什么样的区别？</li><li>新 type 的对象如果被 passed by value，意味着什么？（copy constructor）</li><li>什么是新 type 的合法值？</li><li>你的新 type 需要配合某个继承图系（inheritance graph）吗？（受其束缚，如 virtual）</li><li>你的新 type 需要什么样的转换？</li><li>什么样的操作符和函数对此新 type 而言是合理的？</li><li>什么样的标准函数应该驳回？（声明为 private）</li><li>谁该取用新 type 的成员？（public/private/protected、friends）</li><li>什么是新 type 的未声明接口（undeclared interface）？</li><li>你的新 type 有多么一般化？（class template）</li><li>你真的需要一个新 type 吗？（使用 non-member function 或者 template？）</li></ul><h2 id="条款20：Prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#条款20：Prefer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="条款20：Prefer pass-by-reference-to-const to pass-by-value."></a>条款20：Prefer pass-by-reference-to-const to pass-by-value.</h2><p>更高效，且可避免切割问题（slicing problem）。</p><p>你可以合理假设“pass-by-value 并不昂贵”的唯一对象就是内置类型、STL 迭代器、函数对象。</p><h2 id="条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object" class="headerlink" title="条款 21：Don’t try to return a reference when you must return an object."></a>条款 21：Don’t try to return a reference when you must return an object.</h2><p>比如<code>operator*</code>。</p><p>绝不要返回一个指向 local stack 上对象的 pointer 或 reference，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。</p><h2 id="条款22：Declare-data-members-private"><a href="#条款22：Declare-data-members-private" class="headerlink" title="条款22：Declare data members private."></a>条款22：Declare data members private.</h2><ul><li>语法一致性。</li><li>细微划分访问控制。</li><li>封装性与“当其内容改变时可能造成的代码破坏量”成反比。</li><li>protected 并不比 public 更具封装性。</li></ul><h2 id="条款23：Prefer-non-member-non-friend-functions-to-member-functions"><a href="#条款23：Prefer-non-member-non-friend-functions-to-member-functions" class="headerlink" title="条款23：Prefer non-member non-friend functions to member functions."></a>条款23：Prefer non-member non-friend functions to member functions.</h2><p>可以增加封装性、包裹弹性（packaging flexibility）、机能扩充性。</p><p>比如一些便利函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;<span class="comment">// member function的写法。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123; ... &#125;<span class="comment">// non-member，non-friend的写法。</span></span><br></pre></td></tr></table></figure><p>另外，如果有很多这样的便利函数，可以按照机能划分到不同的头文件、不同的 namespace 下。</p><h2 id="条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="条款24：Declare non-member functions when type conversions should apply to all parameters"></a>条款24：Declare non-member functions when type conversions should apply to all parameters</h2><p>比如想要创建一个实数类，让它既能实现“Rational <em> int”，又想让它能够实现“int </em> Rational”的运算（内含隐性转换），就需要：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational &amp;rhs)&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>注意，不用把它声明为 friend，friend 能避免就避免。</p><h2 id="条款25：Consider-support-for-a-non-throwing-swap"><a href="#条款25：Consider-support-for-a-non-throwing-swap" class="headerlink" title="条款25：Consider support for a non-throwing swap."></a>条款25：Consider support for a non-throwing swap.</h2><p>（有点绕）</p><h1 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h1><h2 id="条款26：Postpone-variable-definitions-as-long-as-possible"><a href="#条款26：Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="条款26：Postpone variable definitions as long as possible."></a>条款26：Postpone variable definitions as long as possible.</h2><p>尽可能延后变量定义式的出现。</p><h2 id="条款27：Minimize-casting"><a href="#条款27：Minimize-casting" class="headerlink" title="条款27：Minimize casting."></a>条款27：Minimize casting.</h2><p>两种旧式转型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T) expr;</span><br><span class="line">T(expr);</span><br></pre></td></tr></table></figure><p>四种新式转型：</p><ul><li><code>const_cast&lt;T&gt;(expr)</code>。常量性转除（cast away the constness）。</li><li><code>dynamic_cast&lt;T&gt;(expr)</code>。安全向下转型（safe downcasting）。执行速度很慢。</li><li><code>reinterpret_cast&lt;T&gt;(expr)</code>。低级转换，行为取决于编译器（不可抑制），很少用。</li><li><p><code>static_cast&lt;T&gt;(expr)</code>。强迫隐式转换，包括：</p><ul><li>non-const 转 const</li><li>int 转 double</li><li>void<em> 转 T</em></li><li>pointer-to-base 转 pointer-to-derived</li></ul></li></ul><p>唯一使用旧时转型的时机：explicit 构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">doSomeWork(Widget(<span class="number">15</span>));</span><br><span class="line">doSomeWork(<span class="keyword">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure><p>转型可能会做很多事，甚至在基类指针转化为派生类指针时会改变指针的地址。</p><p>dynamic_cast 一般用于将基类指针转为派生类指针，然后执行派生类中才有的函数。但尽量用派生类的指针类型或在基类中声明 virtual 来避免使用它。</p><p>如果转型是必要的，把它隐匿在函数中，不要交给客户。</p><h2 id="条款28：Avoid-returning-“handles”-to-object-internals"><a href="#条款28：Avoid-returning-“handles”-to-object-internals" class="headerlink" title="条款28：Avoid returning “handles” to object internals."></a>条款28：Avoid returning “handles” to object internals.</h2><p>避免返回指向对象内部某对象的 handles（包括 references、pointers、iterators），会破坏封装性。</p><p>如果是返回 const 的对象引用，记得用两个 const，即便如此，也存在着“handle 比其所指对象更长寿”的风险。</p><h2 id="条款29：Strive-for-exception-safe-code"><a href="#条款29：Strive-for-exception-safe-code" class="headerlink" title="条款29：Strive for exception-safe code."></a>条款29：Strive for exception-safe code.</h2><p>异常安全性的两个条件：</p><ul><li>当异常被抛出时，不泄露任何资源。</li><li>当异常被抛出时，不允许数据败坏。</li></ul><p>异常安全函数（Exception-safe function）提供以下三个保证之一：</p><ul><li>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。</li><li>强烈保证：如果异常被抛出，程序状态不改变（恢复到调用前的状态）。（copy-and-swap）</li><li>不抛掷（nothrow）保证：承诺绝不抛出异常，</li></ul><p>（有个例子没仔细看）</p><h2 id="条款30：Understand-the-ins-and-outs-of-inlining"><a href="#条款30：Understand-the-ins-and-outs-of-inlining" class="headerlink" title="条款30：Understand the ins and outs of inlining."></a>条款30：Understand the ins and outs of inlining.</h2><ul><li>将大多数 inlining 限制在小型、被频繁使用的函数上。</li><li>不要只因为 function templates 出现在头文件，将就它们声明为 inline。</li></ul><h2 id="条款31：Minimize-compilation-dependecies-between-files"><a href="#条款31：Minimize-compilation-dependecies-between-files" class="headerlink" title="条款31：Minimize compilation dependecies between files."></a>条款31：Minimize compilation dependecies between files.</h2><p>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。可以使用 Handle classes 和 Interface classes。</p><p>程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用。</p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; create(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> Date&amp; birthday</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday)</span><br><span class="line">        : theName(name), theBirthday(birthday)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson()&#123; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//略去实现</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//略去实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; Person::create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name, </span><br><span class="line">                                            <span class="keyword">const</span> Date&amp; birthday)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; pp(Person::create(name, dateOfBirth));</span><br></pre></td></tr></table></figure><h1 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6 继承与面向对象设计"></a>6 继承与面向对象设计</h1><h2 id="条款32：Make-sure-public-inheritance-models-“is-a-”"><a href="#条款32：Make-sure-public-inheritance-models-“is-a-”" class="headerlink" title="条款32：Make sure public inheritance models “is-a.”"></a>条款32：Make sure public inheritance models “is-a.”</h2><p>public 继承意味着“is-a”，适用于 base classes 身上的每一件事一定也适用于 derived classes 身上。</p><h2 id="条款33：Avoid-hiding-inherited-names"><a href="#条款33：Avoid-hiding-inherited-names" class="headerlink" title="条款33：Avoid hiding inherited names."></a>条款33：Avoid hiding inherited names.</h2><ul><li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有人希望如此。</li><li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数（forwarding functions）。</li></ul><h2 id="条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="headerlink" title="条款34：Differentiate between inheritance of interface and inheritance of implementation."></a>条款34：Differentiate between inheritance of interface and inheritance of implementation.</h2><ul><li>接口继承和实现继承不同 ，在 public 继承之下，derived classes 总是继承 base class 的接口。</li><li>pure virtual 函数只具体指定接口继承。</li><li>impure virtual 函数具体指定接口继承及缺省实现继承。</li><li>non-virtual 函数具体指定接口继承以及强制性实现继承。</li></ul><h2 id="条款35：Consider-alternatives-to-virtual-functions"><a href="#条款35：Consider-alternatives-to-virtual-functions" class="headerlink" title="条款35：Consider alternatives to virtual functions"></a>条款35：Consider alternatives to virtual functions</h2><p>virtual 的替代方案：</p><ul><li>使用 non-virtual interface（NVI）手法，那是 Template Method 设计模式的一种特殊模式。它以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的 virtual 函数。</li><li>将 virtual 函数替换为“函数指针成员变量”，这是 Strategy 设计模式的一种分解表现形式。</li><li>以 tr1::function 成员变量替换 virtual 函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。</li><li>将继承体系内的 vitual 函数替换为另一个继承体系的 virtual 函数。这是 Strategy 设计模式的传统实现手法。</li></ul><h2 id="条款36：Never-redefine-an-inherited-non-virtual-function"><a href="#条款36：Never-redefine-an-inherited-non-virtual-function" class="headerlink" title="条款36：Never redefine an inherited non-virtual function."></a>条款36：Never redefine an inherited non-virtual function.</h2><h2 id="条款37：Never-redefine-a-function’s-inherited-default-parameter-value"><a href="#条款37：Never-redefine-a-function’s-inherited-default-parameter-value" class="headerlink" title="条款37：Never redefine a function’s inherited default parameter value."></a>条款37：Never redefine a function’s inherited default parameter value.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;draw();</span><br></pre></td></tr></table></figure><ul><li>Rectangle 中赋予了不同的缺省参数值，很槽糕。</li><li>这里 pr 调用的是派生类复写后的 virtual 函数，但是缺省参数不是 Green 而是 Red（由静态类型决定）。</li><li>使用virtual 函数的替代设计，如 NVI（non-virtual interface）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        doDraw(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><a href="#条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition" class="headerlink" title="条款38：Model “has-a” or “is-implemented-in-terms-of” through composition."></a>条款38：Model “has-a” or “is-implemented-in-terms-of” through composition.</h2><p>复合（composition），同义词有分层（layering）、内含（containment）、聚合（aggregation）、内嵌（embedding）等。它的意义（has-a）和 public 继承（is-a）完全不同。</p><h2 id="条款39：Use-private-inheritance-judiciously"><a href="#条款39：Use-private-inheritance-judiciously" class="headerlink" title="条款39：Use private inheritance judiciously."></a>条款39：Use private inheritance judiciously.</h2><ul><li>private 继承意味着 is-implemented-in-terms-of（根据某物实现出）。通常比复合（composition）的级别低，但当派生类需要访问 protected base class 的成员，或需重新定义继承而来的 virtual 函数时，这么设计是合理的。</li><li>和复合不同，private 继承可以造成 empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ul><h2 id="条款40：Use-multiple-inheritance-judiciously"><a href="#条款40：Use-multiple-inheritance-judiciously" class="headerlink" title="条款40：Use multiple inheritance judiciously."></a>条款40：Use multiple inheritance judiciously.</h2><ul><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li><li>virtual 继承会增加大小、速度、初始化及赋值复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具使用价值的情况。</li><li>多重继承的确有正当用途。其中一个情节涉及“public 继承某个 Interface class”和“private 继承某个协助实现的 class”的组合。</li></ul><h1 id="7-模板和范型编程"><a href="#7-模板和范型编程" class="headerlink" title="7 模板和范型编程"></a>7 模板和范型编程</h1><h2 id="条款41：Understand-implicit-interfaces-and-compile-time-polymorphism"><a href="#条款41：Understand-implicit-interfaces-and-compile-time-polymorphism" class="headerlink" title="条款41：Understand implicit interfaces and compile-time polymorphism."></a>条款41：Understand implicit interfaces and compile-time polymorphism.</h2><ul><li>classes 和 templates 都支持接口（interfaces）和多态（polymorphism）。</li><li>对 classes 而言接口是显式的，以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li><li>对 template 参数而言，接口是隐式的，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析，发生于编译期。</li></ul><h2 id="条款42：Understand-the-two-meanings-of-typename"><a href="#条款42：Understand-the-two-meanings-of-typename" class="headerlink" title="条款42：Understand the two meanings of typename."></a>条款42：Understand the two meanings of typename.</h2><ul><li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li><li>typename 还有个功能是标识嵌套从属类型名称（nested dependent name）。但不得在 base class lists 或 member initialization list 内使用。</li></ul><p>一个正确的使用例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款43：Know-how-to-access-names-in-templatized-base-classes"><a href="#条款43：Know-how-to-access-names-in-templatized-base-classes" class="headerlink" title="条款43：Know how to access names in templatized base classes."></a>条款43：Know how to access names in templatized base classes.</h2><p>当我们从 Object Oriented C++ 跨进 Template C++ 后，继承就没有那样畅行无阻了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        sendClear(info);<span class="comment">// 调用基类函数，无法通过编译。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种解决方式：</p><ol><li>调用前加上<code>this-&gt;</code>。</li><li>使用using声明式。</li><li>使用作用域声明符明确指示，但会关闭 virtual 绑定行为。</li></ol><h2 id="条款44：Factor-parameter-independent-code-out-of-templates"><a href="#条款44：Factor-parameter-independent-code-out-of-templates" class="headerlink" title="条款44：Factor parameter-independent code out of templates."></a>条款44：Factor parameter-independent code out of templates.</h2><ul><li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li><li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。</li><li>因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚入职时看《Effective C++》记录的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Docker CheatSheet</title>
    <link href="http://ifanze.cn/2018/02/23/Docker-CheatSheet/"/>
    <id>http://ifanze.cn/2018/02/23/Docker-CheatSheet/</id>
    <published>2018-02-23T08:40:23.000Z</published>
    <updated>2018-06-24T09:59:13.438Z</updated>
    
    <content type="html"><![CDATA[<p>阅读 Docker 官方文档的笔记。</p><a id="more"></a><!-- toc --><h1 id="Get-Started-Part-1-Orientation-and-setup"><a href="#Get-Started-Part-1-Orientation-and-setup" class="headerlink" title="Get Started, Part 1: Orientation and setup"></a>Get Started, Part 1: Orientation and setup</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## List Docker CLI commands</span></span><br><span class="line">docker</span><br><span class="line">docker container --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Display Docker version and info</span></span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="comment">## Excecute Docker image</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment">## List Docker images</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment">## List Docker containers (running, all, all in quiet mode)</span></span><br><span class="line">docker container ls</span><br><span class="line">docker container ls -all</span><br><span class="line">docker container ls -a -q</span><br></pre></td></tr></table></figure><h1 id="Get-Started-Part-2-Containers"><a href="#Get-Started-Part-2-Containers" class="headerlink" title="Get Started, Part 2: Containers"></a>Get Started, Part 2: Containers</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .  <span class="comment"># Create image using this directory's Dockerfile</span></span><br><span class="line">docker run -p 4000:80 friendlyhello  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></span><br><span class="line">docker run -d -p 4000:80 friendlyhello         <span class="comment"># Same thing, but in detached mode</span></span><br><span class="line">docker container ls                                <span class="comment"># List all running containers</span></span><br><span class="line">docker container ls -a             <span class="comment"># List all containers, even those not running</span></span><br><span class="line">docker container stop &lt;<span class="built_in">hash</span>&gt;           <span class="comment"># Gracefully stop the specified container</span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;         <span class="comment"># Force shutdown of the specified container</span></span><br><span class="line">docker container rm &lt;<span class="built_in">hash</span>&gt;        <span class="comment"># Remove specified container from this machine</span></span><br><span class="line">docker container rm $(docker container ls -a -q)         <span class="comment"># Remove all containers</span></span><br><span class="line">docker image ls -a                             <span class="comment"># List all images on this machine</span></span><br><span class="line">docker image rm &lt;image id&gt;            <span class="comment"># Remove specified image from this machine</span></span><br><span class="line">docker image rm $(docker image ls -a -q)   <span class="comment"># Remove all images from this machine</span></span><br><span class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></span><br><span class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></span><br><span class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></span><br></pre></td></tr></table></figure><h1 id="Get-Started-Part-3-Services"><a href="#Get-Started-Part-3-Services" class="headerlink" title="Get Started, Part 3: Services"></a>Get Started, Part 3: Services</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls                                            <span class="comment"># List stacks or apps</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  <span class="comment"># Run the specified Compose file</span></span><br><span class="line">docker service ls                 <span class="comment"># List running services associated with an app</span></span><br><span class="line">docker service ps &lt;service&gt;                  <span class="comment"># List tasks associated with an app</span></span><br><span class="line">docker inspect &lt;task or container&gt;                   <span class="comment"># Inspect task or container</span></span><br><span class="line">docker container ls -q                                      <span class="comment"># List container IDs</span></span><br><span class="line">docker stack rm &lt;appname&gt;                             <span class="comment"># Tear down an application</span></span><br><span class="line">docker swarm leave --force      <span class="comment"># Take down a single node swarm from the manager</span></span><br></pre></td></tr></table></figure><h1 id="Get-Started-Part-4-Swarms"><a href="#Get-Started-Part-4-Swarms" class="headerlink" title="Get Started, Part 4: Swarms"></a>Get Started, Part 4: Swarms</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 <span class="comment"># Create a VM (Mac, Win7, Linux)</span></span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1 <span class="comment"># Win10</span></span><br><span class="line">docker-machine env myvm1                <span class="comment"># View basic information about your node</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker node ls"</span>         <span class="comment"># List the nodes in your swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker node inspect &lt;node ID&gt;"</span>        <span class="comment"># Inspect a node</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker swarm join-token -q worker"</span>   <span class="comment"># View join token</span></span><br><span class="line">docker-machine ssh myvm1   <span class="comment"># Open an SSH session with the VM; type "exit" to end</span></span><br><span class="line">docker node ls                <span class="comment"># View nodes in swarm (while logged on to manager)</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">"docker swarm leave"</span>  <span class="comment"># Make the worker leave the swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker swarm leave -f"</span> <span class="comment"># Make master leave, kill swarm</span></span><br><span class="line">docker-machine ls <span class="comment"># list VMs, asterisk shows which VM this shell is talking to</span></span><br><span class="line">docker-machine start myvm1            <span class="comment"># Start a VM that is currently not running</span></span><br><span class="line">docker-machine env myvm1      <span class="comment"># show environment variables and command for myvm1</span></span><br><span class="line"><span class="built_in">eval</span> $(docker-machine env myvm1)         <span class="comment"># Mac command to connect shell to myvm1</span></span><br><span class="line">&amp; <span class="string">"C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe"</span> env myvm1 | Invoke-Expression   <span class="comment"># Windows command to connect shell to myvm1</span></span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  <span class="comment"># Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span></span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ <span class="comment"># Copy file to node's home dir (only required if you use ssh to connect to manager and deploy the app)</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker stack deploy -c &lt;file&gt; &lt;app&gt;"</span>   <span class="comment"># Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span></span><br><span class="line"><span class="built_in">eval</span> $(docker-machine env -u)     <span class="comment"># Disconnect shell from VMs, use native docker</span></span><br><span class="line">docker-machine stop $(docker-machine ls -q)               <span class="comment"># Stop all running VMs</span></span><br><span class="line">docker-machine rm $(docker-machine ls -q) <span class="comment"># Delete all VMs and their disk images</span></span><br></pre></td></tr></table></figure><h1 id="Dockerfile-Sample"><a href="#Dockerfile-Sample" class="headerlink" title="Dockerfile Sample"></a>Dockerfile Sample</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Copy the current directory contents into the container at /app</span></span></span><br><span class="line"><span class="bash">ADD . /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install any needed packages specified in requirements.txt</span></span></span><br><span class="line"><span class="bash">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Make port 80 available to the world outside this container</span></span></span><br><span class="line"><span class="bash">EXPOSE 80</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Define environment variable</span></span></span><br><span class="line"><span class="bash">ENV NAME World</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Run app.py when the container launches</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h1 id="docker-compose-yml-Sample"><a href="#docker-compose-yml-Sample" class="headerlink" title="docker-compose.yml Sample"></a>docker-compose.yml Sample</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">  visualizer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"6379:6379"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/home/docker/data:/data"</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">redis-server</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  webnet:</span></span><br></pre></td></tr></table></figure><h1 id="Docker-development-best-practices"><a href="#Docker-development-best-practices" class="headerlink" title="Docker development best practices"></a>Docker development best practices</h1><ol><li><p>Keep images small</p><ul><li>Start with an appropriate base image.</li><li>Use <strong>multistage builds</strong>, or reduce the number of layers by minimizing the number of <code>RUN</code> command.</li><li>Creating your own base image, if you have multiple images with a lot in common.</li><li>Use the production image as the base image for the debug image.</li><li>Tag images with useful tags.</li></ul></li><li><p>Persist data</p><ul><li>Avoid storing data in writable layer using storage drivers, instead, using <strong>volumes</strong>.</li><li>Use <strong>bind mounts</strong> during development and production.</li><li>For production, use <strong>secrets</strong> and <strong>configs</strong> to store sensitive/non-sensitive data.</li></ul></li><li><p>Use swarm services when possible</p><ul><li>Design the app with the ability to scale using swarm services.</li><li>Even only need a single instance, swarm services is better.</li><li>Use <code>docker stack deploy</code> instead of <code>docker pull</code>.</li></ul></li></ol><h1 id="Dockerfile-Reference"><a href="#Dockerfile-Reference" class="headerlink" title="Dockerfile Reference "></a>Dockerfile Reference </h1><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure><h2 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h2><ul><li>Comment: <code>#</code>.</li><li>Parser directives: <ul><li>Only one at present: <code># escape=\</code>. </li><li>Must be at the very top of a Dockerfile.</li><li>Line continuation characters are not supported.</li></ul></li></ul><h2 id="Environment-replacement"><a href="#Environment-replacement" class="headerlink" title="Environment replacement"></a>Environment replacement</h2><ul><li><code>ENV</code></li><li><code>${var}</code></li><li><code>${var:-word}</code></li><li><code>${var:+word}</code></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> abc=hello</span><br><span class="line"><span class="keyword">ENV</span> abc=bye def=$abc        <span class="comment"># def is hello</span></span><br><span class="line"><span class="keyword">ENV</span> ghi=$abc                <span class="comment"># ghi is bye</span></span><br></pre></td></tr></table></figure><h2 id="dockerignore-file"><a href="#dockerignore-file" class="headerlink" title=".dockerignore file"></a>.dockerignore file</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br><span class="line">*.md</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure><ul><li><code>ARG</code> is the only instruction that may precede <code>FROM</code>.</li><li><code>FROM</code> can appear multiple times.</li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>2 forms:</p><ul><li>shell form: <code>RUN &lt;command&gt;</code> , it will run in a shell which by default is <code>/bin/sh -c</code> or <code>cmd /S /C</code>.</li><li>exec form: <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>.</li></ul><p>note: it is the shell that is doing the environment variable expansion, not docker. so:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"echo"</span>, <span class="string">"<span class="variable">$HOME</span>"</span> ]             <span class="comment"># incorrect</span></span></span><br><span class="line"><span class="bash">RUN [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]    <span class="comment"># correct</span></span></span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>3 forms:</p><ul><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (exec form, this is the preferred form)</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (as default parameters to ENTRYPOINT)</li><li><code>CMD command param1 param2</code> (shell form)</li></ul><p>Note: </p><ul><li>Only one <code>CMD</code> allowed, or, the last will take effect.</li><li>If the user specifies arguments to <code>docker run</code> then they will override the default specified in <code>CMD</code>.</li><li><code>CMD</code> does not execute anything at build time.</li></ul><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure><p>Adds metadata to an image, such as <code>MAINTAINER</code>.</p><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure><p>Override at runtime:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> myName=<span class="string">"John Doe"</span> myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> myName John Doe</span><br><span class="line"><span class="keyword">ENV</span> myDog Rex The Dog</span><br><span class="line"><span class="keyword">ENV</span> myCat fluffy</span><br></pre></td></tr></table></figure><p>To set a value for a single command, use <code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code>.</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>2 forms:</p><ul><li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> (this form is required for paths containing whitespace)</li></ul><p>note:</p><ul><li><code>&lt;dest&gt;</code> is an absolute path, or a path relative to <code>WORKDIR</code>.</li><li><code>&lt;user&gt;:&lt;group&gt;</code> will be <code>0</code> by default. Setting them through <code>UID/GID</code> or <code>username/groupname</code> is OK.</li><li>Using <code>username/groupname</code> require the base image contain <code>/etc/passwd</code> and <code>/etc/group</code>.</li></ul><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>Almost same as <code>ADD</code>, but:</p><ul><li><code>ADD</code> allows <code>&lt;src&gt;</code> to be an URL</li><li>If the <code>&lt;src&gt;</code> parameter of <code>ADD</code> is an archive in a recognised compression format, it will be unpacked</li></ul><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>2 forms:</p><ul><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec form, preferred)</li><li><code>ENTRYPOINT command param1 param2</code> (shell form)</li></ul><p>note:</p><ul><li>Unlike <code>CMD</code>, <code>ENTRYPOINT</code> won’t be replaced by command line arguments, those arguments will be appended after all elements in an <strong>exec form</strong> <code>ENTRYPOINT</code>.</li><li>You can override the <code>ENTRYPOINT</code> instruction using the <code>docker run --entrypoint flag</code>.</li><li><strong>shell form</strong> <code>ENTRYPOINT</code> can prevent <code>CMD</code> or command line arguments from being used, however, container’s <code>PID 1</code> will be <code>/bin/sh</code> rather than the executable. So the executable won’t receive the <code>SIGTERM</code> signal from <code>docker stop &lt;container&gt;</code>.</li><li>Only one <code>CMD</code> allowed, or, the last will take effect.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读 Docker 官方文档的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="参考" scheme="http://ifanze.cn/tags/%E5%8F%82%E8%80%83/"/>
    
      <category term="docker" scheme="http://ifanze.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>macOS CheatSheet</title>
    <link href="http://ifanze.cn/2018/02/23/macOS-CheatSheet/"/>
    <id>http://ifanze.cn/2018/02/23/macOS-CheatSheet/</id>
    <published>2018-02-23T07:55:07.000Z</published>
    <updated>2018-06-24T10:01:44.362Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用的一些命令。</p><a id="more"></a><!-- toc --><h1 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">brew doctor</span><br><span class="line">brew update</span><br><span class="line">brew upgrade</span><br><span class="line"></span><br><span class="line">brew search wget</span><br><span class="line">brew info wget</span><br><span class="line">brew install wget</span><br><span class="line">brew list</span><br><span class="line"></span><br><span class="line">brew cask search iterm2</span><br><span class="line">brew cask info iterm2</span><br><span class="line">brew install iterm2</span><br><span class="line">brew cask list</span><br></pre></td></tr></table></figure><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line">nvm install v8.9.4</span><br><span class="line">nvm use v8.9.4</span><br><span class="line">nvm current</span><br><span class="line">nvm ls</span><br><span class="line">nvm <span class="built_in">alias</span> default v8.9.4</span><br></pre></td></tr></table></figure><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"Post Title"</span></span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br><span class="line">hexo clean</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常用的一些命令。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="macOS" scheme="http://ifanze.cn/tags/macOS/"/>
    
      <category term="参考" scheme="http://ifanze.cn/tags/%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>macOS 重装与软件管理</title>
    <link href="http://ifanze.cn/2018/02/23/macOS-%E9%87%8D%E8%A3%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://ifanze.cn/2018/02/23/macOS-重装与软件管理/</id>
    <published>2018-02-23T07:12:20.000Z</published>
    <updated>2018-04-18T13:47:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>高效管理计算机。</p><a id="more"></a><!-- toc --><p>为了保持 macOS 系统环境的整洁，养成良好、高效的软件管理和使用习惯，决定在过年之际重装一次 macOS。日后在 Mac 使用过程中保持以下几个原则：</p><ul><li>不安装破解软件，付费或替换为同类免费软件。（可是 Photoshop ……）</li><li>所有系统权限需求弱的软件使用 Mac App Store 安装和管理。（除 Evernote，记得 MAS 版不支持代码块）</li><li>桌面程序使用 Homebrew Cask 安装和管理。</li><li>命令行程序使用 Homebrew 安装和管理。</li><li>使用 pyenv 和 nvm 安装和管理 python 和 node.js 的多版本。</li><li>学习和利用 docker 做开发环境的搭建。</li><li>利用 iCloud、Github 对文件和程序配置文件作备份，对有跨平台使用需求的使用 Google Drive。</li><li>再次重装系统时需要注意 QQ、微信、企业QQ 的聊天记录迁移。</li></ul><h1 id="macOS-的重装"><a href="#macOS-的重装" class="headerlink" title="macOS 的重装"></a>macOS 的重装</h1><p>官方文档：<a href="https://support.apple.com/zh-cn/HT204904">https://support.apple.com/zh-cn/HT204904</a></p><p>大致步骤就是：</p><ol><li><code>⌘R</code>开机进恢复模式。</li><li>抹掉 macOS 所在宗卷。</li><li>重新安装 macOS。（需要联网和等待）</li></ol><p>值得一提的是，系统安装过程中，利用无线网 -&gt; 加入其他网络可以让菜单栏焦点回到桌面上，然后打开终端，这时可以使用一些辅助命令，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h                       <span class="comment"># 查看硬盘宗卷信息</span></span><br><span class="line">caffeinate -u -t 14400      <span class="comment"># 阻止系统休眠</span></span><br></pre></td></tr></table></figure><p>重装后，正常设置系统、iCloud 账户。</p><h1 id="最高优先级"><a href="#最高优先级" class="headerlink" title="最高优先级"></a>最高优先级</h1><h2 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Meng Fanze&quot;</span><br><span class="line">git config --global user.email ifanze@outlook.com</span><br></pre></td></tr></table></figure><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh/">https://github.com/robbyrussell/oh-my-zsh/</a><br><a href="https://github.com/zsh-users/zsh-autosuggestions/">https://github.com/zsh-users/zsh-autosuggestions/</a></p><p>配置文件恢复：<code>.zshrc</code>、<code>.zsh_history</code></p><h2 id="安装-homebrew"><a href="#安装-homebrew" class="headerlink" title="安装 homebrew"></a>安装 homebrew</h2><p><a href="https://github.com/Homebrew/brew/">https://github.com/Homebrew/brew/</a></p><h1 id="Mac-App-Store-列表"><a href="#Mac-App-Store-列表" class="headerlink" title="Mac App Store 列表"></a>Mac App Store 列表</h1><ul><li>WeChat</li><li>MWeb</li><li>1Password</li></ul><h1 id="Homebrew-Cask-列表"><a href="#Homebrew-Cask-列表" class="headerlink" title="Homebrew Cask 列表"></a>Homebrew Cask 列表</h1><ul><li>docker</li><li>evernote</li><li>iterm2</li><li>surge</li><li>steam</li><li>dash</li></ul><h1 id="Homebrew-列表"><a href="#Homebrew-列表" class="headerlink" title="Homebrew 列表"></a>Homebrew 列表</h1><ul><li>mas</li><li>nvm</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高效管理计算机。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="macOS" scheme="http://ifanze.cn/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 13</title>
    <link href="http://ifanze.cn/2017/12/24/%E3%80%8AC++%20Primer%E3%80%8B(13)/"/>
    <id>http://ifanze.cn/2017/12/24/《C++ Primer》(13)/</id>
    <published>2017-12-24T07:41:00.000Z</published>
    <updated>2018-06-24T10:06:04.459Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第十三章 拷贝控制</p><a id="more"></a><!-- toc --><h1 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h1><p>拷贝控制操作（copy control）：</p><ul><li>拷贝构造函数（copy constructor）</li><li>拷贝赋值运算符（copy-assignment operator）</li><li>移动构造函数（move constructor）</li><li>移动赋值运算符（move-assignment operator）</li><li>析构函数（destructor）</li></ul><h1 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h1><h2 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h2><p>第一个参数是自身类型的引用（且几乎总是<code>const</code>、不是<code>explicit</code>的），任何额外参数都有默认值。</p><p>如未定义，会有合成版本（即使定义了其他构造函数），依次拷贝类的非静态成员，包括数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">'.'</span>)</span></span>;               <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(dots)</span></span>;                     <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="built_in">string</span> s2 = dots;                   <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-9999"</span>;    <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> nines = <span class="built_in">string</span>(<span class="number">100</span>, <span class="string">'9'</span>);    <span class="comment">// 拷贝初始化</span></span><br></pre></td></tr></table></figure><p>拷贝初始化也可能是由移动构造函数完成。</p><p>拷贝初始化时机：</p><ul><li>使用<code>=</code>定义对象。</li><li>将一个对象作为实参传递给一个非引用类型的形参。</li><li>返回一个对象（非引用）。</li><li>列表初始化一个数组中的元素或一个聚合类中的成员。</li><li>类中对所分配对象执行拷贝初始化操作。如 STL 中的<code>insert</code>等。</li></ul><p>注意拷贝构造函数是不是<code>explicit</code>的，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>);     <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>编译器可能绕过拷贝/移动构造函数，而直接创建对象。（但拷贝/移动构造函数依然需要是存在且可访问的）</p><h2 id="13-1-2-拷贝赋值运算符"><a href="#13-1-2-拷贝赋值运算符" class="headerlink" title="13.1.2 拷贝赋值运算符"></a>13.1.2 拷贝赋值运算符</h2><p>如果未定义，会有合成版本，会将右侧运算对象的每个非静态成员赋予左侧运算对象的相应成员，包括数组。</p><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p><h2 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h2><p>调用时机：</p><ul><li>离开作用域。</li><li>当对象被销毁时，其成员被销毁。</li><li>容器被销毁时，其元素被销毁。</li><li>动态分配的对象，使用<code>delete</code>进行销毁。</li><li>对于临时对象，当创建它的完整表达式结束时被销毁。</li></ul><h2 id="13-1-4-三-五法则"><a href="#13-1-4-三-五法则" class="headerlink" title="13.1.4 三/五法则"></a>13.1.4 三/五法则</h2><ul><li>需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符。</li><li>需要拷贝操作的类也需要赋值操作，反之亦然。</li></ul><h2 id="13-1-5-使用-default"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用 = default"></a>13.1.5 使用 = default</h2><p>显式要求编译器生成合成的版本，只能对编译器可以合成的默认构造函数或拷贝控制成员使用。</p><p>在类内使用将声明为内联的，如果不希望这样，应只在类外定义使用。</p><h2 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h2><p>使用<code>= delete</code>，必须出现在第一次声明的时候，可以对任何函数使用，除了析构函数（会造成不能释放这些对象）。</p><p>合成的拷贝控制成员可能是删除的：</p><ul><li>合成析构函数：当某成员的析构函数是删除的或者不可访问的。</li><li>合成拷贝构造函数：当某成员的拷贝构造函数或析构函数是删除的或者不可访问的。</li><li>合成拷贝赋值运算符：当某个成员的拷贝赋值运算符是删除的或不可访问的，或类的成员中有<code>const</code>或引用。</li><li>默认构造函数：当某个成员的析构函数是删除的或者不可访问的，或类的成员中有没有类内初始化器的<code>const</code>或引用。</li></ul><p>使用<code>private</code>阻止拷贝的缺点是：友元和成员函数依然能够拷贝。对此可以只声明不定义，这样在试图拷贝时会报链接错误。</p><h1 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h1><p>（实例）</p><h1 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.ps, rhs.ps);</span><br><span class="line">    swap(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里调用的是<code>swap</code>，而不是<code>std::swap</code>，是想让在用户版本和 std 版本中自动匹配合适的函数。</p><p>有了交换操作后，可以用它更简单的定义赋值运算符，即拷贝并交换（copy and swap）。它是异常安全的，且能正确处理自赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-4-拷贝控制示例"><a href="#13-4-拷贝控制示例" class="headerlink" title="13.4 拷贝控制示例"></a>13.4 拷贝控制示例</h1><p>（实例）</p><h1 id="13-5-动态内存管理类"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类</h1><p>（实例）</p><p>引出移动。</p><h1 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h1><p>很多情况会发生对象拷贝，某些时候对象拷贝后就立刻被销毁了。使用移动可以大幅度提升性能。</p><h2 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h2><ul><li>只能绑定到一个将要销毁的对象（往往意味着也没有其他用户）。</li><li>变量是左值，不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用类型。</li></ul><p>可以使用<code>&lt;utility&gt;</code>中的<code>std::move</code>将一个左值显式地转换为对应的右值引用类型。告诉编译器：我有一个左值，但我希望像一个右值一样处理它，承诺不再使用它的值，除了对其赋值和销毁，因为移后源对象（moved-from）依然是一个有效的、可析构的状态，但不能对它的值做任何假设。</p><h2 id="13-6-2-移动构造函数和移动赋值运算符"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符</h2><p>类似拷贝构造函数，只是第一个参数是右值引用类型。</p><p>注意确保移动后的对象处在销毁它是无害的的状态，如将指针置为<code>nullptr</code>。</p><p>移动构造函数一般是<code>noexcept</code>的，由于它窃取资源而不分配资源。该关键字写在定义和声明的参数列表后，分号和冒号前。声明和定义都必须指定。</p><p>如果容器的元素是我们的自定义类型，如果不告诉编译器我们的移动构造函数是<code>noexcept</code>的，在进行一些操作时，如对<code>vector</code>进行需要增大内存分配的<code>push_back</code>操作，容器会不敢使用移动构造函数而是使用拷贝构造函数，因为它需要对异常发生时自身的行为提供保障：当异常发生时，vector 自身不会发生变化。</p><p>移动赋值运算符与析构函数和移动构造函数执行相同的工作。与移动构造函数一样，如果不抛异常就该标记为<code>noexcept</code>。</p><p>与拷贝不同，编译器根本不会为某些类合成移动操作。特别是当一个类定义了自己的拷贝函数、拷贝赋值运算符或者析构函数。没有移动构造函数后，根据正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，才会合成。</p><p>可以移动的成员包括：内置类型可以移动，有移动操作的类类型成员也能移动。</p><p>与拷贝不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们使用<code>=default</code>，且编译器不能移动所有成员，它会是删除的。例外是：</p><p>（一二三四，我选择不依赖合成而是自己定义= =）</p><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</p><p>如果一个类既有移动构造函数，也有拷贝构造函数。则移动右值，拷贝左值。但如果没有移动构造函数，右值也被拷贝。</p><p>引入移动操作后，<em>13.3</em>中的拷贝并交换赋值运算符在定义了移动构造函数之后会兼容移动操作。单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p><p>更新三/五法则：所有五个拷贝控制成员应该看作一个整体：如果定义了任何一个拷贝操作，就应该定义五个。这些类通常拥有一个资源。</p><p>移动迭代器：通过解引用得到返回一个指向元素的右值引用。使用<code>make_move_iterator</code>函数。例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line"><span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br></pre></td></tr></table></figure><h2 id="13-6-3-右值引用和成员函数"><a href="#13-6-3-右值引用和成员函数" class="headerlink" title="13.6.3 右值引用和成员函数"></a>13.6.3 右值引用和成员函数</h2><p>如果一个成员函数同时提供拷贝和移动版本，则一般使用与拷贝/移动构造函数和赋值运算符相同的参数模式：一个版本接受一个指向<code>const</code>的左值引用，一个版本接受一个指向非<code>const</code>的右值引用。</p><p>一般来说，我们不需要为函数操作定义接受一个<code>const X&amp;&amp;</code>或一个普通的<code>X&amp;</code>参数的版本。</p><p>通常，我们在一个对象上调用成员函数，而不管对象是一个左值还是一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1= <span class="string">"xxxx"</span>, s2=<span class="string">"xxxx"</span>;</span><br><span class="line"><span class="keyword">auto</span> n = (s1 + s2).find(<span class="string">'a'</span>);</span><br><span class="line">s1 + s2 = <span class="string">"wow!"</span>;</span><br></pre></td></tr></table></figure><p>在旧标准中，我们没法阻止这种使用方式，为了向后兼容性，新标准依然允许。但是有方法进行阻止：限定<code>this</code>的左值/右值属性，像限制其<code>const</code>属性那样在参数列表后放置<code>&amp;</code>或<code>&amp;&amp;</code>。如果需要同时放置<code>const</code>，<code>const</code>在前。需要同时在声明和定义中指定。</p><p>重载方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;            <span class="comment">// 可用于可改变的右值</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;       <span class="comment">// 可用于任何类型的 Foo</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：定义<code>const</code>成员函数时，可以定义两个版本：差别是有没有<code>const</code>。但引用限定的函数不一样，必须对所有函数都加上引用限定符，或者所有都不加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第十三章 拷贝控制&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 12</title>
    <link href="http://ifanze.cn/2017/12/10/%E3%80%8AC++%20Primer%E3%80%8B(12)/"/>
    <id>http://ifanze.cn/2017/12/10/《C++ Primer》(12)/</id>
    <published>2017-12-10T06:45:00.000Z</published>
    <updated>2018-06-24T10:06:01.331Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第十二章 动态内存</p><a id="more"></a><!-- toc --><h1 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h1><h1 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h1><p><code>&lt;memory&gt;</code>：<code>shared_ptr</code>、<code>unique_ptr</code>、<code>weak_ptr</code>。</p><h2 id="12-1-1-shared-ptr-类"><a href="#12-1-1-shared-ptr-类" class="headerlink" title="12.1.1 shared_ptr 类"></a>12.1.1 shared_ptr 类</h2><p><img src="http://static.ifanze.cn/2018-06-23-15128867730807.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p4 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，explicit。</span></span><br></pre></td></tr></table></figure><p>递增引用计数：</p><ul><li>使用它初始化另一个 shared_ptr。</li><li>作为参数传递给一个参数。</li><li>作为函数的返回值。</li><li>…</li></ul><p>递减引用计数：</p><ul><li>赋予一个新值</li><li>shared_ptr 被销毁（如离开局部作用域）</li></ul><p>如果计数器变为0，它就会自动释放自己所管理的对象。</p><p>使用动态内存的目的：</p><ul><li>程序不知道自己需要使用多少对象。（容器类）</li><li>程序不知道所需对象的准确类型。（<em>15章</em>）</li><li>程序需要在多个对象间共享数据。</li></ul><h2 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h2><p>使用<code>new (nothrow)</code>阻止抛异常。</p><p>容易出错的地方：</p><ul><li>忘记 delete。</li><li>使用已经释放掉的对象。</li><li>同一块内存释放两次。</li></ul><p>所以应坚持使用智能指针！</p><h2 id="12-1-3-shared-ptr-和-new-结合使用"><a href="#12-1-3-shared-ptr-和-new-结合使用" class="headerlink" title="12.1.3 shared_ptr 和 new 结合使用"></a>12.1.3 shared_ptr 和 new 结合使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p4 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误，explicit。</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p5(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p><img src="http://static.ifanze.cn/2018-06-23-15128912627452.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15128912698568.jpg" alt=""></p><p>依然推荐用 make_shared，而不是混用。</p><p>get 函数的存在是为了去调用只支持内置指针的函数，且函数中不能 delete 此指针。不要用 get 初始化另一个智能指针或为另一个智能指针赋值。</p><p>reset 和 unique 一起使用：改变底层对象之前，检查自己是否是对象仅有的用户，若不是，改变前制造一份新的拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.unique())</span><br><span class="line">    p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p));</span><br><span class="line">*p += newVal;</span><br></pre></td></tr></table></figure><h2 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h2><p>使用智能指针能保证即便程序抛了异常也能销毁局部对象。</p><p>自定义删除器（deleter）来使 C 风格的代码也有析构函数的特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123; disconnect(*p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(...)</span></span>&#123;</span><br><span class="line">    connection c = connect(...);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当 f 退出（即便出于异常），connection也会被正确关闭。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针的使用基本规范：</p><ul><li>不使用相同的内置指针初始化（或 reset）多个智能指针。</li><li>不 delete get() 返回的指针。</li><li>不使用 get() 初始化或 reset 另一个智能指针。</li><li>如果你使用 get() 返回的指针，记住当最后一个对应的智能指针销毁后，指针就变为无效了。</li><li>如果你使用智能指针管理的资源不是 new 分配的内存，记住传递给它一个删除器。</li></ul><h2 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h2><p>某个时刻只能有一个 unique_ptr 指向一个给定对象，所以不能拷贝和赋值。</p><p><img src="http://static.ifanze.cn/2018-06-23-15128928379952.jpg" alt=""></p><p>但是可以使用<code>release</code>或<code>reset</code>进行转移：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"xxx"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p2(p1.release());</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Tex"</span>));</span><br><span class="line">p2.reset(p3.release());</span><br><span class="line">p2.release();       <span class="comment">// 错误：不释放内存却丢失了指针，release 一般用来初始化或赋值给另一个指针。</span></span><br><span class="line">p2.reset();</span><br></pre></td></tr></table></figure><p>不能拷贝 unique_ptr 的规则有个例外：将要被销毁的 unique_ptr，如作为函数返回值。</p><p>标准库的较早版本使用了一个名为<code>auto_ptr</code>的类，它具有<code>unique_ptr</code>的部分特性，但不是全部，如不能在容器中保存也不能从函数返回，因此，弃用。</p><p>传递删除器的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt; p(&amp;c, end_connection);</span><br></pre></td></tr></table></figure><h2 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h2><p><img src="http://static.ifanze.cn/2018-06-23-15128935571390.jpg" alt=""></p><p>不参与计数的 shared_ptr。不能直接使用它访问对象，而必须调用 lock。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; np = wp.lock())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h1><h2 id="12-2-1-new-和数组"><a href="#12-2-1-new-和数组" class="headerlink" title="12.2.1 new 和数组"></a>12.2.1 new 和数组</h2><p><code>new[]</code>和<code>delete[]</code>。</p><p>标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本。</p><p><img src="http://static.ifanze.cn/2018-06-23-15128943618508.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; up(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    up[i] = i;</span><br><span class="line">up.release();</span><br></pre></td></tr></table></figure><p>但是 shared_ptr 不能直接管理动态数组，需要删除器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p)&#123; <span class="keyword">delete</span>[] p; &#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    *(sp.get() + i) = i;    <span class="comment">// shared_ptr 未定义下标运算符，也不支持算术运算。</span></span><br><span class="line">sp.reset();</span><br></pre></td></tr></table></figure><h2 id="12-2-2-allocator-类"><a href="#12-2-2-allocator-类" class="headerlink" title="12.2.2 allocator 类"></a>12.2.2 allocator 类</h2><p>定义在<code>&lt;memory&gt;</code>，帮助我们将内存分配和对象构造分离开来，分配未构造的内存。</p><p><img src="http://static.ifanze.cn/2018-06-23-15128950213473.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n);</span><br><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">alloc.construct(q++);</span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">'c'</span>);</span><br><span class="line">alloc.construct(q++, <span class="string">"hi"</span>);</span><br><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">    alloc.destroy(--q);</span><br><span class="line">alloc.deallocate(p, n);</span><br></pre></td></tr></table></figure><p><img src="http://static.ifanze.cn/2018-06-23-15128956404634.jpg" alt=""></p><p>这些伴随函数返回（递增后的）目的位置迭代器。</p><h1 id="12-3-使用标准库：文本查询程序"><a href="#12-3-使用标准库：文本查询程序" class="headerlink" title="12.3 使用标准库：文本查询程序"></a>12.3 使用标准库：文本查询程序</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第十二章 动态内存&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 11</title>
    <link href="http://ifanze.cn/2017/12/07/%E3%80%8AC++%20Primer%E3%80%8B(11)/"/>
    <id>http://ifanze.cn/2017/12/07/《C++ Primer》(11)/</id>
    <published>2017-12-07T12:26:00.000Z</published>
    <updated>2018-06-24T10:05:58.074Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第十一章 关联容器</p><a id="more"></a><!-- toc --><h1 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="headerlink" title="第十一章 关联容器"></a>第十一章 关联容器</h1><p>2 <em> 2 </em> 2 = 8种：</p><ul><li><code>set</code>、<code>map</code></li><li><code>multi</code>：允许重复关键字（定义在<code>&lt;map&gt;</code>、<code>&lt;set&gt;</code>）</li><li><code>unordered</code>：无序保存（定义在<code>unordered_map</code>、<code>unordered_set</code>）</li></ul><h1 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h1><p>基本使用。</p><h1 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h1><h2 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h2><h2 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h2><p>有序容器需要关键字类型支持<strong>行为正常</strong>的比较操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(compareIsbn)*&gt; bookstore(compareIsbn);    <span class="comment">// 后面的 compareIsbn 可以换成 &amp;compareIsbn</span></span><br></pre></td></tr></table></figure><p>注意：用 decltype 来获得一个函数指针类型时，必须加上一个<code>*</code>指出我们要得到的是函数的指针。</p><h2 id="11-2-3-pair-类型"><a href="#11-2-3-pair-类型" class="headerlink" title="11.2.3 pair 类型"></a>11.2.3 pair 类型</h2><p>在<code>&lt;utility&gt;</code>中。</p><p><img src="http://static.ifanze.cn/2018-06-23-15126508707740.jpg" alt=""></p><p>如果函数返回 pair：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; process(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        <span class="keyword">return</span> &#123;v.back(), v.back().size()&#125;;     <span class="comment">// 列表初始化（C++11）</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;();             <span class="comment">// 隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;(v.back(), v.back().size());</span><br><span class="line"><span class="keyword">return</span> make_pair(v.back(), v.back().size());</span><br></pre></td></tr></table></figure><h1 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h1><p><img src="http://static.ifanze.cn/2018-06-23-15126510682571.jpg" alt=""></p><h2 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h2><ul><li>关键字类型（包括 pair 的 first）是 const 的。</li><li>对 map 解引用得到的类型是 value_type，是个 pair。</li><li>set 的 iterator 和 const_iterator 都是只读的，不能改变 set 的元素。</li><li>通常不对关联容器使用泛型算法，关键字是 const 这一特性使得算法不能对容器进行修改或重排。关联容器可用于只读算法，如 find，但还是优先使用成员函数版本。</li><li>实际使用中，若是用在泛型算法上，要么当作一个源序列，要么当作一个目标位置（使用 inserter）。</li></ul><h2 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set1.insert(ivec.cbegin(), ivec.cend());</span><br><span class="line">set1.insert(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">map1.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">map1.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">map1.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">map1.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p><img src="http://static.ifanze.cn/2018-06-23-15126518693490.jpg" alt=""></p><p>对于不返回重复关键字的容器，这些函数返回一个 pair，其 first 是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出是插入成功还是已经存在于容器。</p><p>一个单词计数的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.second)</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto 的类型是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;map&lt;string, size_t&gt;::iterator, bool&gt;</span><br></pre></td></tr></table></figure><p>注意，对于<code>mutiset</code>和<code>multimap</code>，一定会插入成功，因此只返回迭代器。</p><h2 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15128849829768.jpg" alt=""></p><h2 id="11-3-4-map-的下标操作"><a href="#11-3-4-map-的下标操作" class="headerlink" title="11.3.4 map 的下标操作"></a>11.3.4 map 的下标操作</h2><p>如果关键字不在 map vs ,下标运算符会创建一个元素并插入到 map 中，并进行值初始化。所以，我们只能对非 const 的 map 使用下标操作。</p><p><img src="http://static.ifanze.cn/2018-06-23-15128851559984.jpg" alt=""></p><p>注意在 map 中，下标操作的返回值和对迭代器进行解引用不一样。前者是 mapped_type，后者是 value_type。但相同的一点是都是左值。</p><h2 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15128852997668.jpg" alt=""></p><p>注意：lower_bound 和 upper_bound 不适用于无序容器。下标和 at 只适用于非 const 的 map 和 unordered_map。</p><p>不能用下标运算符来检查一个元素是否存在！</p><p>如果是在 multimap 或 multiset 查找给定关键字，有三种方法（它们一定是连续存储的）：</p><ol><li>find 和 count：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> count = map1.count(key);</span><br><span class="line"><span class="keyword">auto</span> iter  = map1.find (key);</span><br><span class="line"><span class="keyword">while</span>(count)&#123;</span><br><span class="line">    count &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++iter;</span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>迭代器组：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = map1.lower_bound(key),</span><br><span class="line">          end = map1.upper_bound(key);</span><br><span class="line">     beg != end;</span><br><span class="line">     ++beg)</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>equal_range函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = map1.equal_range(key);</span><br><span class="line">     pos.first != pos.second;</span><br><span class="line">     ++pos.first)</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="11-3-6-一个单词转换的-map"><a href="#11-3-6-一个单词转换的-map" class="headerlink" title="11.3.6 一个单词转换的 map"></a>11.3.6 一个单词转换的 map</h2><h1 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h1><p>无序容器使用一个哈希函数将元素映射到桶。<br><img src="http://static.ifanze.cn/2018-06-23-15128859821311.jpg" alt=""></p><p>无序容器对关键字类型使用<code>==</code>比较元素，还使用<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型，还有string和智能指针等标准库类型定义了hash。</p><p>但是，我们不能定义关键字类型为自定义类类型的无序容器。必须提供自己的 hash 模版。<em>16.5</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> hasher(<span class="keyword">const</span> Sales_data &amp;sd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(haser)*, <span class="keyword">decltype</span>(eqOp)* &gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经定义了 == 运算符，则只重载哈希函数：</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;Foo, <span class="keyword">decltype</span>(FooHash)* &gt; fooSet(<span class="number">10</span>, FooHash);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第十一章 关联容器&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 10</title>
    <link href="http://ifanze.cn/2017/12/03/%E3%80%8AC++%20Primer%E3%80%8B(10)/"/>
    <id>http://ifanze.cn/2017/12/03/《C++ Primer》(10)/</id>
    <published>2017-12-03T12:53:00.000Z</published>
    <updated>2018-06-24T10:05:54.987Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第十章 泛型算法</p><a id="more"></a><!-- toc --><h1 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h1><h1 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h1><ul><li>定义在<code>&lt;algorithm&gt;</code>、<code>&lt;numeric&gt;</code>。</li><li>泛型算法本身不会执行容器的操作，它们只会运行于迭代器上，一般不会改变底层容器的大小。</li></ul><h1 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h1><h2 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h2><p>find、count、accumulate、equal。</p><p>其中，accumulate 是累加，第三个参数是初始值，需要支持 <code>+</code> 运算。equal 操作两个序列，比较指定范围内的元素是否都相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="built_in">string</span>(<span class="string">""</span>));  <span class="comment">// 不能改成""</span></span><br></pre></td></tr></table></figure><h2 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h2><p>注意确保序列原大小至少不小于我们要求写入的元素数目。</p><p>操作两个序列时，有些接受三个迭代器，有些接受四个。</p><p><code>fill</code>函数：在指定位置之间填充指定值。<br><code>fill_n</code>函数：从指定位置开始填充指定数量的指定值。注意空间够不够。<br><code>copy</code>函数：<br><code>replace</code>函数：<br><code>replace_copy</code>函数：</p><p>插入迭代器：向插入迭代器所指元素赋值将插入新值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">0</span>);         <span class="comment">// 错误</span></span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">replace(ilst.begin(), ilst.end(), <span class="number">0</span>, <span class="number">42</span>);</span><br><span class="line">replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure><h2 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h2><ul><li><code>sort</code>函数：排列。</li><li><code>unique</code>函数：排列使不重复的元素出现在前面，返回第一个出现重复的元素的位置。（标准库算法是对迭代器而不是容器进行操作。）</li></ul><h1 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h1><h2 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h2><p>给 sort 等函数多传递一个参数，称作谓词（predicate）：它是一个可调用的表达式，其返回结果是一个能用作条件的值。</p><p>稳定排序：<code>stable_sort</code>。</p><h2 id="10-3-2-lambda-表达式"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式</h2><p><code>find_if</code>函数：第三个参数是一个谓词，返回第一个使谓词返回 true 的元素，否则返回尾迭代器。</p><p>可调用对象包括：</p><ul><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>lambda 表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; return type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p>其中，捕获列表是一个 lambda 所在函数中定义的局部变量的列表（通常为空）。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。</p><p>如果函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b) &#123; <span class="keyword">return</span> a.size() &lt; b.size(); &#125; );</span><br></pre></td></tr></table></figure><p>如果 lambda 表达式还用到它所在函数中的局部非静态变量，必须将它写在捕获列表中。所以 find_if 可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">            [sz] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)</span><br><span class="line">                &#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure><p><code>for_each</code>算法：接受一个可调用对象，对输入序列中每个元素调用此对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(wc, words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;&#125;);</span><br></pre></td></tr></table></figure><h2 id="10-3-3-lambda-捕获和返回"><a href="#10-3-3-lambda-捕获和返回" class="headerlink" title="10.3.3 lambda 捕获和返回"></a>10.3.3 lambda 捕获和返回</h2><p>变量的捕获方式也可以是值或引用。被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();       <span class="comment">// j 为 42</span></span><br></pre></td></tr></table></figure><p>以引用方式捕获：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [&amp;v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();       <span class="comment">// j 为 0</span></span><br></pre></td></tr></table></figure><p>引用捕获和返回引用一样，要确保被引用对象在 lambda 执行的时候是存在的。</p><p>当我们向一个函数传递一个 lambda 时，lambda 会立即执行。</p><p>我们也可以返回一个 lambda，但注意不能包含引用捕获。</p><p>尽量减少捕获的数据量，尽量避免捕获指针或引用。</p><p>可以使用<code>&amp;</code>或<code>=</code>表示隐式捕获，也可以混用隐式捕获和显式捕获。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[=]&#123;<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;);</span><br><span class="line">[=, &amp;os](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure><p><img src="http://static.ifanze.cn/2018-06-23-15124918050273.jpg" alt=""></p><p>如果希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++i; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = f();   <span class="comment">// j 为 43</span></span><br></pre></td></tr></table></figure><p><code>transform</code>算法：将一个序列的元素依次做一个转化，放到另一个指定位置开始的序列中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), vi.begin(),</span><br><span class="line">            [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span></span><br><span class="line">            &#123; <span class="keyword">if</span> ( i &lt; <span class="number">0</span> ) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure><h2 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h2><p>lambda 表达式适合使用次数少、代码少的应用场景，取代函数。但是不能直接把捕获列表作为谓词的参数放到函数的形参中。</p><p>解决方法：使用<code>&lt;functional&gt;</code>中定义的<code>bind</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.size() &gt;= sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(),</span><br><span class="line">                bind(check_size, _1, sz));</span><br></pre></td></tr></table></figure><p>其中，<code>_1</code>是占位符。更一般的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _2, c, _1);</span><br><span class="line"></span><br><span class="line">g(X, Y);</span><br><span class="line">f(a, b, Y, c, X);</span><br></pre></td></tr></table></figure><p>如果需要绑定引用，使用<code>ref</code>或<code>cref</code>函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.begin(), words.end(),</span><br><span class="line">            bind(print, ref(os), _1, <span class="string">' '</span>));</span><br></pre></td></tr></table></figure><p>旧版本的 bind1st 和 bind2nd 应被弃用。</p><h1 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h1><p><iterator> 中还定义了：</p><ul><li>插入迭代器。</li><li>流迭代器。</li><li>反向迭代器。</li><li>移动迭代器。</li></ul><h2 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h2><p><img src="http://static.ifanze.cn/2018-06-23-15124937743666.jpg" alt=""></p><p>三种类型：</p><ul><li><code>back_inserter</code>：创建一个使用 push_back 的迭代器。</li><li><code>front_inserter</code>：创建一个使用 push_front 的迭代器。</li><li><code>inserter</code>：创建一个使用 inserter 的迭代器，此函数接受第二个参数表示位置，元素被插入到它之前。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*it = val;</span><br><span class="line"><span class="comment">//inserter 插入迭代器相当于：</span></span><br><span class="line">it = c.insert(it, val);     <span class="comment">// 指向新加入的元素</span></span><br><span class="line">++it;                       <span class="comment">// 指回原来的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line">copy(lst.cbegin(), lst.cend(), front_inserter(list2));  <span class="comment">// 4,3,2,1，始终指向新首元素。</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));   <span class="comment">// 1,2,3,4</span></span><br></pre></td></tr></table></figure><h2 id="10-4-2-iostream-迭代器"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器</h2><ul><li><code>istream_iterator</code>要读写的类型必须定义了<code>&gt;&gt;</code>。</li><li><code>ostream_iterator</code>要读写的类型必须定义了<code>&lt;&lt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造1：使用流</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_it(<span class="built_in">cin</span>);</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"afile"</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; str_it(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造2：默认初始化</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof;          <span class="comment">// 可得到尾后迭代器，一旦到文件尾或者IO错误，迭代器就与之相等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法1: 从流中读内容</span></span><br><span class="line"><span class="keyword">while</span> (int_it != int_eof)</span><br><span class="line">    ivec.push_back(*in_it++);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法2: 两个迭代器结合用来构造容器</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>), eof;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(in_iter, eof);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法3：算法中使用</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in(<span class="built_in">cin</span>), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><img src="http://static.ifanze.cn/2018-06-23-15126478937848.jpg" alt=""></p><p>注意：标准库不保证迭代器立即从流读取数据，允许使用懒惰求值，只保证在第一次解引用前完成从流中读数据的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 用法1：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    out_iter = e;   <span class="comment">// 等效于 *out_iter++ = e;，但推荐别简写。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 用法2：</span></span><br><span class="line">copy(vec.begin(), vec.end(), out_iter);</span><br></pre></td></tr></table></figure><h2 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h2><ul><li><code>rbegin</code>、<code>rend</code>、<code>crbegin</code>、<code>crend</code>。</li><li>反响迭代器需要<code>--</code>运算符。</li><li>可以调用<code>base()</code>转化成正常迭代器。</li></ul><p><img src="http://static.ifanze.cn/2018-06-23-15126482760762.jpg" alt=""></p><h1 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h1><h2 id="10-5-1-5类迭代器"><a href="#10-5-1-5类迭代器" class="headerlink" title="10.5.1 5类迭代器"></a>10.5.1 5类迭代器</h2><p><img src="http://static.ifanze.cn/2018-06-23-15126484658475.jpg" alt=""></p><h2 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg(beg, end, ...);</span><br><span class="line">alg(beg, end, dest, ...);</span><br><span class="line">alg(beg, end, beg2, ...);</span><br><span class="line">alg(beg, end, beg2, end2, ...);</span><br></pre></td></tr></table></figure><h2 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h2><p>重载一个谓词：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique(beg, end);</span><br><span class="line">unique(beg, end, comp);</span><br></pre></td></tr></table></figure><p>_if 版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find(beg, end, val);</span><br><span class="line">find_if(beg, end, pred);</span><br></pre></td></tr></table></figure><p>区分拷贝不拷贝的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(beg, end);</span><br><span class="line">reverse_copy(beg, end, dest);</span><br></pre></td></tr></table></figure><p>同时包含上面两点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remove_if(beg, end, pred);</span><br><span class="line">remove_copy_if(beg, end, dest, pred);</span><br></pre></td></tr></table></figure><h1 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h1><p>list 和 forward_list 还定义了：</p><p><img src="http://static.ifanze.cn/2018-06-23-15126493120661.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15126493216728.jpg" alt=""></p><p>通用版本的 sort 要求随机访问迭代器，不能用于它们。list 和 forward_list 应优先使用成员函数版本的算法。</p><p>另外还有<code>splice</code>成员：<br><img src="http://static.ifanze.cn/2018-06-23-15126493931751.jpg" alt=""></p><p>有些链表版本的算法与通用版本有区别，主要是会改变底层结构。包括<code>remove</code>、<code>unique</code>、<code>merge</code>、<code>splice</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第十章 泛型算法&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 9</title>
    <link href="http://ifanze.cn/2017/12/03/%E3%80%8AC++%20Primer%E3%80%8B(9)/"/>
    <id>http://ifanze.cn/2017/12/03/《C++ Primer》(9)/</id>
    <published>2017-12-03T06:29:00.000Z</published>
    <updated>2018-06-24T10:05:50.195Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第九章 顺序容器</p><a id="more"></a><!-- toc --><h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><h1 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h1><p><img src="http://static.ifanze.cn/2018-06-23-15122827443766.jpg" alt=""></p><p>选用原则：</p><ul><li>除非有更好的理由，否则应用 vector。</li><li>如果元素小而多，空间开销很重要，不要用 list 或 forward_list。</li><li>要求随机访问：vector、deque。</li><li>在中间插入删除：list、forward_list。</li><li>在头尾插入删除：deque。</li></ul><h1 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h1><p>本节介绍对所有容器都适用的操作。</p><p><img src="http://static.ifanze.cn/2018-06-23-15122850635998.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15122850769038.jpg" alt=""></p><h2 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h2><h2 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h2><h2 id="9-2-3-begin-和-end-成员"><a href="#9-2-3-begin-和-end-成员" class="headerlink" title="9.2.3 begin 和 end 成员"></a>9.2.3 begin 和 end 成员</h2><h2 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122854553092.jpg" alt=""></p><p>将一个容器初始化为另一个容器的拷贝：</p><ul><li>拷贝整个容器：容器类型和元素类型必须都匹配。</li><li>拷贝一对迭代器指定的范围：只需要元素类型匹配，甚至是可转换。</li></ul><p>定义 array 容器不但要指定元素类型，还要制定容器大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 10&gt;</span><br></pre></td></tr></table></figure><p>如果元素类型是类类型，则它必须有一个默认构造函数，以使值初始化能够进行。</p><h2 id="9-2-5-赋值和-swap"><a href="#9-2-5-赋值和-swap" class="headerlink" title="9.2.5 赋值和 swap"></a>9.2.5 赋值和 swap</h2><p>array 允许赋值，但类型和大小必须相同，且不允许用花括号包围的值列表进行赋值。</p><p><img src="http://static.ifanze.cn/2018-06-23-15122861450508.jpg" alt=""></p><p>assign 不用保证容器类型要相同，只需元素类型相容即可。</p><p>除 array 外，swap 不对任何元素进行拷贝、删除、插入操作，保证在常数时间完成，只是交换了两个容器的内部数据结构。因此指向容器的迭代器、引用、指针都不会失效（除 string）。</p><p>统一使用非成员版本的 swap 是一个好习惯。（泛型编程很重要）</p><h2 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h2><p>size()、empty()、max_size()</p><h2 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h2><p>==、!=、&gt;、&gt;=、&lt;、&lt;=</p><h1 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h1><h2 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122872873379.jpg" alt=""></p><p>emplace 是构造而不是拷贝元素。其参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。</p><h2 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122876911112.jpg" alt=""></p><p>下标访问若是越界，[]报运行时错误，at 抛出 out_of_range 异常。</p><h2 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122878427283.jpg" alt=""></p><h2 id="9-3-4-特殊的-forward-list-操作"><a href="#9-3-4-特殊的-forward-list-操作" class="headerlink" title="9.3.4 特殊的 forward_list 操作"></a>9.3.4 特殊的 forward_list 操作</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122880697822.jpg" alt=""></p><p>核心思想：单向列表的添加删除，影响的是其前驱元素。所以，如果是遍历过程中进行添加或删除，往往要关注两个迭代器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forward_list&lt;<span class="keyword">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> prev = flst.before_begin();</span><br><span class="line"><span class="keyword">auto</span> curr = flst.begin();</span><br><span class="line"><span class="keyword">while</span> (curr != flst.end())&#123;</span><br><span class="line">    <span class="keyword">if</span> (*curr % <span class="number">2</span>)</span><br><span class="line">        curr = flst.erase_after(prev);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        ++curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122883564813.jpg" alt=""></p><h2 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h2><h1 id="9-4-vector-对象是如何增长的"><a href="#9-4-vector-对象是如何增长的" class="headerlink" title="9.4 vector 对象是如何增长的"></a>9.4 vector 对象是如何增长的</h1><p>vector 和 string 一定是连续的，空间不够了会移动所有元素。</p><p><img src="http://static.ifanze.cn/2018-06-23-15122902887066.jpg" alt=""></p><p>reserve 不改变元素的数量，且永远也不会减少容器占用的内存空间。<br>resize 只改变容器中的元素数目。</p><h1 id="9-5-额外的-string-操作"><a href="#9-5-额外的-string-操作" class="headerlink" title="9.5 额外的 string 操作"></a>9.5 额外的 string 操作</h1><h2 id="9-5-1-构造-string-的其他方法"><a href="#9-5-1-构造-string-的其他方法" class="headerlink" title="9.5.1 构造 string 的其他方法"></a>9.5.1 构造 string 的其他方法</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122905813562.jpg" alt=""></p><p><img src="http://static.ifanze.cn/2018-06-23-15122906238886.jpg" alt=""></p><h2 id="9-5-2-改变-string-的其他方法"><a href="#9-5-2-改变-string-的其他方法" class="headerlink" title="9.5.2 改变 string 的其他方法"></a>9.5.2 改变 string 的其他方法</h2><ul><li>额外的 insert、erase 版本，在指定位置插入指定数量的指定字符。</li><li>接受 C 风格字符数组的 insert 和 assign 版本。</li><li>append、replace。</li></ul><p><img src="http://static.ifanze.cn/2018-06-23-15122908256116.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15122908459896.jpg" alt=""></p><h2 id="9-5-3-string-搜索操作"><a href="#9-5-3-string-搜索操作" class="headerlink" title="9.5.3 string 搜索操作"></a>9.5.3 string 搜索操作</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122909135162.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15122909191619.jpg" alt=""></p><h2 id="9-5-4-compare-函数"><a href="#9-5-4-compare-函数" class="headerlink" title="9.5.4 compare 函数"></a>9.5.4 compare 函数</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122909573903.jpg" alt=""></p><h2 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122910145159.jpg" alt=""></p><h1 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h1><p>stack、queue、priority_queue。</p><p><img src="http://static.ifanze.cn/2018-06-23-15122915101195.jpg" alt=""></p><p>定义一个适配器：</p><ul><li>默认情况下，stack 和 queue 是基于 deque 实现的，priority_queue 是在 vector 之上实现的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">std</span>(deq);</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure><p>所有适配器都要求容器具有添加、删除、访问尾元素的能力，所以不能使用 array、forward_list。剩下的：</p><ul><li>都可用于构造 stack，因为它只要求 push_back、pop_back、back。</li><li>只有 list 或 deque 能构造 queue，因为它要求 back、push_back、front、push_front。</li><li>只有 vector 或 deque 能构造 priority_queue，因为它要求 front、push_back、pop_back、随机访问。</li></ul><p><img src="http://static.ifanze.cn/2018-06-23-15122920763028.jpg" alt=""></p><p><img src="http://static.ifanze.cn/2018-06-23-15122921377197.jpg" alt=""><br><img src="http://static.ifanze.cn/2018-06-23-15122921500473.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第九章 顺序容器&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 8</title>
    <link href="http://ifanze.cn/2017/12/03/%E3%80%8AC++%20Primer%E3%80%8B(8)/"/>
    <id>http://ifanze.cn/2017/12/03/《C++ Primer》(8)/</id>
    <published>2017-12-02T16:53:00.000Z</published>
    <updated>2018-06-24T10:05:46.899Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第八章 IO库</p><a id="more"></a><!-- toc --><h1 id="第八章-IO库"><a href="#第八章-IO库" class="headerlink" title="第八章 IO库"></a>第八章 IO库</h1><h1 id="8-1-IO-类"><a href="#8-1-IO-类" class="headerlink" title="8.1 IO 类"></a>8.1 IO 类</h1><p><img src="http://static.ifanze.cn/2018-06-23-15122337573935.jpg" alt=""></p><p>ifstring 和 istringstream 都集成自 istream。</p><h2 id="8-1-1-IO-对象无拷贝或赋值"><a href="#8-1-1-IO-对象无拷贝或赋值" class="headerlink" title="8.1.1 IO 对象无拷贝或赋值"></a>8.1.1 IO 对象无拷贝或赋值</h2><p>不能拷贝或赋值。<br>流类型不能作为函数返回类型。<br>传递和返回的引用不能是 const 的。</p><h2 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122340445778.jpg" alt=""></p><p><img src="http://static.ifanze.cn/2018-06-23-15122340524000.jpg" alt=""></p><h1 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h1><ul><li><code>ifstream</code>：从文件读数据，继承自<code>istream</code>。</li><li><code>ofstream</code>：从文件写数据，继承自<code>ostream</code>。</li><li><code>fstream</code>：从文件读写数据。</li></ul><p><img src="http://static.ifanze.cn/2018-06-23-15122809025479.jpg" alt=""></p><h2 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h2><p>open() 失败会将 failbit 置位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;</span><br><span class="line">out.open(<span class="string">"xxx"</span>);</span><br><span class="line"><span class="keyword">if</span> (out)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>记得关闭后再打开其他文件，离开作用域析构时会自动调用<code>close()</code>。</p><h2 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h2><p><img src="http://static.ifanze.cn/2018-06-23-15122819839857.jpg" alt=""></p><ul><li>只可以对 ofstream 或 fstream 对象设定 out 模式。</li><li>只可以对 ifstream 或 fstream 对象设定 in 模式。</li><li>只有当 out 也被设定时才可设定 trunc 模式。</li><li>只要 trunc 没被设定，就可以设定 app 模式。app 模式总是以输出方式被打开。</li><li>默认情况下，out 模式会有 trunc 效果，所以追加请同时指定 app，或者 in。</li><li>ate 和 binary 可任意组合。</li></ul><h1 id="8-3-string-流"><a href="#8-3-string-流" class="headerlink" title="8.3 string 流"></a>8.3 string 流</h1><ul><li><code>istringstream</code></li><li><code>ostringstream</code></li><li><code>stringstream</code></li></ul><p><img src="http://static.ifanze.cn/2018-06-23-15122823729187.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第八章 IO库&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 7</title>
    <link href="http://ifanze.cn/2017/11/29/%E3%80%8AC++%20Primer%E3%80%8B(7)/"/>
    <id>http://ifanze.cn/2017/11/29/《C++ Primer》(7)/</id>
    <published>2017-11-28T16:33:00.000Z</published>
    <updated>2018-06-24T10:05:43.079Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第七章 类</p><a id="more"></a><!-- toc --><h1 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h1><h1 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h1><ul><li>成员函数的定义。</li><li>this 指针的理解。</li><li>const 成员函数：意味着 this 是一个指向常量的指针，只能读取它的对象的数据成员，但是不能写入。</li><li>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</li><li>合成的默认构造函数：<ul><li>如果存在类内的初始值，用它来初始化成员。</li><li>否则，默认初始化该成员。</li><li>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</li><li>如果声明了其他构造函数，有需要一个构造函数的默认行为，可以使用<code>= default</code>。</li></ul></li><li>构造函数不应该轻易覆盖掉类内的初始值，除非新值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</li></ul><h1 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h1><p>l<br>private 和 public。</p><h2 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h2><h1 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h1><h2 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a>7.3.1 类成员再探</h2><ul><li>定义一个类型成员：使用 typedef 或 using，达到隐藏实现细节的作用。</li><li>可变数据成员：在成员变量的声明前使用<code>mutable</code>修饰，代表它永远不会是 const，即便在 const 函数中也能修改它。</li><li>当我们提供一个类内初始值时，必须以<code>=</code>或者花括号表示。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, '')&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-3-2-返回-this-的成员函数"><a href="#7-3-2-返回-this-的成员函数" class="headerlink" title="7.3.2 返回 *this 的成员函数"></a>7.3.2 返回 *this 的成员函数</h2><ul><li>返回值用引用可实现连环调用，但对于返回常量引用的调用来说，这些还不够。</li><li>一种比较好的设计：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Screen &#123;</span><br><span class="line">public:</span><br><span class="line">    Screen &amp;display(std::ostream &amp;os)</span><br><span class="line">    &#123;</span><br><span class="line">        do_display(os); </span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    const Screen &amp;display(std::ostream &amp;os) const</span><br><span class="line">    &#123;</span><br><span class="line">        do_display(os); </span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void do_display(std::ostream &amp;os) const</span><br><span class="line">    &#123;</span><br><span class="line">        os &lt;&lt; contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h2><ul><li>类可以做前向声明（forward declaration），在它声明之后定义之前是一个不完全类型（incomplete type），此时不能创建它的对象。</li><li>所以一个类的成员类型不能是它自己，但可以是它的引用或指针。</li></ul><h2 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h2><ul><li>可以声明友元类或友元类成员函数。</li><li>友元关系不存在传递性。</li><li>重载函数必须分别声明友元关系。</li><li><p>要想令某个成员函数作为友元，必须严格遵守以下顺序：</p><ol><li>先定义 Window_mgr 类，其中声明 clear 函数，但不能定义它。</li><li>定义 Screen 类，包括对于 clear 的友元声明。</li><li>定义 clear。</li></ol></li><li><p>声明友元函数不代表声明了该函数，该函数依然需要在类的外部进行声明，且在声明后才能被使用。（有的编译器并不强制执行该规则。）</p></li></ul><h1 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h1><p>名字查找（name lookup）的一般过程：</p><pre><code>1. 在名字所在块中寻找声明，只考虑在名字使用之前出现的声明。2. 如果没有找到，继续查找外层作用域。3. 如果最终没有找到，程序报错。</code></pre><p>对于定义在类内部的成员函数：</p><pre><code>1. 首先，编译成员的声明。2. 直到类全部可见后才编译函数体。</code></pre><h1 id="7-5-类的函数再探"><a href="#7-5-类的函数再探" class="headerlink" title="7.5 类的函数再探"></a>7.5 类的函数再探</h1><h2 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a>7.5.1 构造函数初始值列表</h2><ul><li>初始化和构造函数里赋值的区别。</li><li>初始化顺序。</li><li>构造函数的默认实参。</li></ul><h2 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h2><p>C++11 允许构造函数把活交给别的构造函数干。</p><h2 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h2><p>使用默认构造函数不要加<code>()</code>，不然是定义了一个函数。</p><h2 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h2><p>如果构造函数只接受一个实参，则它实际上定义了一种类型的隐式转换机制，有时把它称之为转换构造函数（converting constructor）。</p><p>但是注意，只允许一步类类型转换。如 “xxxx” 转 sring 再转某 class 是非法的。除非显式地使用 <code>string(&quot;xxx&quot;)</code>进行转换。</p><p>想阻止这种转换，可将构造函数声明为<code>explicit</code>。它将只能以直接初始化的形式使用，而且，编译器将不会在自动转换过程中使用该构造函数（不能再使用<code>=</code>将参数类型的对象用于拷贝形式的初始化过程）。</p><p>但依然可以用显式转化实现。如<code>static_cast&lt;Sales_data&gt;(xxx)</code>或<code>Sales_data(xxx)</code>。</p><p>在标准库中：</p><pre><code>- 接受 const char * 的 string 构造函数不是 explicit 的。- 接受一个容器参数的 vector 构造函数是 explicit 的。</code></pre><h2 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h2><p>聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。需要满足以下条件：</p><ul><li>所有成员都是 public 的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，没有 virtual 函数。</li></ul><p>可以提供一个花括号括起来的成员初始值列表，用它来初始化聚合类数据成员，顺序必须一致。</p><p>这种类缺点也较为明显：</p><ul><li>要求所有成员 public。</li><li>用户决定初始化。</li><li>更改成员后修改代价大。</li></ul><h2 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h2><p>数据成员都是字面值类型的聚合类是字面值常量类。或者满足以下条件也是：</p><ul><li>数据成员都必须是字面值类型。</li><li>类必须至少含有一个 constexpr 构造函数。</li><li>若数据成员含有初始值，则该值必须是一条常量表达式。如果该成员属于某类类型，初始值必须使用成员自己的 constexpr 构造函数。</li><li>必须使用析构函数的默认定义。</li></ul><h1 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h1><ul><li>既可使用类名，也可使用对象访问静态成员。</li><li>在类的外部定义静态成员时，不能重复 static 关键字。</li><li>由于静态成员并不是在创建类的对象时被定义的，所以一般不能在类内进行初始化。（除了返回值是常量表达式的情况。）</li><li>和其他对象一样，一个静态数据成员只能定义一次，最好与其他非内联函数的定义放在同一个文件中。</li><li><p>即使一个常量静态数据成员在类内部被初始化了，通常也应在类的外部定义一下该成员。</p></li><li><p>由于静态成员独立于任何对象，所以有些特性：可以是不完全类型，可以就是它所属类的类型，可以用作默认实参。这些非静态成员都不可以。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第七章 类&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 6</title>
    <link href="http://ifanze.cn/2017/11/26/%E3%80%8AC++%20Primer%E3%80%8B(6)/"/>
    <id>http://ifanze.cn/2017/11/26/《C++ Primer》(6)/</id>
    <published>2017-11-26T11:30:00.000Z</published>
    <updated>2018-06-24T10:05:39.860Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第六章 函数</p><a id="more"></a><!-- toc --><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h1 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h1><ul><li>编写和调用。</li><li>形参和实参。</li><li>形参列表和返回类型。</li></ul><h2 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h2><ul><li>自动对象。</li><li>局部静态对象：在程序执行路径第一次经过该对象的定义时初始化，直到程序终止才被销毁。</li></ul><h2 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h2><ul><li>函数的三要素：返回类型、函数名、形参类型。</li><li>函数原型：即函数声明。</li></ul><h2 id="6-1-3-分离式编译"><a href="#6-1-3-分离式编译" class="headerlink" title="6.1.3 分离式编译"></a>6.1.3 分离式编译</h2><ul><li>在头文件中进行函数声明。</li></ul><h1 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h1><h2 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h2><h2 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h2><h2 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h2><p>和其他初始化过程一样，用实参初始化形参时会忽略掉顶层 const。</p><p>尽量使用常量引用。</p><h2 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h2><p>数组有两个性质：不允许拷贝，使用时会转换成指针。</p><p>几种传递数组长度信息的方法：</p><ul><li>C风格字符串使用标记位。</li><li>标准库规范，传两个指针。</li><li>再传递一个表示大小的参数。</li></ul><p>可以使用数组引用形参，但这会限制数组的大小。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void print(int (&amp;arr) [10]);</span><br></pre></td></tr></table></figure><p>传递多维数组：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void print(int (*matrix)[10], int rowSize);</span><br></pre></td></tr></table></figure><h2 id="6-2-5-main-处理命令行选项"><a href="#6-2-5-main-处理命令行选项" class="headerlink" title="6.2.5 main: 处理命令行选项"></a>6.2.5 main: 处理命令行选项</h2><h2 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h2><p>两种方式：</p><ul><li>若类型相同，可使用 <code>initializer_list</code> 的标准库类型。</li><li>若类型不同，可编写一种特殊的函数，即可变参数模板。<em>16.4</em></li></ul><p>还有种使用省略符的方法，一般只用于与C函数交互的接口程序。</p><p><img src="http://static.ifanze.cn/2018-06-23-15117024905657.jpg" alt=""></p><p>注意，实参要使用花括号的形式。</p><h1 id="6-3-返回类型和-return-语句"><a href="#6-3-返回类型和-return-语句" class="headerlink" title="6.3 返回类型和 return 语句"></a>6.3 返回类型和 return 语句</h1><h2 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a>6.3.1 无返回值函数</h2><h2 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a>6.3.2 有返回值函数</h2><p>C++11中，函数可以返回花括号包围的值的列表。因为返回的值是用于初始化调用点的一个临时量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; process()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"xxx"</span>, <span class="string">"xxxx"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数可以返回<code>&lt;cstdlib&gt;</code>里的<code>EXIT_FAILURE</code>或<code>EXIT_SUCCESS</code>。</p><h2 id="6-3-3-返回数组的指针"><a href="#6-3-3-返回数组的指针" class="headerlink" title="6.3.3 返回数组的指针"></a>6.3.3 返回数组的指针</h2><p>因为数组不能拷贝，所以函数不能返回数组。不过可以返回数组的指针或引用。有以下几种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 声明一个返回数组指针的函数</span></span><br><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用尾置返回类型(C++11)</span></span><br><span class="line">auto func(int i) -&gt; int(*)[10];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 使用 decltype (C++11)</span></span><br><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h1><p>有无顶层 const 形参无法区分开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 错误示例</span><br><span class="line">Record lookup(Phone);</span><br><span class="line">Record lookup(const Phone);</span><br><span class="line"></span><br><span class="line">Record lookup(Phone*);</span><br><span class="line">Record lookup(Phone* const);</span><br></pre></td></tr></table></figure><p>底层 const 可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Record lookup(Account&amp;);</span><br><span class="line">Record lookup(const Account&amp;);</span><br><span class="line"></span><br><span class="line">Record lookup(Account*);</span><br><span class="line">Record lookup(const Account*);</span><br></pre></td></tr></table></figure><p><code>const_cast</code>在重载场景下最有用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const string &amp;shorterString(const string &amp;s1, const string &amp;s2)</span><br><span class="line">&#123;</span><br><span class="line">    return s1.size() &lt;= s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string&amp; shorterString(string&amp; s1, string&amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">    auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1),</span><br><span class="line">    const_cast&lt;const string&amp;&gt;(s2));</span><br><span class="line">    return const_cast&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，所有重载函数的声明应放在同一作用域下。</p><h1 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h1><h2 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h2><p>注意，声明时，每个形参只能被赋予一次默认实参，可以在不同声明中为不同形参添加默认实参。</p><p>默认形参的初始值可以是变量，但不能是局部变量，必须声明在函数之外，可以在调用前被别的函数所更改。</p><h2 id="6-5-2-内联函数和-constexp-函数"><a href="#6-5-2-内联函数和-constexp-函数" class="headerlink" title="6.5.2 内联函数和 constexp 函数"></a>6.5.2 内联函数和 constexp 函数</h2><p>inline 只是向编译器发出了一个请求，编译器可以选择忽略这个请求。</p><p>constexp 函数的约定：</p><ul><li>返回值及所有形参类型都是字面值类型。</li><li>函数题中必须有且只有一条 return 语句。</li></ul><p>这两种函数可以在程序中多次定义，但是必须完全一致，因此通常定义在头文件中。</p><h2 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a>6.5.3 调试帮助</h2><ul><li>assert 预处理宏：<code>&lt;cassert&gt;</code>中。</li><li>NDEBUG 预处理变量：如果被定义，assert 将不起作用。</li></ul><p>可以结合<code>#ifndef</code>进行调试。</p><p>编译器也定义了一些局部静态变量，可帮助调试：<code>__FILE__</code>、<code>__LINE__</code>、<code>__TIME__</code>、<code>__DATE__</code>。</p><h1 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h1><ol><li><p>确定候选函数。</p><ul><li>同名。</li><li>可见。</li></ul></li><li><p>选出可行函数。</p><ul><li>参数数量相等（考虑默认值）。</li><li>参数类型相同，或能转换。</li></ul></li><li><p>寻找最佳匹配。（如果有的话）</p><ul><li><p>逐一检查参数，寻找最匹配的。需要：</p><ul><li>每个参数的匹配都不劣于匹配其他函数。</li><li>至少有一个参数的匹配优于匹配其他函数。</li></ul></li><li><p>如果并不是有且只有一个函数满足，编译器将报二义性调用的错误信息。</p></li></ul></li></ol><p>设计良好的系统中，不应该对实参进行强制类型转换。</p><p>实参类型转换的等级：</p><ol><li><p>精确匹配。</p><ul><li>类型相同。</li><li>从数组或函数类型转成对应的指针类型。（<em>6.7</em>）</li><li>添加或删除顶层 const。</li></ul></li><li><p>通过 const 转换实现的匹配。（<em>4.11.2</em>）</p></li><li>通过类型提升实现的匹配。（<em>4.11.1</em>）</li><li>通过算数类型转换或指针转换实现的匹配。（<em>4.11.1、4.11.2</em>）</li><li>通过类类型转换实现的匹配。（<em>14.9</em>）    </li></ol><h1 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 赋值（&amp;可选）</span></span><br><span class="line">pf = <span class="number">0</span>;</span><br><span class="line">pf = <span class="literal">nullptr</span>;</span><br><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用</span></span><br><span class="line">pf(<span class="string">"xx"</span>, <span class="string">"xx"</span>);</span><br><span class="line">(*pf)(<span class="string">"xx"</span>, <span class="string">"xx"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 函数指针形参</span></span><br><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool pf(const string &amp;, const string &amp;));</span><br><span class="line">void useBigger(const string&amp; s1, const string&amp; s2, bool (*pf)(const string &amp;, const string &amp;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 使用别名(*不能省略，不然是函数的别名)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 返回指向函数的指针((*)不能省略，不然是函数的别名)</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;     <span class="comment">// *不能省略，返回值不能是函数。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);  <span class="comment">// 不用别名的写法。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span> &amp;);    <span class="comment">// 使用 decltype 的写法，*不能省略。</span></span><br></pre></td></tr></table></figure><p>如果指向重载函数，只能是符合它的那个。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 6.1 实参和形参的区别。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.2 不要省略函数定义中的返回值类型、返回语句、大括号。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.3 编写阶乘函数。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.4 读入数据，使用编写的函数。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.5 编写绝对值函数。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.6 形参、局部变量、局部静态变量的区别。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.7 静态变量的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.8 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.9 理解编译器的分离式编译。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.10 编写交换函数。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.11 传引用。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.12 传引用和传指针的比较。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.13 传引用和传值。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.14 传引用。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.15 传值、传引用、传常量引用。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.16 尽量传常量引用。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.17 传引用、传常量引用的使用场景。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.18 传引用、传迭代器的使用场景。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.19 实参格式。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.20 传引用、传常量引用的使用场景。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.21 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.22 编写交换两个指针的函数。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.23 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.24 传数组。<em>KEY: 可使用：<code>void print10(const int (&amp;ia)[10] ) { }</code>。</em></li><li style="list-style: none"><input type="checkbox" checked></input> 6.25 <code>main()</code>的参数。</li><li style="list-style: none"><input type="checkbox" checked></input> 6.26 <code>main()</code>的参数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第六章 函数&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 5</title>
    <link href="http://ifanze.cn/2017/11/26/%E3%80%8AC++%20Primer%E3%80%8B(5)/"/>
    <id>http://ifanze.cn/2017/11/26/《C++ Primer》(5)/</id>
    <published>2017-11-26T09:17:00.000Z</published>
    <updated>2018-06-24T10:05:35.621Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第五章 语句</p><a id="more"></a><!-- toc --><h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 5.1 空语句。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.2 块。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.3 逗号运算符。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.4 注意初始化和作用域。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.5 <code>if</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.6 <code>if</code>转条件运算符。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.7 <code>if</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.8 <code>if</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.9 <code>if</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.10 <code>if</code>、<code>switch</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.11 <code>if</code>、<code>switch</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.12 <code>if</code>、<code>switch</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.13 <code>switch</code>的常见错误。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.14 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.15 <code>for</code>找错。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.16 <code>while</code>和<code>for</code>的比较。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.17 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.18 <code>while</code>找错。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.19 <code>do while</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.20 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.21 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.22 简单编程练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.23 除法练习。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.24 <code>try catch</code>的使用。</li><li style="list-style: none"><input type="checkbox" checked></input> 5.25 <code>try catch</code>的使用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第五章 语句&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
