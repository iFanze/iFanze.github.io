<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meng Fanze&#39;s Blog</title>
  
  <subtitle>C++、Web、Game</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ifanze.cn/"/>
  <updated>2019-07-15T00:18:38.438Z</updated>
  <id>http://ifanze.cn/</id>
  
  <author>
    <name>Meng Fanze</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>非阻塞网络编程</title>
    <link href="http://ifanze.cn/2018/09/01/%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://ifanze.cn/2018/09/01/非阻塞网络编程/</id>
    <published>2018-09-01T09:42:43.000Z</published>
    <updated>2019-07-15T00:18:38.438Z</updated>
    
    <content type="html"><![CDATA[<p>One Sentence.</p><a id="more"></a><!-- toc --><h3 id="简单的阻塞客户端"><a href="#简单的阻塞客户端" class="headerlink" title="简单的阻塞客户端"></a>简单的阻塞客户端</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For gethostbyname */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> query[] =</span><br><span class="line">        <span class="string">"GET / HTTP/1.0\r\n"</span></span><br><span class="line">        <span class="string">"Host: www.google.com\r\n"</span></span><br><span class="line">        <span class="string">"\r\n"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> hostname[] = <span class="string">"www.google.com"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">h</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">ssize_t</span> n_written, remaining;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the IP address for the hostname.   Watch out; this isn't</span></span><br><span class="line"><span class="comment">       threadsafe on most platforms. */</span></span><br><span class="line">    h = gethostbyname(hostname);</span><br><span class="line">    <span class="keyword">if</span> (!h) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't lookup %s: %s"</span>, hostname, hstrerror(h_errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;h_addrtype != AF_INET) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"No ipv6 support, sorry."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a new socket */</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Connect to the remote host. */</span></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr = *(struct in_addr*)h-&gt;h_addr;</span><br><span class="line">    <span class="keyword">if</span> (connect(fd, (struct sockaddr*) &amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>))) &#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the query. */</span></span><br><span class="line">    <span class="comment">/* XXX Can send succeed partially? */</span></span><br><span class="line">    cp = query;</span><br><span class="line">    remaining = <span class="built_in">strlen</span>(query);</span><br><span class="line">    <span class="keyword">while</span> (remaining) &#123;</span><br><span class="line">      n_written = send(fd, cp, remaining, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (n_written &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"send"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      remaining -= n_written;</span><br><span class="line">      cp += n_written;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get an answer back. */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> result = recv(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"recv"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fwrite(buf, <span class="number">1</span>, result, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bad example:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This won't work. */</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> i, n;</span><br><span class="line"><span class="keyword">while</span> (i_still_want_to_read()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n_sockets; ++i) &#123;</span><br><span class="line">        n = recv(fd[i], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">            handle_close(fd[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">            handle_error(fd[i], errno);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            handle_input(fd[i], buf, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对每个连接fork后进行处理的服务器"><a href="#对每个连接fork后进行处理的服务器" class="headerlink" title="对每个连接fork后进行处理的服务器"></a>对每个连接fork后进行处理的服务器</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span></span><br><span class="line">rot13_char(<span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We don't want to use isalpha here; setting the locale would change</span></span><br><span class="line"><span class="comment">     * which characters are considered alphabetical. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'m'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'M'</span>))</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'n'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'N'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>))</span><br><span class="line">        <span class="keyword">return</span> c - <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">child(<span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> outbuf[MAX_LINE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">size_t</span> outbuf_used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        result = recv(fd, &amp;ch, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"read"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We do this test to keep the user from overflowing the buffer. */</span></span><br><span class="line">        <span class="keyword">if</span> (outbuf_used &lt; <span class="keyword">sizeof</span>(outbuf)) &#123;</span><br><span class="line">            outbuf[outbuf_used++] = rot13_char(ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'\n'</span>) &#123;</span><br><span class="line">            send(fd, outbuf, outbuf_used, <span class="number">0</span>);</span><br><span class="line">            outbuf_used = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">run(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> listener;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">40713</span>);</span><br><span class="line"></span><br><span class="line">    listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <span class="keyword">sizeof</span>(one));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listener, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listener, <span class="number">16</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">        <span class="keyword">int</span> fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"accept"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                child(fd);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span><br><span class="line">&#123;</span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入非阻塞、忙轮询：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This will work, but the performance will be unforgivably bad. */</span></span><br><span class="line"><span class="keyword">int</span> i, n;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; n_sockets; ++i)</span><br><span class="line">    fcntl(fd[i], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i_still_want_to_read()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; n_sockets; ++i) &#123;</span><br><span class="line">        n = recv(fd[i], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            handle_close(fd[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                 ; <span class="comment">/* The kernel didn't have any data for us to read. */</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                 handle_error(fd[i], errno);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handle_input(fd[i], buf, n);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-select"><a href="#使用-select" class="headerlink" title="使用 select"></a>使用 select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If you only have a couple dozen fds, this version won't be awful */</span></span><br><span class="line">fd_set readset;</span><br><span class="line"><span class="keyword">int</span> i, n;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i_still_want_to_read()) &#123;</span><br><span class="line">    <span class="keyword">int</span> maxfd = <span class="number">-1</span>;</span><br><span class="line">    FD_ZERO(&amp;readset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add all of the interesting fds to readset */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; n_sockets; ++i) &#123;</span><br><span class="line">         <span class="keyword">if</span> (fd[i]&gt;maxfd) maxfd = fd[i];</span><br><span class="line">         FD_SET(fd[i], &amp;readset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait until one or more fds are ready to read */</span></span><br><span class="line">    select(maxfd+<span class="number">1</span>, &amp;readset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process all of the fds that are still set in readset */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; n_sockets; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(fd[i], &amp;readset)) &#123;</span><br><span class="line">            n = recv(fd[i], buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                handle_close(fd[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                     ; <span class="comment">/* The kernel didn't have any data for us to read. */</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                     handle_error(fd[i], errno);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handle_input(fd[i], buf, n);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select()-based ROT13 server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For fcntl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/* for select */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span></span><br><span class="line">rot13_char(<span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We don't want to use isalpha here; setting the locale would change</span></span><br><span class="line"><span class="comment">     * which characters are considered alphabetical. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'m'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'M'</span>))</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'n'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'N'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>))</span><br><span class="line">        <span class="keyword">return</span> c - <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MAX_LINE];</span><br><span class="line">    <span class="keyword">size_t</span> buffer_used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> writing;</span><br><span class="line">    <span class="keyword">size_t</span> n_written;</span><br><span class="line">    <span class="keyword">size_t</span> write_upto;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_fd_state</span>(<span class="title">void</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">fd_state</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (!state)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    state-&gt;buffer_used = state-&gt;n_written = state-&gt;writing =</span><br><span class="line">        state-&gt;write_upto = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">free_fd_state(struct fd_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">make_nonblocking(<span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_read(<span class="keyword">int</span> fd, struct fd_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">ssize_t</span> result;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        result = recv(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; result; ++i)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (state-&gt;buffer_used &lt; <span class="keyword">sizeof</span>(state-&gt;buffer))</span><br><span class="line">                state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);</span><br><span class="line">            <span class="keyword">if</span> (buf[i] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                state-&gt;writing = <span class="number">1</span>;</span><br><span class="line">                state-&gt;write_upto = state-&gt;buffer_used;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">do_write(<span class="keyword">int</span> fd, struct fd_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (state-&gt;n_written &lt; state-&gt;write_upto) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> result = send(fd, state-&gt;buffer + state-&gt;n_written,</span><br><span class="line">                              state-&gt;write_upto - state-&gt;n_written, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(result != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        state-&gt;n_written += result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;n_written == state-&gt;buffer_used)</span><br><span class="line">        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    state-&gt;writing = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">run(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> listener;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span>[<span class="title">FD_SETSIZE</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, maxfd;</span><br><span class="line">    fd_set readset, writeset, exset;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">40713</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FD_SETSIZE; ++i)</span><br><span class="line">        state[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    make_nonblocking(listener);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <span class="keyword">sizeof</span>(one));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listener, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listener, <span class="number">16</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;readset);</span><br><span class="line">    FD_ZERO(&amp;writeset);</span><br><span class="line">    FD_ZERO(&amp;exset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        maxfd = listener;</span><br><span class="line"></span><br><span class="line">        FD_ZERO(&amp;readset);</span><br><span class="line">        FD_ZERO(&amp;writeset);</span><br><span class="line">        FD_ZERO(&amp;exset);</span><br><span class="line"></span><br><span class="line">        FD_SET(listener, &amp;readset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; FD_SETSIZE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; maxfd)</span><br><span class="line">                    maxfd = i;</span><br><span class="line">                FD_SET(i, &amp;readset);</span><br><span class="line">                <span class="keyword">if</span> (state[i]-&gt;writing) &#123;</span><br><span class="line">                    FD_SET(i, &amp;writeset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (select(maxfd+<span class="number">1</span>, &amp;readset, &amp;writeset, &amp;exset, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">"select"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listener, &amp;readset)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">            <span class="keyword">int</span> fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);</span><br><span class="line">            <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"accept"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &gt; FD_SETSIZE) &#123;</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                make_nonblocking(fd);</span><br><span class="line">                state[fd] = alloc_fd_state();</span><br><span class="line">                assert(state[fd]);<span class="comment">/*XXX*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; maxfd+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == listener)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(i, &amp;readset)) &#123;</span><br><span class="line">                r = do_read(i, state[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; FD_ISSET(i, &amp;writeset)) &#123;</span><br><span class="line">                r = do_write(i, state[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                free_fd_state(state[i]);</span><br><span class="line">                state[i] = <span class="literal">NULL</span>;</span><br><span class="line">                close(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-low-level-ROT13-server-with-Libevent"><a href="#A-low-level-ROT13-server-with-Libevent" class="headerlink" title="A low-level ROT13 server with Libevent"></a>A low-level ROT13 server with Libevent</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For fcntl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span></span><br><span class="line">rot13_char(<span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We don't want to use isalpha here; setting the locale would change</span></span><br><span class="line"><span class="comment">     * which characters are considered alphabetical. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'m'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'M'</span>))</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'n'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'N'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>))</span><br><span class="line">        <span class="keyword">return</span> c - <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> buffer[MAX_LINE];</span><br><span class="line">    <span class="keyword">size_t</span> buffer_used;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> n_written;</span><br><span class="line">    <span class="keyword">size_t</span> write_upto;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">read_event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">write_event</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_fd_state</span>(<span class="title">struct</span> <span class="title">event_base</span> *<span class="title">base</span>, <span class="title">evutil_socket_t</span> <span class="title">fd</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">fd_state</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (!state)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    state-&gt;read_event = event_new(base, fd, EV_READ|EV_PERSIST, do_read, state);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;read_event) &#123;</span><br><span class="line">        <span class="built_in">free</span>(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;write_event =</span><br><span class="line">        event_new(base, fd, EV_WRITE|EV_PERSIST, do_write, state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;write_event) &#123;</span><br><span class="line">        event_free(state-&gt;read_event);</span><br><span class="line">        <span class="built_in">free</span>(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;buffer_used = state-&gt;n_written = state-&gt;write_upto = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    assert(state-&gt;write_event);</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">free_fd_state(struct fd_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    event_free(state-&gt;read_event);</span><br><span class="line">    event_free(state-&gt;write_event);</span><br><span class="line">    <span class="built_in">free</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">do_read(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> = <span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">ssize_t</span> result;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        assert(state-&gt;write_event);</span><br><span class="line">        result = recv(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; result; ++i)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (state-&gt;buffer_used &lt; <span class="keyword">sizeof</span>(state-&gt;buffer))</span><br><span class="line">                state-&gt;buffer[state-&gt;buffer_used++] = rot13_char(buf[i]);</span><br><span class="line">            <span class="keyword">if</span> (buf[i] == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                assert(state-&gt;write_event);</span><br><span class="line">                event_add(state-&gt;write_event, <span class="literal">NULL</span>);</span><br><span class="line">                state-&gt;write_upto = state-&gt;buffer_used;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        free_fd_state(state);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) <span class="comment">// XXXX use evutil macro</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        perror(<span class="string">"recv"</span>);</span><br><span class="line">        free_fd_state(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">do_write(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd_state</span> *<span class="title">state</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (state-&gt;n_written &lt; state-&gt;write_upto) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> result = send(fd, state-&gt;buffer + state-&gt;n_written,</span><br><span class="line">                              state-&gt;write_upto - state-&gt;n_written, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) <span class="comment">// XXX use evutil macro</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            free_fd_state(state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(result != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        state-&gt;n_written += result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;n_written == state-&gt;buffer_used)</span><br><span class="line">        state-&gt;n_written = state-&gt;write_upto = state-&gt;buffer_used = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    event_del(state-&gt;write_event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">do_accept(<span class="keyword">evutil_socket_t</span> listener, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">arg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">    <span class="keyword">int</span> fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123; <span class="comment">// XXXX eagain??</span></span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &gt; FD_SETSIZE) &#123;</span><br><span class="line">        close(fd); <span class="comment">// XXX replace all closes with EVUTIL_CLOSESOCKET */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        struct fd_state *state;</span><br><span class="line">        evutil_make_socket_nonblocking(fd);</span><br><span class="line">        state = alloc_fd_state(base, fd);</span><br><span class="line">        assert(state); <span class="comment">/*XXX err*/</span></span><br><span class="line">        assert(state-&gt;write_event);</span><br><span class="line">        event_add(state-&gt;read_event, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">run(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">evutil_socket_t</span> listener;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">listener_event</span>;</span></span><br><span class="line"></span><br><span class="line">    base = event_base_new();</span><br><span class="line">    <span class="keyword">if</span> (!base)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/*XXXerr*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">40713</span>);</span><br><span class="line"></span><br><span class="line">    listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    evutil_make_socket_nonblocking(listener);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <span class="keyword">sizeof</span>(one));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listener, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listener, <span class="number">16</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (<span class="keyword">void</span>*)base);</span><br><span class="line">    <span class="comment">/*XXX check it */</span></span><br><span class="line">    event_add(listener_event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>simpler:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For sockaddr_in */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For socket functions */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For fcntl */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event2/bufferevent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_read</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_write</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> events, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span></span><br><span class="line">rot13_char(<span class="keyword">char</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We don't want to use isalpha here; setting the locale would change</span></span><br><span class="line"><span class="comment">     * which characters are considered alphabetical. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'m'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'M'</span>))</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((c &gt;= <span class="string">'n'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'N'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>))</span><br><span class="line">        <span class="keyword">return</span> c - <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">readcb(struct bufferevent *bev, <span class="keyword">void</span> *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evbuffer</span> *<span class="title">input</span>, *<span class="title">output</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *line;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    input = bufferevent_get_input(bev);</span><br><span class="line">    output = bufferevent_get_output(bev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((line = evbuffer_readln(input, &amp;n, EVBUFFER_EOL_LF))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            line[i] = rot13_char(line[i]);</span><br><span class="line">        evbuffer_add(output, line, n);</span><br><span class="line">        evbuffer_add(output, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (evbuffer_get_length(input) &gt;= MAX_LINE) &#123;</span><br><span class="line">        <span class="comment">/* Too long; just process what there is and go on so that the buffer</span></span><br><span class="line"><span class="comment">         * doesn't grow infinitely long. */</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> (evbuffer_get_length(input)) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = evbuffer_remove(input, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                buf[i] = rot13_char(buf[i]);</span><br><span class="line">            evbuffer_add(output, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">        evbuffer_add(output, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">errorcb(struct bufferevent *bev, <span class="keyword">short</span> error, <span class="keyword">void</span> *ctx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error &amp; BEV_EVENT_EOF) &#123;</span><br><span class="line">        <span class="comment">/* connection has been closed, do any clean up here */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &amp; BEV_EVENT_ERROR) &#123;</span><br><span class="line">        <span class="comment">/* check errno to see what error occurred */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &amp; BEV_EVENT_TIMEOUT) &#123;</span><br><span class="line">        <span class="comment">/* must be a timeout event handle, handle it */</span></span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    bufferevent_free(bev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">do_accept(<span class="keyword">evutil_socket_t</span> listener, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> = <span class="title">arg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">ss</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> slen = <span class="keyword">sizeof</span>(ss);</span><br><span class="line">    <span class="keyword">int</span> fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fd &gt; FD_SETSIZE) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        struct bufferevent *bev;</span><br><span class="line">        evutil_make_socket_nonblocking(fd);</span><br><span class="line">        bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">        bufferevent_setcb(bev, readcb, <span class="literal">NULL</span>, errorcb, <span class="literal">NULL</span>);</span><br><span class="line">        bufferevent_setwatermark(bev, EV_READ, <span class="number">0</span>, MAX_LINE);</span><br><span class="line">        bufferevent_enable(bev, EV_READ|EV_WRITE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">run(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">evutil_socket_t</span> listener;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">listener_event</span>;</span></span><br><span class="line"></span><br><span class="line">    base = event_base_new();</span><br><span class="line">    <span class="keyword">if</span> (!base)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/*XXXerr*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(<span class="number">40713</span>);</span><br><span class="line"></span><br><span class="line">    listener = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    evutil_make_socket_nonblocking(listener);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WIN32</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line">        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;one, <span class="keyword">sizeof</span>(one));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(listener, (struct sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listener, <span class="number">16</span>)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (<span class="keyword">void</span>*)base);</span><br><span class="line">    <span class="comment">/*XXX check it */</span></span><br><span class="line">    event_add(listener_event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> c, <span class="keyword">char</span> **v)</span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;One Sentence.&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《TCP/IP详解 卷1:协议》读书笔记 12</title>
    <link href="http://ifanze.cn/2018/08/14/%E3%80%8ATCP-IP-%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-12/"/>
    <id>http://ifanze.cn/2018/08/14/《TCP-IP-详解卷1：协议》读书笔记-12/</id>
    <published>2018-08-14T09:42:43.000Z</published>
    <updated>2018-09-01T13:22:17.451Z</updated>
    
    <content type="html"><![CDATA[<p>One Sentence.</p><a id="more"></a><!-- toc --><h1 id="第十二章-TCP：传输控制协议（初步）"><a href="#第十二章-TCP：传输控制协议（初步）" class="headerlink" title="第十二章 TCP：传输控制协议（初步）"></a>第十二章 TCP：传输控制协议（初步）</h1><h2 id="12-1-引言"><a href="#12-1-引言" class="headerlink" title="12.1 引言"></a>12.1 引言</h2><ul><li><p>通信媒介可能会丢失或改变被传递的消息。——信息理论（information theory）&amp; 编码理论（coding theory）</p></li><li><p>如何使信息在通信信道中避免出错：</p><ul><li>使用差错校正码（某些比特的冗余）。</li><li>尝试重新发送（自动重复请求，Automatic Repeat Request，ARQ）。</li></ul></li></ul><h3 id="12-1-1-ARQ-和-重传"><a href="#12-1-1-ARQ-和-重传" class="headerlink" title="12.1.1 ARQ 和 重传"></a>12.1.1 ARQ 和 重传</h3><ul><li><p>如果不只考虑单个通信信道，而是几个的多跳级联。除了分组比特差错，还会有以下问题：</p><ul><li>分组重新排序。</li><li>分组复制。</li><li>分子泯灭。</li></ul></li><li><p>使用重发需要判断：</p><ul><li>接收方是否已收到分组。</li><li>接收方接收到的分组是否与发送的一样。</li></ul></li><li><p>使用 ACK：</p><ul><li>发送方对一个 ACK 应等待多久。 <em>（14章讨论）</em></li><li>如果 ACK 丢失了怎么办。 <em>（处理后续接收到的拷贝）</em></li><li>分组收到了，但里面有错怎么办。（不发送 ACK）</li><li>接收到重复的拷贝。（使用序列号）</li></ul></li><li><p>允许多个分组进入网络来提高吞吐量：引出窗口的概念。</p></li></ul><h3 id="12-1-2-分组窗口和滑动窗口"><a href="#12-1-2-分组窗口和滑动窗口" class="headerlink" title="12.1.2 分组窗口和滑动窗口"></a>12.1.2 分组窗口和滑动窗口</h3><ul><li><strong>分组窗口</strong>：已被发送方注入但还没完成确认的分组的集合。</li><li><strong>窗口大小</strong>：窗口中的分组数量。</li><li><strong>滑动窗口（sliding window）协议</strong>。</li><li>对发送方：哪些分组可被释放，哪些正在等待确认，哪些还不能发送。</li><li>对接收方：哪些分组已被接收和确认，哪些是下一步期望的，哪些即使被接收也因限制而被丢弃。</li></ul><h3 id="12-1-3-变量窗口：流量控制和拥塞控制"><a href="#12-1-3-变量窗口：流量控制和拥塞控制" class="headerlink" title="12.1.3 变量窗口：流量控制和拥塞控制"></a>12.1.3 变量窗口：流量控制和拥塞控制</h3><ul><li><strong>流量控制（flow control）</strong>：接收方跟不上速度时强迫发送方慢下来。</li><li><p>两种方式：</p><ul><li>基于速率（rate-based）：适合流应用程序，可被用于广播和组播发现。</li><li><p>基于窗口（window-based）：窗口大小随时间变化。</p></li><li><p>让接收方可以通知发送方使用多大的窗口，即窗口通告（window advertisement）或窗口更新（window update），一般和 ACK 是同一个分组携带的。</p></li></ul></li><li><p><strong>拥塞控制（congestion control）</strong>：中间网络出现瓶颈，而非接收方。</p><ul><li>明确（explicit）发信：使用窗口通告。</li><li>隐形（implicit）发信：根据其他某些证据来决定放慢速度。</li></ul></li></ul><h3 id="12-1-4-设置重传超时"><a href="#12-1-4-设置重传超时" class="headerlink" title="12.1.4 设置重传超时"></a>12.1.4 设置重传超时</h3><ul><li><p>让协议实现尝试去估计，称之为往返时间估计（round-trip-time estimation）。</p></li><li><p>选用一组 RTT 样本的均值，实际依然可能超过该值。</p></li></ul><h2 id="12-2-TCP-的引入"><a href="#12-2-TCP-的引入" class="headerlink" title="12.2 TCP 的引入"></a>12.2 TCP 的引入</h2><h3 id="12-2-1-TCP-服务模型"><a href="#12-2-1-TCP-服务模型" class="headerlink" title="12.2.1 TCP 服务模型"></a>12.2.1 TCP 服务模型</h3><ul><li><p>TCP 提供了一种面向连接的（connection-oriented）、可靠的字节流服务。</p><ul><li>面向连接：交换数据前先建立连接。</li><li>字节流：没有由 TCP 自动插入的记录标志或消息边界。每个端点独立选择自己的读和写大小。</li></ul></li></ul><h3 id="12-2-2-TCP-中的可靠性"><a href="#12-2-2-TCP-中的可靠性" class="headerlink" title="12.2.2 TCP 中的可靠性"></a>12.2.2 TCP 中的可靠性</h3><ul><li>组包（packetization）：TCP 提供一个字节流接口，将一个发送应用程序的字节流转换成一组 IP 可以携带的分组。</li><li>分组的序列号：分组第一个字节在整个数据流中的字节偏移，而不是分组号。这允许分组在传送中是可变大小的，允许重新组包（repacketization）。</li><li>应用程序数据被打散成 TCP 认为的最佳大小的块来发送，一般使得每个报文段（由 TCP 传给 IP 的块，segment）按照不会被分片的单个 IP 层数据报的大小来划分。这和 UDP 每次写入整个数据不同。</li><li>TCP 根据校验和检测比特差错，如果报文段无效，会被直接丢弃。该校验可能不够强壮，应用程序应有自己的差错保护方法，或者使用一种中间层来达到同样的效果。</li><li>TCP 接收端可能对一个之前已经确认的报文段进行确认，以帮助发送方计算拥塞控制。</li><li>TCP 为发送的报文段设置重传计时器，实现自适应超时和重传策略。</li><li>ACK 的发送是累积的，收到字节号 N 的 ACK 暗示 N 之前（不包括 N）的字节都已经成功被接收了。</li><li>TCP 提供双工服务，数据可以在两个方向上平等地流动。每个端点都要为每个方向维持一个序列号、发送 ACK、实现流量控制。</li><li>TCP 会丢弃重复的报文段，记录乱序的报文段，保证不以杂乱的顺序交给应用程序数据。</li></ul><h2 id="12-3-TCP-头部和封装"><a href="#12-3-TCP-头部和封装" class="headerlink" title="12.3 TCP 头部和封装"></a>12.3 TCP 头部和封装</h2><p><img src="http://static.ifanze.cn/workflow-IMG_0107.jpeg" alt=""></p><p><img src="http://static.ifanze.cn/workflow-IMG_0108.jpeg" alt=""></p><ul><li>TCP 头部的长度：20字节（无选项）～60字节。</li><li>端口号：和 IP 地址组成套接字（socket）或称端点（endpoint）。每个TCP连接由一对套接字唯一地标识。</li><li>序列号：标识了发送端到接收端代表着包含该序列号的报文段的数据中的第一个字节。到达 2^32-1 后再循环到 0。</li><li><p>确认号（ACK）：期待接收的下一个序列号。这个字段只有在 ACK 位被启用的情况下生效。通常会一直使用。</p><ul><li>虽然如此，现代 TCP 有一个选择确认（Selective ACKnowledgment，SACK）选项，允许告之发送方接收到了次序杂乱的数据。如果发送方支持选择重发（selective repeat），性能可得到明显改善。</li></ul></li><li><p>SYN 位：客户端向服务器建立新连接发送第一个报文段时被启用。此时序列号字段包含了本次连接的这个方向上要使用的初始序列号（Initial Sequence Number，ISN，出于安全考虑，一般不从 0 或 1 开始）。</p></li><li>头部长度：4位，20～60。</li><li><p>8位的选项：一些老的实现只理解后6位。</p><ul><li>CWR：拥塞窗口减（发送方降低发送速率）。</li><li>ECE：ECN 回显（发送方接收到一个更早的拥塞通告）。</li><li>URG：紧急（紧急指针字段有效，很少使用）。</li><li>ACK：确认。</li><li>PSH：推送（接收方应尽快给应用程序传送这个数据：没被可靠的实现或用到）。</li><li>RST：重置连接（连接取消，常因为错误）。</li><li>SYN：初始化序列号。</li><li>FIN：结束发送数据。</li></ul></li><li><p>窗口大小：16字节，最大 65535，但可利用窗口缩放选项进行扩大。实现流量控制，是一个字节数。</p></li><li>TCP 校验和。</li><li>紧急指针（Urgent Pointer）：一个必须要加到序列号字段上的正偏移，以产生紧急数据的最后一个字节的序列号。是一种发送方给接收方提供特殊标志数据的方法。</li><li>最大段大小（MSS）：指定发送方在相反方向上希望接收到的报文段的最大值。</li><li>数据部分是可选的。</li></ul><p>￼<br>￼</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;One Sentence.&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>《TCP/IP详解 卷1:协议》读书笔记 3</title>
    <link href="http://ifanze.cn/2018/08/07/%E3%80%8ATCP-IP-%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/"/>
    <id>http://ifanze.cn/2018/08/07/《TCP-IP-详解卷1：协议》读书笔记-3/</id>
    <published>2018-08-07T09:42:43.000Z</published>
    <updated>2018-09-01T13:22:17.451Z</updated>
    
    <content type="html"><![CDATA[<p>One Sentence.</p><a id="more"></a><!-- toc --><h1 id="第三章-链路层"><a href="#第三章-链路层" class="headerlink" title="第三章 链路层"></a>第三章 链路层</h1><h2 id="3-1-引言"><a href="#3-1-引言" class="headerlink" title="3.1 引言"></a>3.1 引言</h2><ul><li>设计链路层的目的是为 IP 模块发送和接收 IP 数据报，可用于携带一些支持 IP 的辅助性协议，如 ARP。</li><li><p>TCP/IP 支持多种链路层，依赖于网络硬件类型：</p><ul><li>有线局域网，如以太网。</li><li>城域网（MAN），如服务供应商提供的有线电视和 DSL 连接。</li><li>有线语音网络，如支持调制解调器的电话线。</li><li>无线网络，如 Wi-Fi（无线局域网）。</li><li>基于蜂窝技术的各种无线数据服务，如 HSPA、EV-DO、LTE、WiMAX。</li></ul></li><li><p>本章将讨论点到点协议（PPP）、如何在其他协议中携带链路层协议、隧道技术。</p></li><li><p>链路层的 PDU 通常称为：帧。</p></li><li>帧通常支持可变的帧长度，范围从几字节到几千字节。该上限称为最大传输单元（MTU）。</li></ul><h2 id="3-2-以太网和-IEEE-802-局域网-城域网标准"><a href="#3-2-以太网和-IEEE-802-局域网-城域网标准" class="headerlink" title="3.2 以太网和 IEEE 802 局域网/城域网标准"></a>3.2 以太网和 IEEE 802 局域网/城域网标准</h2><h3 id="3-2-1-IEEE-802-局域网-城域网标准"><a href="#3-2-1-IEEE-802-局域网-城域网标准" class="headerlink" title="3.2.1 IEEE 802 局域网/城域网标准"></a>3.2.1 IEEE 802 局域网/城域网标准</h3><ul><li><p>介质访问控制（MAC）协议：</p><ul><li>基于每个站尝试独立使用网络。如CSMA/CD：带冲突（或碰撞）检测的载波侦听多路访问。使得在给定时间内，基于竞争的，网络中只有一个帧传输。</li><li>基于预先安排的协调。如依据为每个站分配的时段发送。</li></ul></li><li><p>共享电缆 -&gt; 双绞线（10BASE-T） -&gt; 快速以太网（100BASE-TX，100Mb/s） -&gt; 以太网交换机。</p></li><li><p>以太网标准：802.3。</p></li><li>Wi-Fi 标准：802.11（帧格式和通用接口大部分来自 802.3）。</li></ul><h3 id="3-2-2-以太网帧格式"><a href="#3-2-2-以太网帧格式" class="headerlink" title="3.2.2 以太网帧格式"></a>3.2.2 以太网帧格式</h3><p><img src="http://static.ifanze.cn/Annotation.png" alt=""></p><ul><li><p>前导字段和帧起始分隔符（SFD）：用于接收器同步。</p><ul><li>前导典型值：0xAA。</li><li>SFD典型值：0xAB。</li></ul></li><li><p>目的地址（DST）和源地址（SRC）：各 6 字节，又称 MAC地址、链路层地址、802地址、硬件地址、物理地址。允许广播（ARP协议）或组播（ICMPv6协议）</p></li><li><p>类型或长度字段：大于等于1536表示类型，小于等于1500表示长度。常见值：</p><ul><li>IPv4：0x0800。</li><li>IPv6：0x86DD。</li><li>ARP：0x0806。</li><li>Q标签帧：0x8100。</li></ul></li><li><p>标签：常见的是由 802.1p 和 802.1q 使用的，提供虚拟局域网（VLAN）和一些服务质量（QoS）指示符。</p><ul><li>信封帧：802.3 帧格式提供最大为 482 字节的标签，这些较大的帧称为信封帧。</li><li>Q标签帧也是信封帧。</li></ul></li><li><p>数据区（有效载荷）：放置上层 PDU，最大为 1500 字节（MTU），有时会填充 0 来满足最小长度要求。</p></li><li><p>循环冗余校验（CRC）字段或帧校验序列（FCS）字段中：32位。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;One Sentence.&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>GTest 技术调研</title>
    <link href="http://ifanze.cn/2018/08/06/GTest%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94/"/>
    <id>http://ifanze.cn/2018/08/06/GTest技术调研/</id>
    <published>2018-08-06T06:51:23.000Z</published>
    <updated>2019-02-10T07:49:26.568Z</updated>
    
    <content type="html"><![CDATA[<p>对 GoogleTest（<a href="https://github.com/google/googletest）的技术调研。">https://github.com/google/googletest）的技术调研。</a></p><a id="more"></a><!-- toc --><ol><li><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1></li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/google/googletest.git</span><br><span class="line">cd googletest/googletest</span><br><span class="line">mkdir mybuild</span><br><span class="line">cd mybuild</span><br><span class="line">cmake -Dgtest_build_samples=ON ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><ul><li><code>-DGTEST_USE_OWN_TR1_TUPLE=1</code>。使用自带的 TR1 Tuple。若使用自己工程的 TR1 Tuple library，须有<code>-DGTEST_USE_OWN_TR1_TUPLE=0</code>。</li><li><code>-DGTEST_HAS_TR1_TUPLE=0</code>。禁用使用了 TR1 Tuple 的特性。</li></ul><blockquote><p>Some Google Test features require the C++ Technical Report 1 (TR1) tuple library, which is not yet available with all compilers. </p></blockquote><ul><li><code>-DGTEST_HAS_PTHREAD=1</code>。当<code>pthread</code>启用时，GTest 是线程安全的。在<code>#include &quot;gtest/gtest.h&quot;</code>之后检查<code>GTEST_IS_THREADSAFE</code>宏可以判断是否是线程安全的。如果判断不准确，可定义该宏强制启用<code>pthread</code>。</li><li><code>-DGTEST_CREATE_SHARED_LIBRARY=1</code>。若需要生成动态链接库，添加此选项。</li><li><code>-DGTEST_LINKED_AS_SHARED_LIBRARY=1</code>。若要使用动态库编译自己的测试代码，添加此选项。</li><li><code>-DGTEST_DONT_DEFINE_XXXXX=1</code>。为防止与已有宏冲突，将 GTest 中的宏<code>XXXXX</code>改为<code>GTEST_XXXXX</code>。</li></ul><ol><li><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1></li></ol><h2 id="Sample-1-测试函数"><a href="#Sample-1-测试函数" class="headerlink" title="Sample 1: 测试函数"></a>Sample 1: 测试函数</h2><ul><li>Step #1: 包含头文件。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sample1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gtest/gtest.h"</span></span></span><br></pre></td></tr></table></figure><ul><li><p>Step #2: 定义测试。</p><ul><li>两个参数：测试用例名 test case name、测试名 test name。</li><li>必须是合法 C++ 标识符，不能有下划线<code>_</code>。</li><li>多个 logically related 的测试组成一个测试用例。</li><li>使用在<code>gtest.h</code>中定义的宏来写测试。</li><li>GTest 保证每个测试做且只做一次，但不保证测试顺序。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tests Factorial().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of negative numbers.</span></span><br><span class="line">TEST(FactorialTest, Negative) &#123;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-5</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-1</span>));</span><br><span class="line">  EXPECT_GT(Factorial(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of 0.</span></span><br><span class="line">TEST(FactorialTest, Zero) &#123;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line">TEST(FactorialTest, Positive) &#123;</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">1</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">2</span>, Factorial(<span class="number">2</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">6</span>, Factorial(<span class="number">3</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">40320</span>, Factorial(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Step #3：在<code>main()</code>中调用<code>RUN_ALL_TESTS()</code>（甚至不需要注册这些测试），成功则返回 0。</li></ul><h2 id="Sample-2-测试类"><a href="#Sample-2-测试类" class="headerlink" title="Sample 2: 测试类"></a>Sample 2: 测试类</h2><ul><li>一般会为每个类中的方法定义一个测试用例。（当然可按需决定）</li><li>使用<code>EXPECT_EQ</code>比较指针和<code>NULL</code>会触发编译器警告。</li></ul><h2 id="Sample-3-使用-test-fixture"><a href="#Sample-3-使用-test-fixture" class="headerlink" title="Sample 3: 使用 test fixture"></a>Sample 3: 使用 test fixture</h2><ul><li>text fixture 是用于保存多个测试间共享的对象和方法。</li><li>为了让每个测试 independent and repeatable，每个测试用例分别有这些共享对象的一个拷贝，不会相互影响。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To use a test fixture, derive a class from testing::Test.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTestSmpl3</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:  <span class="comment">// You should make the members protected s.t. they can be</span></span><br><span class="line">             <span class="comment">// accessed from sub-classes.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtual void SetUp() will be called before each test is run.  You</span></span><br><span class="line">  <span class="comment">// should define it if you need to initialize the variables.</span></span><br><span class="line">  <span class="comment">// Otherwise, this can be skipped.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q1_.Enqueue(<span class="number">1</span>);</span><br><span class="line">    q2_.Enqueue(<span class="number">2</span>);</span><br><span class="line">    q2_.Enqueue(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtual void TearDown() will be called after each test is run.</span></span><br><span class="line">  <span class="comment">// You should define it if there is cleanup work to do.  Otherwise,</span></span><br><span class="line">  <span class="comment">// you don't have to provide it.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// virtual void TearDown() &#123;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Other helper functions.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declares the variables your tests want to use.</span></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// When you have a test fixture, you define a test using TEST_F</span></span><br><span class="line"><span class="comment">// instead of TEST.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the default c'tor.</span></span><br><span class="line">TEST_F(QueueTestSmpl3, DefaultConstructor) &#123;</span><br><span class="line">  <span class="comment">// You can access data in the test fixture here.</span></span><br><span class="line">  EXPECT_EQ(<span class="number">0u</span>, q0_.Size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Dequeue().</span></span><br><span class="line">TEST_F(QueueTestSmpl3, Dequeue) &#123;</span><br><span class="line">  <span class="keyword">int</span> * n = q0_.Dequeue();</span><br><span class="line">  EXPECT_TRUE(n == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  n = q1_.Dequeue();</span><br><span class="line">  ASSERT_TRUE(n != <span class="literal">NULL</span>);</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, *n);</span><br><span class="line">  EXPECT_EQ(<span class="number">0u</span>, q1_.Size());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line"></span><br><span class="line">  n = q2_.Dequeue();</span><br><span class="line">  ASSERT_TRUE(n != <span class="literal">NULL</span>);</span><br><span class="line">  EXPECT_EQ(<span class="number">2</span>, *n);</span><br><span class="line">  EXPECT_EQ(<span class="number">1u</span>, q2_.Size());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the Queue::Map() function.</span></span><br><span class="line">TEST_F(QueueTestSmpl3, Map) &#123;</span><br><span class="line">  MapTester(&amp;q0_);</span><br><span class="line">  MapTester(&amp;q1_);</span><br><span class="line">  MapTester(&amp;q2_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sample-4-利用继承在多个用例中复用-test-fixture"><a href="#Sample-4-利用继承在多个用例中复用-test-fixture" class="headerlink" title="Sample 4: 利用继承在多个用例中复用 test fixture"></a>Sample 4: 利用继承在多个用例中复用 test fixture</h2><p>如要求让所有测试在 5s 内完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickTest</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Remember that SetUp() is run immediately before a test starts.</span></span><br><span class="line">  <span class="comment">// This is a good place to record the start time.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start_time_ = time(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TearDown() is invoked immediately after a test finishes.  Here we</span></span><br><span class="line">  <span class="comment">// check if the test was too slow.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Gets the time when the test finishes</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">time_t</span> end_time = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Asserts that the test took no more than ~5 seconds.  Did you</span></span><br><span class="line">    <span class="comment">// know that you can use assertions in SetUp() and TearDown() as</span></span><br><span class="line">    <span class="comment">// well?</span></span><br><span class="line">    EXPECT_TRUE(end_time - start_time_ &lt;= <span class="number">5</span>) &lt;&lt; <span class="string">"The test took too long."</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The UTC time (in seconds) when the test starts</span></span><br><span class="line">  <span class="keyword">time_t</span> start_time_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive a fixture named IntegerFunctionTest from the QuickTest</span></span><br><span class="line"><span class="comment">// fixture.  All tests using this fixture will be automatically</span></span><br><span class="line"><span class="comment">// required to be quick.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFunctionTest</span> :</span> <span class="keyword">public</span> QuickTest &#123;</span><br><span class="line">  <span class="comment">// We don't need any more logic than already in the QuickTest fixture.</span></span><br><span class="line">  <span class="comment">// Therefore the body is empty.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Factorial()</span></span><br><span class="line">TEST_F(IntegerFunctionTest, Factorial) &#123;</span><br><span class="line">  <span class="comment">// Tests factorial of negative numbers.</span></span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-5</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">-1</span>));</span><br><span class="line">  EXPECT_GT(Factorial(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tests factorial of 0.</span></span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, Factorial(<span class="number">1</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">2</span>, Factorial(<span class="number">2</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">6</span>, Factorial(<span class="number">3</span>));</span><br><span class="line">  EXPECT_EQ(<span class="number">40320</span>, Factorial(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The next test case (named "QueueTest") also needs to be quick, so</span></span><br><span class="line"><span class="comment">// we derive another fixture from QuickTest.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The QueueTest test fixture has some logic and shared objects in</span></span><br><span class="line"><span class="comment">// addition to what's in QuickTest already.  We define the additional</span></span><br><span class="line"><span class="comment">// stuff inside the body of the test fixture, as usual.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> :</span> <span class="keyword">public</span> QuickTest &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First, we need to set up the super fixture (QuickTest).</span></span><br><span class="line">    QuickTest::SetUp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second, some additional setup for this fixture.</span></span><br><span class="line">    q1_.Enqueue(<span class="number">1</span>);</span><br><span class="line">    q2_.Enqueue(<span class="number">2</span>);</span><br><span class="line">    q2_.Enqueue(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// By default, TearDown() inherits the behavior of</span></span><br><span class="line">  <span class="comment">// QuickTest::TearDown().  As we have no additional cleaning work</span></span><br><span class="line">  <span class="comment">// for QueueTest, we omit it here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// virtual void TearDown() &#123;</span></span><br><span class="line">  <span class="comment">//   QuickTest::TearDown();</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the default constructor.</span></span><br><span class="line">TEST_F(QueueTest, DefaultConstructor) &#123;</span><br><span class="line">  EXPECT_EQ(<span class="number">0u</span>, q0_.Size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Dequeue().</span></span><br><span class="line">TEST_F(QueueTest, Dequeue) &#123;</span><br><span class="line">  <span class="keyword">int</span>* n = q0_.Dequeue();</span><br><span class="line">  EXPECT_TRUE(n == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  n = q1_.Dequeue();</span><br><span class="line">  EXPECT_TRUE(n != <span class="literal">NULL</span>);</span><br><span class="line">  EXPECT_EQ(<span class="number">1</span>, *n);</span><br><span class="line">  EXPECT_EQ(<span class="number">0u</span>, q1_.Size());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line"></span><br><span class="line">  n = q2_.Dequeue();</span><br><span class="line">  EXPECT_TRUE(n != <span class="literal">NULL</span>);</span><br><span class="line">  EXPECT_EQ(<span class="number">2</span>, *n);</span><br><span class="line">  EXPECT_EQ(<span class="number">1u</span>, q2_.Size());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sample-5"><a href="#Sample-5" class="headerlink" title="Sample 5:"></a>Sample 5:</h3><h3 id="Sample-6-利用模板进行接口测试"><a href="#Sample-6-利用模板进行接口测试" class="headerlink" title="Sample 6: 利用模板进行接口测试"></a>Sample 6: 利用模板进行接口测试</h3><p>两种方式：</p><ul><li>“typed tests”：知道所有的要测试的派生类。</li><li>“type-parameterized tests”：</li></ul><h3 id="Sample-7-testing-TestWithParam"><a href="#Sample-7-testing-TestWithParam" class="headerlink" title="Sample 7: ::testing::TestWithParam"></a>Sample 7: <code>::testing::TestWithParam</code></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对 GoogleTest（&lt;a href=&quot;https://github.com/google/googletest）的技术调研。&quot;&gt;https://github.com/google/googletest）的技术调研。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="gtest" scheme="http://ifanze.cn/tags/gtest/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode解题记录</title>
    <link href="http://ifanze.cn/2018/07/20/LeetCode%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://ifanze.cn/2018/07/20/LeetCode解题记录/</id>
    <published>2018-07-20T09:30:23.000Z</published>
    <updated>2018-09-01T13:32:16.393Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode上做过的题。</p><a id="more"></a><!-- toc --><blockquote><p>题库：<a href="https://github.com/liuyubobobo/Play-with-Algorithm-Interview">https://github.com/liuyubobobo/Play-with-Algorithm-Interview</a></p></blockquote><h2 id="Coding-Tips"><a href="#Coding-Tips" class="headerlink" title="Coding Tips"></a>Coding Tips</h2><ul><li><code>stringstream</code>可以用<code>eof()</code>判断是否读到了结尾，但不包括尾部空格。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>722.</p><p>792.</p><p>796.</p><p>736.</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol><li><p>Single Number</p><ul><li><a href="https://leetcode.com/submissions/detail/164809954/">https://leetcode.com/submissions/detail/164809954/</a></li></ul></li></ol><p>389.</p><h2 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h2><ol><li><p>Intersection of Two Arrays</p><ul><li><a href="https://leetcode.com/submissions/detail/140140222/">https://leetcode.com/submissions/detail/140140222/</a></li><li><a href="https://leetcode.com/submissions/detail/140140384/">https://leetcode.com/submissions/detail/140140384/</a></li><li><a href="https://leetcode.com/submissions/detail/140141226/">https://leetcode.com/submissions/detail/140141226/</a></li><li><a href="https://leetcode.com/submissions/detail/140141342/">https://leetcode.com/submissions/detail/140141342/</a></li></ul></li><li><p>Intersection of Two Arrays II</p><ul><li><a href="https://leetcode.com/submissions/detail/140141952/">https://leetcode.com/submissions/detail/140141952/</a></li></ul></li><li><p>Valid Anagram</p><ul><li><a href="https://leetcode.com/submissions/detail/164812086/">https://leetcode.com/submissions/detail/164812086/</a></li><li><a href="https://leetcode.com/submissions/detail/164812280/">https://leetcode.com/submissions/detail/164812280/</a></li></ul></li><li><p>Happy Number</p><ul><li><a href="https://leetcode.com/submissions/detail/164916918/">https://leetcode.com/submissions/detail/164916918/</a></li></ul></li><li><p>Word Pattern</p><ul><li><a href="https://leetcode.com/submissions/detail/164920615/">https://leetcode.com/submissions/detail/164920615/</a></li></ul></li><li><p>Isomorphic Strings</p><ul><li><a href="https://leetcode.com/submissions/detail/164923185/">https://leetcode.com/submissions/detail/164923185/</a></li></ul></li><li><p><strong>[Medium]</strong> Sort Characters By Frequency</p><ul><li><a href="https://leetcode.com/submissions/detail/164945886/">https://leetcode.com/submissions/detail/164945886/</a></li></ul></li></ol><ol><li><p>Unique Morse Code Words</p><ul><li><a href="https://leetcode.com/submissions/detail/164950488/">https://leetcode.com/submissions/detail/164950488/</a></li></ul></li><li><p>Two Sum</p><ul><li><a href="https://leetcode.com/submissions/detail/59651268/">https://leetcode.com/submissions/detail/59651268/</a></li></ul></li></ol><p>15.</p><p>18.</p><p>16.</p><p>454.</p><p>49.</p><p>697.</p><p>734.</p><p>447.</p><p>149.</p><p>719.</p><p>219.</p><p>217.</p><p>220.</p><p>155.</p><p>716.</p><p>729.</p><p>731.</p><p>855.</p><p>290.</p><p>811.</p><p>819.</p><p>128.</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li><p>Reverse Linked List</p><ul><li><a href="https://leetcode.com/submissions/detail/164962749/">https://leetcode.com/submissions/detail/164962749/</a> （递归）</li><li><a href="https://leetcode.com/submissions/detail/165935527/">https://leetcode.com/submissions/detail/165935527/</a> （非递归）</li></ul></li><li><p><strong>[Medium]</strong> Reverse Linked List II</p><ul><li><a href="https://leetcode.com/submissions/detail/166245169/">https://leetcode.com/submissions/detail/166245169/</a></li></ul></li><li><p>Remove Duplicates from Sorted List</p><ul><li><a href="https://leetcode.com/submissions/detail/166250200/">https://leetcode.com/submissions/detail/166250200/</a></li></ul></li><li><p><strong>[Medium]</strong> Partition List</p><ul><li><a href="https://leetcode.com/submissions/detail/166251746/">https://leetcode.com/submissions/detail/166251746/</a></li></ul></li></ol><p>328.</p><p>2.</p><p>445.</p><p>203.</p><p>82.</p><p>21.</p><p>24.</p><p>25.</p><p>147.</p><p>148.</p><p>237.</p><p>19.</p><p>61.</p><p>143.</p><p>234.</p><p>725.</p><p>817.</p><p>141.</p><p>142.</p><p>287.</p><h2 id="栈、队列、图"><a href="#栈、队列、图" class="headerlink" title="栈、队列、图"></a>栈、队列、图</h2><p>20.</p><p>150.</p><p>71.</p><p>735.</p><p>144.</p><p>94.</p><p>145.</p><p>341.</p><p>388.</p><p>102.</p><p>107.</p><p>103.</p><p>199.</p><p>232.</p><p>637.</p><p>279.</p><p>127.</p><p>126.</p><p>675.</p><p>347.</p><p>23.</p><p>692.</p><p>239.</p><p>786.</p><p>857.</p><p>856.</p><p>490.</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>104.</p><p>111.</p><p>226.</p><p>100.</p><p>101.</p><p>222.</p><p>110.</p><p>112.</p><p>111.</p><p>404.</p><p>257.</p><p>113.</p><p>129.</p><p>250.</p><p>437.</p><p>785.</p><p>783.</p><p>235.</p><p>98.</p><p>450.</p><p>108.</p><p>230.</p><p>236.</p><p>530.</p><p>99.</p><p>109.</p><p>105.</p><p>106.</p><p>173.</p><p>863.</p><p>865.</p><p>87.</p><h2 id="递归、回溯"><a href="#递归、回溯" class="headerlink" title="递归、回溯"></a>递归、回溯</h2><p>17.</p><p>690.</p><p>93.</p><p>131.</p><p>797.</p><p>46.</p><p>47.</p><p>784.</p><p>77.</p><p>39.</p><p>40.</p><p>216.</p><p>78.</p><p>90.</p><p>401.</p><p>254.</p><p>79.</p><p>200.</p><p>130.</p><p>417.</p><p>695.</p><p>694.</p><p>733.</p><p>711.</p><p>51.</p><p>52.</p><p>37.</p><p>390.</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>70.</p><p>120.</p><p>64.</p><p>123.</p><p>309.</p><p>714.</p><p>118.</p><p>343.</p><p>279.</p><p>91.</p><p>62.</p><p>63.</p><p>198.</p><p>213.</p><p>337.</p><p>309.</p><p>740.</p><p>115.</p><p>416.</p><p>322.</p><p>377.</p><p>474.</p><p>139.</p><p>494.</p><p>518.</p><p>805.</p><p>300.</p><p>376.</p><p>673.</p><p>583.</p><p>712.</p><p>718.</p><p>698.</p><p>188.</p><p>790.</p><p>600.</p><p>727.</p><p>741.</p><p>788.</p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>455.</p><p>392.</p><p>561.</p><p>435.</p><p>860.</p><p>861.</p><p>765.</p><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p>386.</p><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>307.</p><p>370.</p><p>218.</p><p>699.</p><p>715.</p><p>308.</p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>208.</p><p>720.</p><p>676.</p><p>677.</p><p>648.</p><p>211.</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>737.</p><p>721.</p><p>684.</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>787.</p><p>685.</p><p>765.</p><p>864.</p><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><p>268.</p><p>382.</p><p>398.</p><p>710.</p><h2 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h2><p>319.</p><p>858.</p><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><p>380.</p><p>381.</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>391.</p><p>780.</p><p>781.</p><p>789.</p><p>795.</p><p>799.</p><p>866.</p><p>732.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode上做过的题。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全2》读书笔记 9</title>
    <link href="http://ifanze.cn/2018/06/28/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(9)/"/>
    <id>http://ifanze.cn/2018/06/28/《代码大全2》(9)/</id>
    <published>2018-06-28T14:12:10.000Z</published>
    <updated>2018-07-08T01:19:50.870Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全2》读书笔记 第九章 伪代码编译过程</p><a id="more"></a><!-- toc --><h1 id="9-伪代码编译过程"><a href="#9-伪代码编译过程" class="headerlink" title="9 伪代码编译过程"></a>9 伪代码编译过程</h1><h2 id="9-1-创建类和子程序的步骤概述"><a href="#9-1-创建类和子程序的步骤概述" class="headerlink" title="9.1 创建类和子程序的步骤概述"></a>9.1 创建类和子程序的步骤概述</h2><h3 id="创建一个类的步骤"><a href="#创建一个类的步骤" class="headerlink" title="创建一个类的步骤"></a>创建一个类的步骤</h3><ul><li><p>创建类的总体设计。包括：</p><ul><li>定义类的职责。</li><li>定义类所要隐藏的秘密。</li><li>精确定义类的接口所代表的抽象概念。</li><li>决定是否从其他类派生而来，以及是否允许其他类再由它派生。</li><li>指出这个类中关键的公用方法，标识并设计出类所需用到的重要数据成员。</li><li>上述任务需迭代多次，直到能直截了当地设计出子程序。</li></ul></li><li><p>创建类中的子程序。</p></li><li>重申并测试整个类。</li></ul><h3 id="创建子程序的步骤"><a href="#创建子程序的步骤" class="headerlink" title="创建子程序的步骤"></a>创建子程序的步骤</h3><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全2》读书笔记 第九章 伪代码编译过程&lt;/p&gt;
    
    </summary>
    
      <category term="《代码大全2》" scheme="http://ifanze.cn/categories/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全2》读书笔记 8</title>
    <link href="http://ifanze.cn/2018/06/28/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(8)/"/>
    <id>http://ifanze.cn/2018/06/28/《代码大全2》(8)/</id>
    <published>2018-06-28T11:50:16.000Z</published>
    <updated>2018-06-27T15:10:14.309Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全2》读书笔记 第八章 防御式编程</p><a id="more"></a><!-- toc --><h1 id="8-防御式编程"><a href="#8-防御式编程" class="headerlink" title="8 防御式编程"></a>8 防御式编程</h1><ul><li>子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。</li></ul><h2 id="8-1-保护程序免遭非法输入数据的破坏"><a href="#8-1-保护程序免遭非法输入数据的破坏" class="headerlink" title="8.1 保护程序免遭非法输入数据的破坏"></a>8.1 保护程序免遭非法输入数据的破坏</h2><ul><li>检查所有来源于外部的数据的值。</li><li>检查子程序所有输入参数的值。</li><li>决定如何处理错误的输入数据。</li></ul><h2 id="8-2-断言（Assertions）"><a href="#8-2-断言（Assertions）" class="headerlink" title="8.2 断言（Assertions）"></a>8.2 断言（Assertions）</h2><ul><li>用错误处理代码来处理预期会发生的状况，用断言来处理绝不应该发生的状况。</li><li>把断言当作可执行的注释。</li><li>避免把需要执行的代码放到断言中。</li><li>用断言来注解并验证前条件和后条件。</li><li>对于高健壮性的代码，应该先使用断言再处理错误。（仅对大型系统而言，一般程序应该使用一种一致的处理方法。）</li></ul><h2 id="8-3-错误处理技术（Error-Handling-Techniques）"><a href="#8-3-错误处理技术（Error-Handling-Techniques）" class="headerlink" title="8.3 错误处理技术（Error-Handling Techniques）"></a>8.3 错误处理技术（Error-Handling Techniques）</h2><ul><li>返回中立值。</li><li>换用下一个正确的数据。</li><li>返回与前次相同的数据。</li><li>换用最接近的合法值。</li><li>记录日志。</li><li>返回一个错误码。</li><li>调用统一的错误处理子程序或对象。（整个程序会与之高耦合）</li><li>当错误发生时显示出错信息。</li><li>用最妥当的方式在局部出错错误。</li><li><p>关闭程序。</p></li><li><p>正确性（correctness）：意味着永不返回不准确的结果，哪怕不返回数据。</p></li><li><p>健壮性（robustness）：意味着不断尝试采取某些措施，以保证软件可以持续地运转下去，哪怕有时做出一些不够准确地结果。</p></li><li><p>确定一种通用的处理错误参数的方法，是架构层次（或称高层次）的设计决策。</p></li></ul><h2 id="8-4-异常（Exceptions）"><a href="#8-4-异常（Exceptions）" class="headerlink" title="8.4 异常（Exceptions）"></a>8.4 异常（Exceptions）</h2><ul><li>用异常通知程序的其他部分，发生了不可忽略的错误。</li><li>只在真正例外的情况下才抛出异常。也就是在其他编码实践方法都无法解决的情况下才使用异常。</li><li>它的应用情形和断言相似：用来处理那些不仅罕见甚至永远不该发生的情况。</li><li>异常的负面：异常弱化了封装性，增加了复杂度。</li><li>不能用异常来推卸责任。</li><li>避免在构造函数或者析构函数抛异常，除非你在同一地方把他们捕获。</li><li>在恰当的抽象层次抛出异常。异常也是程序接口的一部分。（不要抛出更低层的异常，应抛出一个与其所在类的接口相一致的异常。）</li><li>在异常消息中加入关于导致异常发生时的全部信息。（如数组的上下界）</li><li>避免使用空的<code>catch</code>语句。如果确实无法将某较低层次上的异常表现为调用方抽象层次上的异常，在采用空<code>catch</code>的同时也要用注释或日志对其进行文档化说明。</li><li>了解所用函数库可能抛出的异常。</li><li>考虑创建一个集中的异常报告机制。</li><li><p>把项目中对异常的使用标准化。</p><ul><li>抛出哪些异常。</li><li>考虑创建项目的特定异常类。</li><li>规定在何种场合允许代码使用<code>throw-catch</code>在局部进行处理。</li><li>规定何种场合允许代码抛出不在局部处理的异常。</li><li>确定是否要使用集中的异常报告机制。</li><li>规定是否允许在构造函数和析构函数中使用异常。</li></ul></li><li><p>考虑异常的替换方案。</p></li></ul><h2 id="8-5-隔离程序，使之包容由错误造成的损害"><a href="#8-5-隔离程序，使之包容由错误造成的损害" class="headerlink" title="8.5 隔离程序，使之包容由错误造成的损害"></a>8.5 隔离程序，使之包容由错误造成的损害</h2><ul><li>把某些接口选定为“安全”区域的边界，对穿越安全区域边界的数据进行合法性校验，并当数据非法时做出敏锐的反映。</li><li>用于类的层次：公用方法可以假设数据是不安全的，负责检查数据并清理。私用方法就假定数据是安全的了。</li><li>在输入数据时将其转换为恰当的类型。</li><li>隔栏外部使用错误处理技术，隔栏内部使用断言技术。</li></ul><h2 id="8-6-辅助调试的代码"><a href="#8-6-辅助调试的代码" class="headerlink" title="8.6 辅助调试的代码"></a>8.6 辅助调试的代码</h2><h3 id="不要自动地把产品版的限制强加于开发版之上"><a href="#不要自动地把产品版的限制强加于开发版之上" class="headerlink" title="不要自动地把产品版的限制强加于开发版之上"></a>不要自动地把产品版的限制强加于开发版之上</h3><ul><li>开发中的软件允许运行缓慢，可以牺牲一些速度和对资源的使用，来换取一些可以让开发更顺畅的内置工具。</li></ul><h3 id="尽早引入辅助调试的代码"><a href="#尽早引入辅助调试的代码" class="headerlink" title="尽早引入辅助调试的代码"></a>尽早引入辅助调试的代码</h3><h3 id="采用进攻式编程"><a href="#采用进攻式编程" class="headerlink" title="采用进攻式编程"></a>采用进攻式编程</h3><ul><li>确保断言语句使程序终止运行。</li><li>完全填充分配到的所有内存。</li><li>完全填充分配到的所有文件或流。</li><li>确保每一个<code>default</code>或<code>else</code>分支都能产生严重错误，让错误不会被忽视。</li><li>在删除一个对象之前把它填满垃圾数据。</li><li>让程序把它的错误日志用电子邮件发给你。</li></ul><h3 id="计划移除调试辅助的代码"><a href="#计划移除调试辅助的代码" class="headerlink" title="计划移除调试辅助的代码"></a>计划移除调试辅助的代码</h3><ul><li>使用类似<code>ant</code>和<code>make</code>这样的版本控制工具。</li><li>使用内置的预处理器。</li><li>编写你自己的预处理器。</li><li>使用调试存根（debugging stubs）。开发版和发行版使用不同的检查程序。</li></ul><h2 id="8-7-确定在产品代码中该保留多少防御式代码"><a href="#8-7-确定在产品代码中该保留多少防御式代码" class="headerlink" title="8.7 确定在产品代码中该保留多少防御式代码"></a>8.7 确定在产品代码中该保留多少防御式代码</h2><ul><li>保留那些检查重要错误的代码。确定程序的哪些部分可以承担未检测出错误而造成的后果，而哪些不能承担。</li><li>去掉检查细微错误的代码。</li><li>去掉可以导致程序硬性崩溃的代码。</li><li>保留可以让程序稳妥地崩溃的代码。</li><li>为你的技术支持人员记录错误信息。</li><li>确认留在代码中的错误消息是友好的。</li></ul><h2 id="8-8-对防御式编程采取防御的姿态"><a href="#8-8-对防御式编程采取防御的姿态" class="headerlink" title="8.8 对防御式编程采取防御的姿态"></a>8.8 对防御式编程采取防御的姿态</h2><ul><li>过度的防御式编程会使代码臃肿而缓慢。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全2》读书笔记 第八章 防御式编程&lt;/p&gt;
    
    </summary>
    
      <category term="《代码大全2》" scheme="http://ifanze.cn/categories/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》读书笔记 3</title>
    <link href="http://ifanze.cn/2018/06/26/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B(3)/"/>
    <id>http://ifanze.cn/2018/06/26/《深入理解计算机系统》(3)/</id>
    <published>2018-06-26T12:18:17.000Z</published>
    <updated>2018-07-21T15:42:23.498Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》读书笔记 第三章 程序的机器级表示。</p><a id="more"></a><!-- toc --><h1 id="3-程序的机器级结构"><a href="#3-程序的机器级结构" class="headerlink" title="3 程序的机器级结构"></a>3 程序的机器级结构</h1><ul><li><p>通过阅读汇编代码：</p><ul><li>理解编译器的优化能力，并分析代码中隐含的低效率。</li><li>如用线程包写并发程序时，了解不同线程如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据。</li><li>许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。</li></ul></li></ul><h2 id="3-1-历史观点"><a href="#3-1-历史观点" class="headerlink" title="3.1 历史观点"></a>3.1 历史观点</h2><p>Intel处理器俗称x86。主要发展历程：</p><ul><li>8086（1978年）。第一代单芯片，16 位微处理器之一。其变种 8088 构成了最初 IBM 个人计算机的心脏，与微软开发了 MS-DOS 系统。</li><li>80286（1982年）。MS Windows 最初的使用平台。</li><li>i386（1985年）。体系结构扩展到 32 位。Intel 系列中第一台全面支持 Unix 的机器。</li><li>i486（1989年）。改善了性能，集成了浮点单元，但指令级没有明显改变。</li><li>Pentium（1993年）。改善了性能。</li><li>PentiumPro（1995年）。全新的处理器设计，P6 微体系结构。</li><li>Pentium 4E（2004年）。增加了超线程（hyperthreading），使得可以在一个处理器上同时运行两个程序；还增加了 EM64T，是 Intel 对 AMD 提出的对 IA32 的 64 位 扩展的实现，我们称之为 x86-64。</li><li>Core 2（2006年）。回归 P6。Intel 第一个多核微处理器，但不支持超线程。</li><li>Core i7，Nehalem（2008年）。既支持超线程，也有多核。</li><li>Core i7，Sandy Bridge（2011年）。引入了 AVX，这是对 SSE 的扩展，支持把数据封装进 256 位的向量。</li><li>Core i7，Haswell（2013年）。将 AVX 扩展至 AVX2，增加了更多指令和指令格式。</li></ul><p>这些处理器是后向兼容的：较早版本上编译的代码可以在较新的处理器上运行。</p><ul><li>IA32：Intel 32位体系结构（Intel Architecture 32-bit）。</li><li>Intel64：IA32 的 64位扩展，也称为 x86-64。</li><li>x86：指代整个系列。</li></ul><h2 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -0g -o p p1.c p2.c</span><br></pre></td></tr></table></figure><h3 id="3-2-1-机器级编码"><a href="#3-2-1-机器级编码" class="headerlink" title="3.2.1 机器级编码"></a>3.2.1 机器级编码</h3><p>两种抽象：</p><ul><li>指令集体系结构或指令级架构（Instruction Set Architecture, ISA）：定义机器级程序的格式和行为、处理器状态和指令的格式、每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址。</li></ul><p>机器代码的一些在C语言中不可见的状态：</p><ul><li>程序计数器（PC，x86-64中用%rip表示）：下一条指令在内存中的地址。</li><li>整数寄存器文件：包含16个命名的位置。</li><li>条件码寄存器：保存最近执行的算术或逻辑指令的状态信息，实现控制或数据流中的条件变化。</li><li><p>一组向量寄存器：存放一个或多个整数或浮点的值。</p></li><li><p>汇编代码不区分有符号无符号，不区分各种类型的指针，甚至不区分指针和整数。</p></li><li>x86-64 的虚拟地址是由 64 位的字来表示的，在目前的实现中，高 16 位地址必须设置为 0。（64TB）</li></ul><h3 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h3><p>查看编译器产生的汇编代码（生成<code>*.s</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -0g -S *.c</span><br></pre></td></tr></table></figure><p>编译并汇编代码（生成目标文件<code>*.o</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -0g -c *.c</span><br></pre></td></tr></table></figure><p>使用 gdb 展示程序的二进制目标代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 先用反汇编器确定该函数的代码长度是14字节。</span><br><span class="line">(gdb) x/14xb func1</span><br></pre></td></tr></table></figure><p>利用反汇编器查看机器代码内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d mstore.o</span><br></pre></td></tr></table></figure><p>一些关于机器代码和反汇编表示的特性：</p><ul><li>x86-64 的指令长度从 1 到 15 个字节不等。</li><li>设计指令格式的方式：从某个给定位置开始，可以将字节唯一地解码成机器指令。</li><li>反汇编器只基于代码文件中的字节序列来确定汇编代码，不需要访问源代码或汇编代码。</li><li><p>反汇编器使用的指令命名规则和 GCC 生成的汇编代码有些细微差别。如：省略了很多指令结尾的<code>q</code>，也给一些指令添加了<code>q</code>。</p></li><li><p>连接器会为函数调用找到匹配的函数的可执行代码的位置。</p></li><li>机器代码中在函数末尾处会填充字节使函数代码变为16字节，提升存储器系统性能。</li></ul><h3 id="3-2-3-关于格式的注解"><a href="#3-2-3-关于格式的注解" class="headerlink" title="3.2.3 关于格式的注解"></a>3.2.3 关于格式的注解</h3><ul><li><code>.</code>开头的行都是指导汇编器和连接器工作的伪指令。</li><li><p>ATT 汇编代码格式（GCC、Objdump等工具的默认格式）和 Intel 汇编代码格式（Microsft 的工具和 Intel 的文档）的区别：</p><ul><li>Intel 代码省略了指示大小的后缀。如<code>q</code>。</li><li>Intel 代码省略了寄存器名字前面的<code>%</code>。</li><li>Intel 代码用不同的方式来描述内存中的位置。如<code>QWORD PTR [rbx]</code>而不是<code>(%rbx)</code>。</li><li>多个操作数的指令下，列出的操作数顺序相反。</li></ul></li><li><p>C程序中插入汇编代码的方法：</p><ul><li>编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把他们合并。</li><li>用 GCC 的内联汇编（inline assembly）特性，用 asm 伪指令在 C 程序中包含简短的汇编代码。</li></ul></li></ul><h2 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h2><ul><li>字节（byte）：8位。后缀<code>b</code>。</li><li>字（word）：16位。后缀<code>w</code>。</li><li>双字（DWORD）：32位。后缀<code>l</code>。</li><li>四字（QWORD）：64位。后缀<code>q</code>。</li></ul><p><img src="http://static.ifanze.cn/F5590D50-6424-408D-A53E-B7AD2FFAE876.jpeg" alt=""></p><ul><li>单精度浮点：4字节。</li><li>双精度浮点：8字节。</li><li>long double：10字节（不推荐）。</li></ul><h2 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h2><ul><li>8086：8个16位寄存器，从<code>%ax</code>到<code>%bp</code>。</li><li>IA32：8个32位寄存器，从<code>%eax</code>到<code>%ebp</code>。</li><li>x86-64：16个64位寄存器，从<code>%rax</code>到<code>%rbp%</code>，从<code>%r8</code>到<code>%r15</code>。</li></ul><p><img src="http://static.ifanze.cn/DB2A5541-5654-4FA4-B935-CD7FADB6DD4B.jpeg" alt=""></p><ul><li>生成 1 字节和 2 字节数字的指令会保持剩下的字节不变。</li><li>生成 4 字节数字的指令会把高位 4 个字节置为 0。</li></ul><h3 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h3><ul><li>立即数（immediate），ATT 格式中，用<code>$</code>前缀加标准C表示法的整数。</li><li>寄存器（register）。</li><li>内存引用。有四个组成部分：立即数偏移、基址寄存器、变址寄存器、比例因子。</li></ul><p><img src="http://static.ifanze.cn/E5DD9AA6-0E23-4DF6-9C8E-3B7232B4B174.jpeg" alt=""></p><h3 id="3-4-2-数据传送指令"><a href="#3-4-2-数据传送指令" class="headerlink" title="3.4.2 数据传送指令"></a>3.4.2 数据传送指令</h3><h4 id="MOV-指令类"><a href="#MOV-指令类" class="headerlink" title="MOV 指令类"></a><code>MOV</code> 指令类</h4><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOV  S, D</td><td>D &lt;- S</td><td>传送</td></tr><tr><td>movb</td><td></td><td>传送字节</td></tr><tr><td>movw</td><td></td><td>传送字</td></tr><tr><td>movl</td><td></td><td>传送双字</td></tr><tr><td>movq</td><td></td><td>传送四字</td></tr><tr><td>movabsq  I, R</td><td>R &lt;- I</td><td>传送绝对的四字</td></tr></tbody></table><ul><li>源操作数指定的值是一个立即数，存储在寄存器或内存中。</li><li>目的操作数指定一个位置，要么是一个寄存器，要么是一个内存地址。</li><li>x86-64 不允许两个操作数都指向内存地址。</li><li>寄存器部分的大小必须与指令后缀匹配。</li><li><code>movl</code>指令以寄存器作为目标时，会把高 4 位也置为 0。</li><li><code>movq</code>只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64 位的值，放到目的位置。</li><li><code>movabsq</code>能够以任意 64 位立即数作为源操作数，并且只能以寄存器作为目的。</li></ul><h4 id="MOVZ-指令类"><a href="#MOVZ-指令类" class="headerlink" title="MOVZ 指令类"></a><code>MOVZ</code> 指令类</h4><ul><li>将较小的源值复制到较大的目的时，用 0 填充。</li></ul><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOVZ  S, R</td><td>R &lt;- 零扩展(S)</td><td>以零扩展进行传送</td></tr><tr><td>movzbw</td><td></td><td>字节 -&gt; 字</td></tr><tr><td>movzbl</td><td></td><td>字节 -&gt; 双字</td></tr><tr><td>movzwl</td><td></td><td>字   -&gt; 双字</td></tr><tr><td>movzbq</td><td></td><td>字节 -&gt; 四字</td></tr><tr><td>movzwq</td><td></td><td>字   -&gt; 四字</td></tr></tbody></table><h4 id="MOVS-指令类"><a href="#MOVS-指令类" class="headerlink" title="MOVS 指令类"></a><code>MOVS</code> 指令类</h4><ul><li>将较小的源值复制到较大的目的时，用 符号扩展 填充。</li></ul><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOVS  S, R</td><td>R &lt;- 符号扩展(S)</td><td>以零扩展进行传送</td></tr><tr><td>movsbw</td><td></td><td>字节 -&gt; 字</td></tr><tr><td>movsbl</td><td></td><td>字节 -&gt; 双字</td></tr><tr><td>movswl</td><td></td><td>字   -&gt; 双字</td></tr><tr><td>movsbq</td><td></td><td>字节 -&gt; 四字</td></tr><tr><td>movswq</td><td></td><td>字   -&gt; 四字</td></tr><tr><td>movslq</td><td></td><td>双字 -&gt; 四字（<code>movzlq</code> 并不存在，因为用 <code>movl</code> 其实就能实现）</td></tr><tr><td>cltq</td><td>%rax &lt;- 符号扩展(%eax)</td><td>把 %eax 符号扩展到 %rax（即 <code>movslq %eax,%rax</code>）</td></tr></tbody></table><h3 id="3-4-3-数据传送示例"><a href="#3-4-3-数据传送示例" class="headerlink" title="3.4.3 数据传送示例"></a>3.4.3 数据传送示例</h3><ul><li>函数的参数通过寄存器传递给函数。</li><li>函数通过把值存储在寄存器<code>%rax</code>或该寄存器某个低位部分中返回。</li><li>间接引用指针就是将该指针放在一个寄存器中。</li><li>局部变量通常是保存在寄存器中，而不是内存中。</li></ul><h3 id="3-4-4-压入和弹出栈数据"><a href="#3-4-4-压入和弹出栈数据" class="headerlink" title="3.4.4 压入和弹出栈数据"></a>3.4.4 压入和弹出栈数据</h3><ul><li>栈向下增长，栈顶元素的地址是栈中所有元素地址中最低的。</li><li><code>%rsp</code>保存着栈顶元素的地址。</li><li>程序可以用标准的内存寻址方法访问栈内的任意位置。</li></ul><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>pushq  S</td><td>R[%rsp] &lt;- R[%rsp] - 8</td><td>将四字压入栈</td></tr><tr><td></td><td>M[R[%rsp]] &lt;- S</td><td></td></tr><tr><td>popq  D</td><td>D &lt;- M[R[%rsp]]</td><td>将四字弹出栈</td></tr><tr><td></td><td>R[%rsp] &lt;- R[%rsp] + 8</td><td></td></tr></tbody></table><h2 id="3-5-算数和逻辑操作"><a href="#3-5-算数和逻辑操作" class="headerlink" title="3.5 算数和逻辑操作"></a>3.5 算数和逻辑操作</h2><p>四组操作：</p><ul><li><p>加载有效地址：</p><ul><li><code>leaq S,D</code>，效果：<code>D &lt;- &amp;S</code></li></ul></li><li><p>一元操作：</p><ul><li><code>INC D</code>：加 1。</li><li><code>DEC D</code>：减 1。</li><li><code>NEG D</code>：取负。</li><li><code>NOT D</code>：取补。</li></ul></li><li><p>二元操作：</p><ul><li><code>ADD S, D</code>：加。</li><li><code>SUB S, D</code>：减。</li><li><code>IMUL S, D</code>：乘。</li><li><code>XOR S, D</code>：异或。</li><li><code>OR S, D</code>：或。</li><li><code>AND S, D</code>：与。</li></ul></li><li><p>移位：</p><ul><li><code>SAL k, D</code>：左移。</li><li><code>SHL k, D</code>：左移。</li><li><code>SAR k, D</code>：算术右移。</li><li><code>SHR k, D</code>：逻辑右移。</li></ul></li></ul><h3 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h3><ul><li><code>leaq</code>实际上是<code>movq</code>指令的变形。</li><li>形式是从内存读数据到寄存器，但实际上根本没有引用内存，只是将有效地址写入到目的操作数。</li><li>编译器经常发现<code>leaq</code>的一些灵活用法，比如可以简洁地描述普通的算术计算（加法和乘法），根本就与有效地址的计算无关。</li></ul><h3 id="3-5-2-一元和二元操作"><a href="#3-5-2-一元和二元操作" class="headerlink" title="3.5.2 一元和二元操作"></a>3.5.2 一元和二元操作</h3><ul><li>一元操作：既是源又是目的。</li><li>二元操作：第二个操作数既是源又是目的，所以不能是立即数。如果第二个操作数是内存地址，处理器必须从内存读出值，执行操作，再把结果写回内存。</li></ul><h3 id="3-5-3-移位操作"><a href="#3-5-3-移位操作" class="headerlink" title="3.5.3 移位操作"></a>3.5.3 移位操作</h3><ul><li>第一个操作数：移位量。第二个操作数：要移位的数。</li><li>移位量可以是一个立即数，或者放在单字节寄存器<code>%cl</code>中。</li><li><p>移位操作对<code>w</code>位长的数据值进行操作时，移位量是由<code>%cl</code>寄存器的低<code>m</code>位决定的，这里<code>2^m = w</code>。高位被忽略。如<code>%cl</code>为<code>0xFF</code>：</p><ul><li><code>salb</code>移动 7 位。</li><li><code>salw</code>移动 15 位。</li><li><code>sall</code>移动 31 位。</li><li><code>salq</code>移动 63 位。</li></ul></li></ul><h3 id="3-5-4-讨论"><a href="#3-5-4-讨论" class="headerlink" title="3.5.4 讨论"></a>3.5.4 讨论</h3><ul><li>除了右移操作，其他操作都无须区分有符号和无符号数。</li></ul><h3 id="3-5-5-特殊的算术操作"><a href="#3-5-5-特殊的算术操作" class="headerlink" title="3.5.5 特殊的算术操作"></a>3.5.5 特殊的算术操作</h3><ul><li>两个 64 位整数相乘的积需要 128 位来表示。x86-64 指令集对其提供了有限的支持：8字（oct word）。</li></ul><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>imulq  S</td><td>R[%rdx]: R[%rax] &lt;- S*R[%rax]</td><td>有符号全乘法</td></tr><tr><td>mulq   S</td><td>R[%rdx]: R[%rax] &lt;- S*R[%rax]</td><td>无符号全乘法</td></tr><tr><td>clto</td><td>R[%rdx]: R[%rax] &lt;- 符号扩展(R[%rax])</td><td>转换为八字</td></tr><tr><td>idivq  S</td><td>R[%rdx] &lt;- R[%rdx]: R[%rax] mod S</td><td>有符号除法</td></tr><tr><td></td><td>R[%rdx] &lt;- R[%rdx]: R[%rax] / S</td><td></td></tr><tr><td>divq   S</td><td>R[%rdx] &lt;- R[%rdx]: R[%rax] mod S</td><td>无符号除法</td></tr><tr><td></td><td>R[%rdx] &lt;- R[%rdx]: R[%rax] / S</td><td></td></tr></tbody></table><ul><li><p><code>imulq</code>有两种形式：</p><ul><li>双操作数：两数相乘，产生一个64位乘积（截断，无符号乘和补码乘的位级行为是一样的，因此，没有<code>imulq</code>。）。</li><li>单操作数：将<code>%rax</code>与操作数相乘，产生一个128位乘积，高位和低位分别存放在<code>%rdx</code>和<code>%rax</code>中。（<code>mulq</code>同理。）</li></ul></li><li><p>C 标准没有提供128位的值。可以借助 GCC 提供的<code>__int128</code>来声明128位整数。</p></li><li><p>将结果从寄存器取出时，要注意机器的大小端。</p></li><li><p><code>idivq</code>：</p><ul><li>将寄存器<code>%rdx</code>（高64位）和<code>%rax</code>（低64位）中的128位数作为被除数，操作数作为除数，商存放在<code>%rax</code>，余数存放在<code>%rdx</code>。</li><li>除数应该放在<code>%rax</code>中，<code>%rdx</code>的位应该设置为0（无符号运算）或者<code>%rax</code>的符号位（有符号运算），使用<code>cqto</code>指令即可完成这个操作。</li><li><code>divq</code>应该将<code>%rdx</code>事先设定为0。 </li></ul></li></ul><h2 id="3-6-控制"><a href="#3-6-控制" class="headerlink" title="3.6 控制"></a>3.6 控制</h2><h3 id="3-6-1-条件码（condition-code）"><a href="#3-6-1-条件码（condition-code）" class="headerlink" title="3.6.1 条件码（condition code）"></a>3.6.1 条件码（condition code）</h3><p>除了整数寄存器，CPU 还维护着一组单个位的条件码寄存器。常用的条件码有：</p><ul><li><code>CF</code>：进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。</li><li><code>ZF</code>：零标志。最近的操作得出的结果为 0。</li><li><code>SF</code>：符号标志。最近的操作得出的结果为负值。</li><li><code>OF</code>：溢出标志。最近的操作导致一个补码溢出——正溢出或负溢出。</li></ul><p>除了<code>leaq</code>，上面列出的所有指令都会改变条件码。并且：</p><ul><li>对于逻辑操作，如<code>XOR</code>，进位标志和溢出标志会设置成0。</li><li>对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置位0。</li><li><code>INC</code>和<code>DEC</code>指令会设置溢出和零标志，但是不会改变进位标志。</li></ul><p>还有两类指令只设置条件码而不改变任何其他寄存器：</p><table><thead><tr><th>指令</th><th>基于</th><th>描述</th></tr></thead><tbody><tr><td>CMP  S1, S2</td><td>S2 - S1</td><td>比较</td></tr><tr><td> cmpb</td><td></td><td>比较字节</td></tr><tr><td> cmpw</td><td></td><td>比较字</td></tr><tr><td> cmpl</td><td></td><td>比较双字</td></tr><tr><td> cmpq</td><td></td><td>比较四字</td></tr><tr><td>TEST S1, S2</td><td>S1 &amp; S2</td><td>测试</td></tr><tr><td> testb</td><td></td><td>测试字节</td></tr><tr><td> testw</td><td></td><td>测试字</td></tr><tr><td> testl</td><td></td><td>测试双字</td></tr><tr><td> testq</td><td></td><td>测试四字</td></tr></tbody></table><ul><li>在 ATT 格式中，列出操作数的顺序是相反的。</li><li>如果两个操作数相等：零标志置为 1。若不相等：根据其他标志判断。</li></ul><h3 id="3-6-2-访问条件码"><a href="#3-6-2-访问条件码" class="headerlink" title="3.6.2 访问条件码"></a>3.6.2 访问条件码</h3><ul><li>根据条件码的某种组合，将一个字节设置为 0 或者 1。（<code>SET</code>指令。）</li><li>可以条件跳转到程序的某个其他的部分。</li><li>可以有条件地传送数据。</li></ul><table><thead><tr><th>指令</th><th>同义名</th><th>效果</th><th>设置条件</th></tr></thead><tbody><tr><td>sete   D</td><td>setz</td><td>D &lt;- ZF</td><td>相等/零</td></tr><tr><td>setne  D</td><td>setnz</td><td>D &lt;- ~ZF</td><td>不等/非零</td></tr><tr><td>sets   D</td><td></td><td>D &lt;- SF</td><td>负数</td></tr><tr><td>setns  D</td><td></td><td>D &lt;- ~SF</td><td>非负数</td></tr><tr><td>setg   D</td><td>setnle</td><td>D &lt;- ~(SF^OF)&amp;~ZF</td><td>大于（有符号）</td></tr><tr><td>setge  D</td><td>setnl</td><td>D &lt;- ~(SF^OF)</td><td>大于等于（有符号）</td></tr><tr><td>setl   D</td><td>setnge</td><td>D &lt;- SF^OF</td><td>小于（有符号）</td></tr><tr><td>setle  D</td><td>setng</td><td>D &lt;- (SF^OF) or ZF</td><td>小于等于（有符号）</td></tr><tr><td>seta   D</td><td>setnbe</td><td>D &lt;- ~CF &amp; ~ZF</td><td>超过（无符号）</td></tr><tr><td>setae  D</td><td>setnb</td><td>D &lt;- ~CF</td><td>超过或等于（无符号）</td></tr><tr><td>setb   D</td><td>setnae</td><td>D &lt;- CF</td><td>低于（无符号）</td></tr><tr><td>setbe  D</td><td>setna</td><td>D &lt;- CF or ZF</td><td>低于或等于（无符号）</td></tr></tbody></table><ul><li><code>SET</code>指令的后缀不是操作数的大小，而是不同的条件。</li><li><p><code>SET</code>的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置为 0 或者 1。因此如果要得到 32 位或者 64 位的结果，须对高位清零。</p></li><li><p>对于大多数情况，机器代码对于有符号和无符号两种情况都使用一样的指令。</p></li><li>有些情况需要用不同的指令来处理有符号和无符号操作。例如：右移、乘除、不同的条件码组合。</li></ul><h3 id="3-6-3-跳转指令"><a href="#3-6-3-跳转指令" class="headerlink" title="3.6.3 跳转指令"></a>3.6.3 跳转指令</h3><ul><li><p><code>jmp</code>：无条件跳转指令。可以是：</p><ul><li>直接跳转：跳转目标是作为指令的一部分编码的。汇编中用标号，如<code>.L1</code>。</li><li>间接跳转：跳转目标8是从寄存器或内存位置中读出的。汇编中用<code>*</code>跟操作数指示符，如<code>*%rax</code>、<code>*(%rax)</code>。</li></ul></li><li><p>其他条件跳转都只能是直接跳转。</p></li></ul><table><thead><tr><th>指令</th><th>同义名</th><th>跳转条件</th><th>描述</th></tr></thead><tbody><tr><td>je   D</td><td>jz</td><td>ZF</td><td>相等/零</td></tr><tr><td>jne  D</td><td>jnz</td><td>~ZF</td><td>不等/非零</td></tr><tr><td>js   D</td><td></td><td>SF</td><td>负数</td></tr><tr><td>jns  D</td><td></td><td>~SF</td><td>非负数</td></tr><tr><td>jg   D</td><td>jnle</td><td>~(SF^OF)&amp;~ZF</td><td>大于（有符号）</td></tr><tr><td>jge  D</td><td>jnl</td><td>~(SF^OF)</td><td>大于等于（有符号）</td></tr><tr><td>jl   D</td><td>jnge</td><td>SF^OF</td><td>小于（有符号）</td></tr><tr><td>jle  D</td><td>jng</td><td>(SF^OF) or ZF</td><td>小于等于（有符号）</td></tr><tr><td>ja   D</td><td>jnbe</td><td>~CF &amp; ~ZF</td><td>超过（无符号）</td></tr><tr><td>jae  D</td><td>jnb</td><td>~CF</td><td>超过或等于（无符号）</td></tr><tr><td>jb   D</td><td>jnae</td><td>CF</td><td>低于（无符号）</td></tr><tr><td>jbe  D</td><td>jna</td><td>CF or ZF</td><td>低于或等于（无符号）</td></tr></tbody></table><h3 id="3-6-4-跳转指令的编码"><a href="#3-6-4-跳转指令的编码" class="headerlink" title="3.6.4 跳转指令的编码"></a>3.6.4 跳转指令的编码</h3><p>跳转指令的编码分为：</p><ul><li>PC相对的（PC-relative）。将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、2、4 个字节。程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。</li><li>绝对地址，用 4 个字节直接指定目标，汇编器和连接器会选择适当的跳转目的编码。</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（汇编代码）</span><br><span class="line">1   mov     %rdi, %rax</span><br><span class="line">2   jmp     .L2</span><br><span class="line">3 .L3:</span><br><span class="line">4   sarq    %rax</span><br><span class="line">5 .L2:</span><br><span class="line">6   testq   %rax, %rax</span><br><span class="line">7   jg      .L3</span><br><span class="line">8   req; ret</span><br><span class="line"></span><br><span class="line">（机器代码的反汇编版本）</span><br><span class="line">1   0:  48 89 f8            mov     %rdi,%rax</span><br><span class="line">2   3:  eb 03               jmp     8 &lt;loop+0x8&gt;</span><br><span class="line">3   5:  48 d1 f8            sar     %rax</span><br><span class="line">4   8:  48 85 c0            test    %rax,%rax</span><br><span class="line">5   b:  7f f8               jg      5 &lt;loop+0x5&gt;</span><br><span class="line">6   d:  f3 c3               repz retq</span><br></pre></td></tr></table></figure><p>其中，反汇编第二行的<code>8</code>是由<code>0x3 + 0x5</code>得到，第五行的<code>5</code>是由<code>0xf8 + 0xd</code>得到。</p><p>注：AMD 建议用<code>rep</code>后面跟<code>ret</code>的组合来避免使<code>ret</code>成为条件跳转指令的目标。如果没有<code>rep</code>，当分支不跳转时，<code>jg</code>指令会继续到<code>ret</code>指令。（以后遇到<code>rep</code>或<code>repz</code>就直接无视掉。）</p><h3 id="3-6-5-用条件控制来实现条件分支"><a href="#3-6-5-用条件控制来实现条件分支" class="headerlink" title="3.6.5 用条件控制来实现条件分支"></a>3.6.5 用条件控制来实现条件分支</h3><p>C语言中<code>if-else</code>到汇编的转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">（C代码）</span><br><span class="line">if (test-expr)</span><br><span class="line">    then-statement</span><br><span class="line">else</span><br><span class="line">    else-statement</span><br><span class="line"></span><br><span class="line">（汇编代码）</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (!t)</span><br><span class="line">        goto false;</span><br><span class="line">    then-statement</span><br><span class="line">    goto done;</span><br><span class="line">false:</span><br><span class="line">    else-statement</span><br><span class="line">done:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="3-6-6-用条件传送来实现条件分支"><a href="#3-6-6-用条件传送来实现条件分支" class="headerlink" title="3.6.6 用条件传送来实现条件分支"></a>3.6.6 用条件传送来实现条件分支</h3><ul><li><p>利用控制实现条件转移虽然简单通用，但是可能非常低效。因为处理器通过使用“流水线”来获得高性能，而流水线需要事先确定要执行的指令序列，遇到条件分支时需要采用“分支预测逻辑”来猜测每条跳转指令是否会执行。若猜错，需要处理器丢掉这些已经做好的工作，浪费大约15~30个时钟周期。</p></li><li><p>假设预测错误的概率是<code>p</code>，如果没有预测错误，执行代码的时间是<code>T-OK</code>，否则是<code>T-MP</code>，则执行代码的平均时间<code>T-avg = T-OK + p * T-MP</code>。</p></li></ul><table><thead><tr><th>指令</th><th>同义名</th><th>传送条件</th><th>描述</th></tr></thead><tbody><tr><td>cmove   S,R</td><td>cmovz</td><td>ZF</td><td>相等/零</td></tr><tr><td>cmovne  S,R</td><td>cmovnz</td><td>~ZF</td><td>不等/非零</td></tr><tr><td>cmovs   S,R</td><td></td><td>SF</td><td>负数</td></tr><tr><td>cmovns  S,R</td><td></td><td>~SF</td><td>非负数</td></tr><tr><td>cmovg   S,R</td><td>cmovnle</td><td>~(SF^OF)&amp;~ZF</td><td>大于（有符号）</td></tr><tr><td>cmovge  S,R</td><td>cmovnl</td><td>~(SF^OF)</td><td>大于等于（有符号）</td></tr><tr><td>cmovl   S,R</td><td>cmovnge</td><td>SF^OF</td><td>小于（有符号）</td></tr><tr><td>cmovle  S,R</td><td>cmovng</td><td>(SF^OF) or ZF</td><td>小于等于（有符号）</td></tr><tr><td>cmova   S,R</td><td>cmovnbe</td><td>~CF &amp; ~ZF</td><td>超过（无符号）</td></tr><tr><td>cmovae  S,R</td><td>cmovnb</td><td>~CF</td><td>超过或等于（无符号）</td></tr><tr><td>cmovb   S,R</td><td>cmovnae</td><td>CF</td><td>低于（无符号）</td></tr><tr><td>cmovbe  S,R</td><td>cmovna</td><td>CF or ZF</td><td>低于或等于（无符号）</td></tr></tbody></table><ul><li>两个操作数：源寄存器或内存地址 S，目的寄存器 R。</li><li>只有在指定的条件满足时，才会被复制到目的寄存器中。</li><li>源和目的的值可以时16位、32位、64位，不支持单字节的条件传送。汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。</li></ul><p>对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（C语句）</span><br><span class="line">v = test-expr ? then-expr : else-expr;</span><br><span class="line"></span><br><span class="line">（条件控制转移形式）</span><br><span class="line">    if (!test-expr)</span><br><span class="line">        goto false;</span><br><span class="line">    v = then-expr</span><br><span class="line">    goto done;</span><br><span class="line">false:</span><br><span class="line">    v = else-expr;</span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">（条件传送形式）</span><br><span class="line">v = then-expr;</span><br><span class="line">ve = else-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line">if (!t) v = ve;</span><br></pre></td></tr></table></figure><ul><li><p>不是所有的条件表达式都可以用传送条件来编译。如果<code>then-expr</code>或<code>else-expr</code>可能产生错误条件或副作用，会导致非法的行为。（如给全局变量赋值、<code>return p ? *p : 0;</code>等）</p></li><li><p>条件传送并不总是会提高代码的效率。编译器一般只在两个表达式都很容易计算且没有副作用时才会使用。</p></li></ul><h3 id="3-6-7-循环"><a href="#3-6-7-循环" class="headerlink" title="3.6.7 循环"></a>3.6.7 循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">（C语句）</span><br><span class="line">do</span><br><span class="line">    body-statement</span><br><span class="line">    while (test-expr);</span><br><span class="line"></span><br><span class="line">（汇编）</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line">（C语句）</span><br><span class="line">while (test-expr)</span><br><span class="line">    body-statement</span><br><span class="line"></span><br><span class="line">（汇编方式一：跳转到中间）</span><br><span class="line">    goto test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line">（汇编方式二：guarded-do）</span><br><span class="line">t = test-expr;</span><br><span class="line">if (!t)</span><br><span class="line">    goto done;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">（C语句）</span><br><span class="line">for(init-expr; test-expr; update-expr)</span><br><span class="line">    body-statement</span><br><span class="line"></span><br><span class="line">（汇编一）</span><br><span class="line">    init-expr;</span><br><span class="line">    goto test;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">test:</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line"></span><br><span class="line">（汇编二）</span><br><span class="line">    init-expr;</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (!t)</span><br><span class="line">        goto done;</span><br><span class="line">loop:</span><br><span class="line">    body-statement</span><br><span class="line">    update-expr;</span><br><span class="line">    t = test-expr;</span><br><span class="line">    if (t)</span><br><span class="line">        goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h3 id="3-6-8-switch-语句"><a href="#3-6-8-switch-语句" class="headerlink" title="3.6.8 switch 语句"></a>3.6.8 switch 语句</h3><ul><li>使用 <strong>跳转表（jump table）</strong> 提高效率，使得执行 switch 语句的时间与开关情况的数量无关。</li><li>跳转表可以用 GCC 对 C 的扩展的方式表示：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;&amp;表示指向代码位置的指针。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *jt[<span class="number">7</span>] = &#123;</span><br><span class="line">    &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,</span><br><span class="line">    &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,</span><br><span class="line">    &amp;&amp;loc_D</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>跳转表的汇编表示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  .section      .rodata</span><br><span class="line">  .align 8</span><br><span class="line">.L4:</span><br><span class="line">  .quad     .L3                     # Case 100: loc_A</span><br><span class="line">  .quad     .L8                     # Case 101: loc_def</span><br><span class="line">  .quad     .L5                     # Case 102: loc_B</span><br><span class="line">  .quad     .L6                     # Case 103: loc_C</span><br><span class="line">  .quad     .L7                     # Case 104: loc_D</span><br><span class="line">  .quad     .L8                     # Case 105: loc_def</span><br><span class="line">  .quad     .L7                     # Case 106: loc_D</span><br></pre></td></tr></table></figure><ul><li>switch语句的汇编表示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">switch_eg:</span><br><span class="line">    subq        $100, %rsi          # Compute index = n - 100</span><br><span class="line">    cmpq        $6, %rsi            # Compare index and 6</span><br><span class="line">    ja          .L8                 # If &gt;, goto loc_def</span><br><span class="line">    jmp         *.L4(,%rsi,8)       # Goto *jt[index]</span><br><span class="line">.L3:</span><br><span class="line">    ...</span><br><span class="line">.L5:</span><br><span class="line">    ...</span><br><span class="line">...</span><br><span class="line">.L2:</span><br><span class="line">    movq        %rdi, (%rdx)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><ul><li>完整代码见原书。</li></ul><h2 id="3-7-过程"><a href="#3-7-过程" class="headerlink" title="3.7 过程"></a>3.7 过程</h2><ul><li>过程的形式：函数（function）、方法（method）、子例程（subroutine）、处理函数（handler）等。</li><li><p>P 调用 Q，再返回 P。这些动作包括以下一个或多个机制：</p><ul><li>传递控制。（运行时栈）</li><li>传递数据。</li><li>分配和释放内存。</li></ul></li></ul><h3 id="3-7-1-运行时栈"><a href="#3-7-1-运行时栈" class="headerlink" title="3.7.1 运行时栈"></a>3.7.1 运行时栈</h3><ul><li>当 x86-64 过程需要的存储空间超过寄存器能够存放的大小时，就会在栈上分配空间。这个部分成为过程的 <strong>栈帧（stack frame）</strong>。</li></ul><p><img src="http://static.ifanze.cn/630A095A-C44F-42BA-B5F3-73834F147A5B.jpeg" alt=""></p><ul><li><p>当 P 调用 Q 时：</p><ul><li>把返回地址压入栈中（表示从 Q 返回时，从 P 的哪个位置继续执行）（算作 P 的栈帧的一部分）。</li><li>Q 会扩展当前栈的边界，在这个空间里，可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</li></ul></li><li><p>大多数过程的栈帧都是定长的，在过程的开始就分配好了。但也有变长的帧。</p></li><li>最多可以通过寄存器传递 6 个整数值（指针和整数），如果 Q 需要更多的参数，则 P 可以在 Q 调用之前在自己的栈帧里存储好这些参数。</li><li>当所有的局部变量都可以保存在寄存器中，且该函数不会调用任何其他函数，不需要栈帧。</li></ul><h3 id="3-7-2-转移控制"><a href="#3-7-2-转移控制" class="headerlink" title="3.7.2 转移控制"></a>3.7.2 转移控制</h3><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>call Label</td><td>过程调用（直接调用）</td></tr><tr><td>call *Operand</td><td>过程调用（间接调用）</td></tr><tr><td>ret</td><td>从过程调用中返回</td></tr></tbody></table><ul><li><code>call Q</code> 会把地址A（返回地址，是紧跟在<code>call</code>指令后的那条指令的地址）压入栈，并将 PC 设置为 Q 的起始地址。</li><li><code>ret</code> 会从栈中弹出地址A，并将 PC 设置为 A。</li></ul><h3 id="3-7-3-数据传送"><a href="#3-7-3-数据传送" class="headerlink" title="3.7.3 数据传送"></a>3.7.3 数据传送</h3><ul><li>x86-64 中，可以通过寄存器最多传递6个整型参数。多余的部分就要通过栈来传递。</li><li>寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。</li><li>使用栈传递参数时，所有的数据大小都向8的倍数对齐。</li></ul><table><thead><tr><th>操作数大小</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6   </th></tr></thead><tbody><tr><td>64</td><td>%rdi</td><td>%rsi</td><td>%rdx</td><td>%rcx</td><td>%r8</td><td>%r9    </td></tr><tr><td>32</td><td>%edi</td><td>%esi</td><td>%edx</td><td>%ecx</td><td>%r8d</td><td>%r9d </td></tr><tr><td>16</td><td>%di</td><td>%si</td><td>%dx</td><td>%cx</td><td>%r8w</td><td>%r9w  </td></tr><tr><td>8</td><td>%dil</td><td>%sil</td><td>%dl</td><td>%cl</td><td>%r8b</td><td>%r9b  </td></tr></tbody></table><ul><li>假设一个函数有两个参数需要放到栈中，分别是<code>char</code>和<code>char*</code>类型。则它的内存状态是：</li></ul><p><img src="http://static.ifanze.cn/698256E6-47B7-4955-A223-635CC7D2FFF2.jpeg" alt=""></p><h3 id="3-7-4-栈上的局部存储"><a href="#3-7-4-栈上的局部存储" class="headerlink" title="3.7.4 栈上的局部存储"></a>3.7.4 栈上的局部存储</h3><ul><li><p>局部数据必须存放在内存中的情况：</p><ul><li>寄存器不足够存放所有的本地数据。</li><li>对一个局部变量使用地址运算符<code>&amp;</code>，因此必须能够为它产生一个地址。</li><li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。</li></ul></li></ul><h3 id="3-7-5-寄存器中的局部存储空间"><a href="#3-7-5-寄存器中的局部存储空间" class="headerlink" title="3.7.5 寄存器中的局部存储空间"></a>3.7.5 寄存器中的局部存储空间</h3><ul><li><p><code>%rbx</code>、<code>%rbp</code>和<code>%r12 ~ %r15</code>被划分成 <strong>被调用者</strong> 保存寄存器。当 P 调用 Q 时，Q 必须保存这些寄存器的值，确保他们在调用接受后不变。措施有：</p><ul><li>根本不去改变它。</li><li>把原始值压入栈中，返回前再弹出。</li></ul></li><li><p>其他所有寄存器，除了栈指针<code>%rsp</code>，都分类为 <strong>调用者</strong> 保存寄存器。任何函数都能修改他们。当 P 调用 Q 时，调用前保存好这个数据是 P 的责任。</p></li></ul><h3 id="3-7-6-递归过程"><a href="#3-7-6-递归过程" class="headerlink" title="3.7.6 递归过程"></a>3.7.6 递归过程</h3><ul><li>栈机制使得对递归的情况同样适用。</li></ul><h2 id="3-8-数组分配和访问"><a href="#3-8-数组分配和访问" class="headerlink" title="3.8 数组分配和访问"></a>3.8 数组分配和访问</h2><h3 id="3-8-1-基本原则"><a href="#3-8-1-基本原则" class="headerlink" title="3.8.1 基本原则"></a>3.8.1 基本原则</h3><p><code>T A[N]</code></p><ul><li>数据类型：<code>T</code></li><li>整形常数：<code>N</code></li><li>标识符：<code>A</code></li><li>元素大小：<code>L</code></li><li>起始地址：<code>x</code></li><li>元素i的地址：<code>x + i * L</code></li></ul><h3 id="3-8-2-指针运算"><a href="#3-8-2-指针运算" class="headerlink" title="3.8.2 指针运算"></a>3.8.2 指针运算</h3><ul><li>可利用<code>MOV</code>、<code>leaq</code>等指令进行地址的运算。</li></ul><h3 id="3-8-3-嵌套的数组"><a href="#3-8-3-嵌套的数组" class="headerlink" title="3.8.3 嵌套的数组"></a>3.8.3 嵌套的数组</h3><ul><li>对于<code>T D[R][C]</code>，<code>&amp;D[i][j] = x + L(C · i + j)</code>。</li></ul><h3 id="3-8-4-定长数组"><a href="#3-8-4-定长数组" class="headerlink" title="3.8.4 定长数组"></a>3.8.4 定长数组</h3><ul><li>编译器往往会对定长多维数组进行优化。</li></ul><h3 id="3-8-5-变长数组"><a href="#3-8-5-变长数组" class="headerlink" title="3.8.5 变长数组"></a>3.8.5 变长数组</h3><ul><li>C99 允许数组的维度是表达式。这会导致寄存器使用的变化，并且必须要使用乘法。</li><li>在循环引用定长数组时，编译器会利用其规律性进行优化计算。</li></ul><h2 id="3-9-异数的数据结构"><a href="#3-9-异数的数据结构" class="headerlink" title="3.9 异数的数据结构"></a>3.9 异数的数据结构</h2><h3 id="3-9-1-结构"><a href="#3-9-1-结构" class="headerlink" title="3.9.1 结构"></a>3.9.1 结构</h3><ul><li>编译器负责计算每个字段的地址。</li></ul><h3 id="3-9-2-联合"><a href="#3-9-2-联合" class="headerlink" title="3.9.2 联合"></a>3.9.2 联合</h3><ul><li>编译器负责计算每个字段的地址。</li></ul><h3 id="3-9-3-数据对齐"><a href="#3-9-3-数据对齐" class="headerlink" title="3.9.3 数据对齐"></a>3.9.3 数据对齐</h3><ul><li>许多计算机系统对基本数据类型的合法地址做了一些限制，比如必须是某个值（2、4 或 8）的倍数。</li><li>无论数据是否对齐，x86-64 硬件都能正确工作。不过，Intel 还是建议对齐数据以提高内存系统的性能。对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。</li><li>编译器在汇编代码中放入命令，指明全局数据所需的对齐。例如<code>.align 8</code>。</li><li>对于结构，编译器可能需要在字段的分配中插入间隙，以保证每个结构单元满足对齐要求。包括结尾，以满足结构数组的对齐要求。</li></ul><h2 id="3-10-在机器级程序中将控制与数据结合起来"><a href="#3-10-在机器级程序中将控制与数据结合起来" class="headerlink" title="3.10 在机器级程序中将控制与数据结合起来"></a>3.10 在机器级程序中将控制与数据结合起来</h2><h3 id="3-10-1-理解指针"><a href="#3-10-1-理解指针" class="headerlink" title="3.10.1 理解指针"></a>3.10.1 理解指针</h3><ul><li>每个指针都对应一个类型。（不是机器代码的一部分，属于C语言提供的抽象）</li><li>每个指针都有一个值。</li><li>指针用<code>&amp;</code>运算符创建。</li><li><code>*</code>用于间接引用指针。</li><li>数组和指针关系紧密。</li><li>将指针类型转换，不会改变它的值。</li><li>指针也可以指向函数。</li></ul><h3 id="3-10-2-应用：使用-GDB-调试器"><a href="#3-10-2-应用：使用-GDB-调试器" class="headerlink" title="3.10.2 应用：使用 GDB 调试器"></a>3.10.2 应用：使用 GDB 调试器</h3><p><img src="http://static.ifanze.cn/38F1C154-78AB-4929-8679-C751F202B963.jpeg" alt=""></p><h3 id="3-10-3-内存越界引用和缓冲区溢出"><a href="#3-10-3-内存越界引用和缓冲区溢出" class="headerlink" title="3.10.3 内存越界引用和缓冲区溢出"></a>3.10.3 内存越界引用和缓冲区溢出</h3><ul><li>缓冲区溢出（buffer overflow）会破坏栈的状态，甚至让程序执行攻击代码（exploit code）。</li></ul><h3 id="3-10-4-对抗缓冲区溢出攻击"><a href="#3-10-4-对抗缓冲区溢出攻击" class="headerlink" title="3.10.4 对抗缓冲区溢出攻击"></a>3.10.4 对抗缓冲区溢出攻击</h3><ul><li><p>栈随机化。</p><ul><li>过去，程序的栈地址非常容易预测，安全单一化（security monoculture）。</li><li>栈随机化的思想是使得栈的位置在程序每次运行时都发生变化。如在程序开始时在栈上分配随机个字节大小的空间。</li><li>这种策略已经变成了标准行为，它属于地址空间布局随机化（Address-Space Layout Randomization，ASLR）。</li><li>不过攻击者依然可以用蛮力攻克，比如在攻击代码前插入很长一段空操作雪橇（nop sled），只要猜中这段序列中的任一地址即可。</li></ul></li><li><p>栈破坏检测</p><ul><li>栈保护者（stack protector）机制：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary）值，或称哨兵值（guard value），是程序运行时随机产生的。在恢复寄存器状态和从函数返回之前，检查它是否改变了。</li></ul></li><li><p>限制可执行代码的区域</p><ul><li>虚拟内存空间在逻辑上被分成了页（page）。</li><li>硬件支持多种形式的内存保护，能够指明用户程序和操作系统内核所允许的访问形式。</li><li>许多系统都支持三种访问形式：读、写、执行。</li><li>以前，x86 将读和执行合并在一起，为了限制一些页是可读但不可执行，会带来性能损失。</li></ul></li></ul><h3 id="3-10-5-支持变长栈帧"><a href="#3-10-5-支持变长栈帧" class="headerlink" title="3.10.5 支持变长栈帧"></a>3.10.5 支持变长栈帧</h3><ul><li>使用<code>%rbp</code>作为帧指针（frame pointer）或称基指针（base pointer）。</li></ul><h2 id="3-11-浮点代码"><a href="#3-11-浮点代码" class="headerlink" title="3.11 浮点代码"></a>3.11 浮点代码</h2><ul><li><p>处理器的浮点数体系结构包括以下几个方面：</p><ul><li>如何存储和访问浮点数值。（通常通过某种寄存器）</li><li>对浮点数据操作的指令。</li><li>向函数传递浮点参数和从函数返回浮点数结果的规则。</li><li>函数调用过程中保存寄存器的规则。</li></ul></li><li><p>历史：</p><ul><li>1997，Pentium/MMX，媒体（media）指令，支持图形和图像处理，允许多个操作以并行模式执行，称为单指令多数据或 SIMD。（MM寄存器，64位）</li><li>SSE（Streaming SIMD Extension，流式 SIMD 扩展）。（XMM寄存器，128位）</li><li>AVX（Advanced Vector Extension，高级向量扩展）。（YMM寄存器，256位）</li><li>2000，Pentium 4，SSE2，媒体指令开始包括对标量浮点数据进行操作的指令，他们更类似于其他处理器支持浮点数的方式。所有能够执行 x86-64 代码的处理器都支持 SSE2 或更高的版本，因此 x86-64 浮点数是基于 SSE 或 AVX 的，包括传递过程参数和返回值的规则。</li><li>2013，Core i7 Haswell，AVX2。(指定命令行参数<code>-mavx2</code>)。我们讲述的版本。</li></ul></li></ul><p><img src="http://static.ifanze.cn/8FF60F1F-707F-4151-AF99-62D66C8CEBEF.jpeg" alt=""></p><ul><li>对标量数据操作时，这些寄存器只保存浮点数。并且只使用低32位（float）或64位（double）。</li></ul><h3 id="3-11-1-浮点传送和转换操作"><a href="#3-11-1-浮点传送和转换操作" class="headerlink" title="3.11.1 浮点传送和转换操作"></a>3.11.1 浮点传送和转换操作</h3><ul><li>引用内存的指令是标量指令，意味着只对单个而不是一组封装好的数据值进行操作。</li><li>数据要么保存在内存中（M32 或 M64），要么保存在XMM寄存器中（X）。</li><li>无论数据对齐与否，都能正确执行。不过代码优化规则建议32位最好满足4字节对齐，64位最好满足8字节对齐。</li></ul><table><thead><tr><th>指令</th><th>源</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td>   vmovss</td><td>M32</td><td>X</td><td>传送单精度数</td></tr><tr><td>   vmovss</td><td>X</td><td>M32</td><td>传送单精度数</td></tr><tr><td>   vmovsd</td><td>M64</td><td>X</td><td>传送双精度数</td></tr><tr><td>   vmovsd</td><td>X</td><td>M64</td><td>传送双精度数</td></tr><tr><td>   vmovaps</td><td>X</td><td>X</td><td>传送对齐的封装好的单精度数</td></tr><tr><td>   vmovapd</td><td>X</td><td>X</td><td>传送对齐的封装好的双精度数</td></tr></tbody></table><ul><li>程序复制整个寄存器还是只复制低位值既不会影响程序功能，也不会影响执行速度。</li><li><code>a</code>表示<code>aligned</code>，如果地址不满足 16 字节对齐，会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。</li></ul><table><thead><tr><th>指令</th><th>源</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td>vcvttss2si</td><td>X/M32</td><td>R32</td><td>用截断的方法把单精度数转换为整数</td></tr><tr><td>vcvttsd2si</td><td>X/M64</td><td>R32</td><td>用截断的方法把双精度数转换为整数</td></tr><tr><td>vcvttss2siq</td><td>X/M32</td><td>R64</td><td>用截断的方法把单精度数转换为四字整数</td></tr><tr><td>vcvttsd2siq</td><td>X/M64</td><td>R64</td><td>用截断的方法把双精度数转换为四字整数</td></tr></tbody></table><table><thead><tr><th>指令</th><th>源1</th><th>源2</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td>vcvtsi2ss</td><td>M32/R32</td><td>X</td><td>X</td><td>整数 -&gt; 单精度数</td></tr><tr><td>vcvtsi2sd</td><td>M32/R32</td><td>X</td><td>X</td><td>整数 -&gt; 双精度数</td></tr><tr><td>vcvtsi2ssq</td><td>M64/R64</td><td>X</td><td>X</td><td>四字整数 -&gt; 单精度数</td></tr><tr><td>vcvtsi2sdq</td><td>M64/R64</td><td>X</td><td>X</td><td>四字整数 -&gt; 双精度数</td></tr></tbody></table><h2 id="3-12-小结"><a href="#3-12-小结" class="headerlink" title="3.12 小结"></a>3.12 小结</h2><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 3.1 操作数的计算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.2 <code>MOV</code>指令的选择。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.3 <code>MOV</code>指令的挑错。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.4 <code>MOV</code>、<code>MOVZ</code>、<code>MOVS</code>的计算，实现C语言强制类型转换的指令。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.5 <code>MOV</code>、<code>MOVZ</code>、<code>MOVS</code>的逆向推算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.6 <code>leaq</code>的计算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.7 <code>leaq</code>的逆向推算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.8 一元和二元操作的计算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.9 C语言移位运算的指令。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.10 算术操作的逆向推算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.11 用<code>xorq %rdx, %rdx</code>实现赋 0 值。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.12 对比有符号除法和无符号除法产生的汇编。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.13 <code>SET</code>的逆向推算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.14 <code>TEST</code>的逆向推算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.15 跳转中PC相对寻址的计算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.16 汇编跳转实现C语言中的短路运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.17 条件跳转。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.18 汇编中条件跳转逆向推算C语句。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.19 条件分支预测错误的概率计算。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.20 汇编中条件传送逆向推算C语句。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.21 汇编中条件传送逆向推算C语句。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.22 阶乘的可用范围。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.23 汇编<code>do-while</code>反推。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.24 汇编<code>while</code>反推。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.25 汇编<code>while</code>反推。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.26 汇编<code>while</code>反推 。<em>计算有多少个1</em></li><li style="list-style: none"><input type="checkbox"></input> 3.27</li><li style="list-style: none"><input type="checkbox"></input> 3.28</li><li style="list-style: none"><input type="checkbox"></input> 3.29</li><li style="list-style: none"><input type="checkbox" checked></input> 3.30 <code>switch</code>反推。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.31 <code>switch</code>反推。</li><li style="list-style: none"><input type="checkbox" checked></input> 3.32 函数调用的运行时栈。</li><li style="list-style: none"><input type="checkbox"></input> 3.33 逆推参数类型。</li><li style="list-style: none"><input type="checkbox"></input> 3.34 判断局部值保存在寄存器还是栈上。</li><li style="list-style: none"><input type="checkbox"></input> 3.35 逆推递归函数。</li><li style="list-style: none"><input type="checkbox"></input> 3.36 数组大小和地址的计算。</li><li style="list-style: none"><input type="checkbox"></input> 3.37 指针运算与汇编代码。</li><li style="list-style: none"><input type="checkbox"></input> 3.38 逆推二维数组。</li><li style="list-style: none"><input type="checkbox"></input> 3.39 定长数组的优化。</li><li style="list-style: none"><input type="checkbox"></input> 3.40 逆推定长数组的优化。</li></ul><h1 id="4-处理器体系结构"><a href="#4-处理器体系结构" class="headerlink" title="4 处理器体系结构"></a>4 处理器体系结构</h1><h1 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5 优化程序性能"></a>5 优化程序性能</h1><h1 id="6-存储器层次结构"><a href="#6-存储器层次结构" class="headerlink" title="6 存储器层次结构"></a>6 存储器层次结构</h1><h1 id="7-链接"><a href="#7-链接" class="headerlink" title="7 链接"></a>7 链接</h1><h1 id="8-异常控制流"><a href="#8-异常控制流" class="headerlink" title="8 异常控制流"></a>8 异常控制流</h1><h1 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9 虚拟内存"></a>9 虚拟内存</h1><h1 id="10-系统级I-O"><a href="#10-系统级I-O" class="headerlink" title="10 系统级I/O"></a>10 系统级I/O</h1><h1 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11 网络编程"></a>11 网络编程</h1><h1 id="12-并发编程"><a href="#12-并发编程" class="headerlink" title="12 并发编程"></a>12 并发编程</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》读书笔记 第三章 程序的机器级表示。&lt;/p&gt;
    
    </summary>
    
      <category term="《深入理解计算机系统》" scheme="http://ifanze.cn/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全2》读书笔记 7</title>
    <link href="http://ifanze.cn/2018/06/26/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(7)/"/>
    <id>http://ifanze.cn/2018/06/26/《代码大全2》(7)/</id>
    <published>2018-06-26T09:32:16.000Z</published>
    <updated>2018-06-27T15:10:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全2》读书笔记 第七章 高质量的子程序</p><a id="more"></a><!-- toc --><h1 id="7-高质量的子程序"><a href="#7-高质量的子程序" class="headerlink" title="7 高质量的子程序"></a>7 高质量的子程序</h1><h2 id="7-1-创建子程序的正当理由"><a href="#7-1-创建子程序的正当理由" class="headerlink" title="7.1 创建子程序的正当理由"></a>7.1 创建子程序的正当理由</h2><ul><li>降低复杂度。</li><li>引入中间、易懂的抽象。</li><li>避免代码重复。</li><li>支持子类化。（重载）</li><li>隐藏顺序。</li><li>隐藏指针操作。</li><li>提高可移植性。</li><li>简化复杂的布尔判断。</li><li>改善性能。</li><li><p>创建类的很多理由也是创建子程序的理由。</p></li><li><p>心理障碍：不情愿为一个简单的目的而编写一个简单的子程序。</p></li></ul><h2 id="7-2-在子程序层上设计"><a href="#7-2-在子程序层上设计" class="headerlink" title="7.2 在子程序层上设计"></a>7.2 在子程序层上设计</h2><p>内聚性（cohesion）：</p><ul><li>功能上的内聚性（functional cohesion）：最强也最好的一种内聚性。子程序只执行一项功能。</li></ul><p>不够理想的内聚性：</p><ul><li>顺序上的内聚性（sequential cohesion）：子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有全部完成才完成一项功能。</li><li>通信上的内聚性（communicational cohesion）：一个子程序中的不同操作使用了同样的数据，但不存在其他任何联系。</li><li>临时的内聚性（temporal cohesion）：含有一些因为需要同时执行才放到一起的操作的子程序。</li></ul><p>不可取的内聚性：</p><ul><li>过程上的内聚性（procedural cohesion）：一个子程序中的操作是按特定顺序进行的。</li><li>逻辑上的内聚性（logical cohesion）：若干操作被放入同一个子程序中，通过传入的标志选择执行一项操作。</li><li>巧合的内聚性（coincidental cohesion）：子程序中的各个操作之间没有任何可以看到的关联。（无内聚性、混乱的内聚性）。</li></ul><h2 id="7-3-好的子程序名字"><a href="#7-3-好的子程序名字" class="headerlink" title="7.3 好的子程序名字"></a>7.3 好的子程序名字</h2><ul><li>描述子程序所做的所有事情。</li><li>避免使用无意义的、模糊或表述不清的动词。</li><li>不要仅通过数字来区分不同的子程序。</li><li>根据需要确定子程序名字的长度。</li><li>要对返回值有所描述。</li><li>用语气强烈的动词加宾语。</li><li>准确使用对仗词。</li><li>为常用操作确立命名规则。</li></ul><h2 id="7-4-子程序可以写多长"><a href="#7-4-子程序可以写多长" class="headerlink" title="7.4 子程序可以写多长"></a>7.4 子程序可以写多长</h2><ul><li>……200行顶多了。</li></ul><h2 id="7-5-如何使用子程序参数"><a href="#7-5-如何使用子程序参数" class="headerlink" title="7.5 如何使用子程序参数"></a>7.5 如何使用子程序参数</h2><ul><li>参数顺序：输入、修改、输出。</li><li>考虑创建<code>IN</code>、<code>OUT</code>关键字。</li><li>如果几个子程序都用了类似参数，让他们的排列一致。</li><li>使用所有的参数。</li><li>把状态或出错变量放在最后。</li><li>不要把子程序的参数用作工作变量。</li><li><p>在接口中对参数的断言加以说明。包括：</p><ul><li>参数时仅用于输入、要被修改的、还是仅用于输出的。</li><li>参数的单位。</li><li>没有用枚举的话，状态代码和错误值的含义。</li><li>所能接受的数值的范围。</li><li>不该出现的特定数值。</li></ul></li><li><p>参数数量限制在7个以内。</p></li><li>采用某种命名规则。</li><li>为子程序传递用以维持其接口抽象的变量或对象。（传整个对象还是其中特定几个参数。）</li><li>使用具名参数。（需语言支持）</li><li>确保实参和形参匹配。</li></ul><h2 id="7-6-使用函数时要特别考虑的问题"><a href="#7-6-使用函数时要特别考虑的问题" class="headerlink" title="7.6 使用函数时要特别考虑的问题"></a>7.6 使用函数时要特别考虑的问题</h2><ul><li><p>语义上：</p><ul><li>函数：有返回值。</li><li>过程：无返回值。</li></ul></li></ul><h2 id="7-7-宏子程序和内联子程序"><a href="#7-7-宏子程序和内联子程序" class="headerlink" title="7.7 宏子程序和内联子程序"></a>7.7 宏子程序和内联子程序</h2><ul><li>把宏表达式整个包含在括号内。</li><li>把含有多条语句的宏用大括号括起来。</li><li>除非必要，避免使用宏。</li><li>用给子程序命名的方法给宏命名，以便需要时用子程序替换宏。</li><li>C++中，可以用<code>const</code>、<code>inline</code>、<code>template</code>、<code>enum</code>、<code>typedef</code>等替代宏。</li><li>节制使用 inline 子程序。因为它违反了封装原则，也增加了整体代码的长度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全2》读书笔记 第七章 高质量的子程序&lt;/p&gt;
    
    </summary>
    
      <category term="《代码大全2》" scheme="http://ifanze.cn/categories/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全》读书笔记 6</title>
    <link href="http://ifanze.cn/2018/06/26/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(6)/"/>
    <id>http://ifanze.cn/2018/06/26/《代码大全2》(6)/</id>
    <published>2018-06-26T04:32:16.000Z</published>
    <updated>2018-06-27T15:10:19.472Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全2》读书笔记 第六章 可以工作的类</p><a id="more"></a><!-- toc --><h1 id="6-可以工作的类"><a href="#6-可以工作的类" class="headerlink" title="6 可以工作的类"></a>6 可以工作的类</h1><h2 id="6-1-类的基础：抽象数据类型（ADTs）"><a href="#6-1-类的基础：抽象数据类型（ADTs）" class="headerlink" title="6.1 类的基础：抽象数据类型（ADTs）"></a>6.1 类的基础：抽象数据类型（ADTs）</h2><h3 id="使用-ADT-的益处"><a href="#使用-ADT-的益处" class="headerlink" title="使用 ADT 的益处"></a>使用 ADT 的益处</h3><ul><li>隐藏实现细节。</li><li>增加功能和改动不会影响到整个程序。</li><li>让接口提供更多的信息。</li><li>更容易提高性能。</li><li>让程序的正确性显而易见。</li><li>程序更具有自我说明性。</li><li>无须在程序内到处传递数据。</li><li>你可以像在现实世界中那样操作实体，而不用在底层实现上操作它。</li></ul><h3 id="指导建议"><a href="#指导建议" class="headerlink" title="指导建议"></a>指导建议</h3><ul><li>把常见的底层数据类型创建为 ADT 并使用他们，而不再使用底层数据类型。</li><li>把像文件这样的常用对象当成 ADT。</li><li>简单的事物也可当作 ADT。</li><li>不要让 ADT 依赖于存储介质。</li></ul><h3 id="如何在非面向对象环境中使用-ADT-处理多分数据实例"><a href="#如何在非面向对象环境中使用-ADT-处理多分数据实例" class="headerlink" title="如何在非面向对象环境中使用 ADT 处理多分数据实例"></a>如何在非面向对象环境中使用 ADT 处理多分数据实例</h3><ul><li>做法一：每次使用 ADT 服务子程序时都传入实例的ID。（需要进行一次查询）</li><li>做法二：传入整个实例。（暴露了不需要的数据）</li><li>做法三：使用隐含实例，执行前调用<code>SetCurrentInstance(instID);</code>。（不推荐）</li></ul><h2 id="6-2-良好的类接口"><a href="#6-2-良好的类接口" class="headerlink" title="6.2 良好的类接口"></a>6.2 良好的类接口</h2><h3 id="好的抽象"><a href="#好的抽象" class="headerlink" title="好的抽象"></a>好的抽象</h3><ul><li>类的接口应该展现一致的抽象层次。</li><li>一定要理解类所实现的抽象是什么。（一些类非常相像。）</li><li>提供成对的服务。（有开就有关。）</li><li>把不相关的信息转移到其他类中。</li><li>尽可能让接口可编程，而不是表达语义。（一个接口中任何无法通过编译器强制实施的语义部分，就是一个可能被误用的部分，需要用注释或者断言指出。）</li><li>谨防在修改时破坏接口的抽象。</li><li>不要添加与接口抽象不一致的共用成员。</li><li>同时考虑抽象性和内聚性。</li></ul><h3 id="良好的封装"><a href="#良好的封装" class="headerlink" title="良好的封装"></a>良好的封装</h3><ul><li>尽可能地限制类和成员地可访问性。</li><li>不要公开暴露成员数据。</li><li>避免把私用的实现细节放入类的接口。<ul><li>如果你甚至不想把<code>private</code>的字段放到头文件中暴露给其他人开，可以使用一个<code>XXXImplement</code>类的指针。</li></ul></li><li>不要对类的使用者作出任何假设。</li><li>多数场合下应避免使用友元类。</li><li>不要因为一个程序里仅使用公用子程序，就把它归入公开接口。</li><li>让阅读代码比编写代码更方便。</li><li>要格外警惕从语义上破坏封装性。</li><li>留意过于紧密的耦合关系。</li></ul><h2 id="6-3-有关设计和实现的问题"><a href="#6-3-有关设计和实现的问题" class="headerlink" title="6.3 有关设计和实现的问题"></a>6.3 有关设计和实现的问题</h2><ul><li>包含才是面向对象编程中的主力技术，而不是继承。</li></ul><h3 id="包含（Containment）：-has-a"><a href="#包含（Containment）：-has-a" class="headerlink" title="包含（Containment）：... has a ..."></a>包含（Containment）：<code>... has a ...</code></h3><ul><li>包含用于实现<code>has a</code>关系。</li><li>万不得已时才通过<code>private</code>继承来实现<code>has a</code>关系。</li><li>警惕有超过约7个数据成员的类。（7±2）</li></ul><h3 id="继承（Inheritance）：-is-a"><a href="#继承（Inheritance）：-is-a" class="headerlink" title="继承（Inheritance）：...is a ..."></a>继承（Inheritance）：<code>...is a ...</code></h3><ul><li>继承用于实现<code>is a</code>关系。基类对派生类将会做什么既设定了预期，也给出了限制。</li><li>要么使用继承并进行详细说明，要么就不要用它。</li><li>遵循里氏代换原则（LSP，Liskvo Substitution Principle）。“派生类必须能通过基类的接口而被使用，且使用者无须了解两者之间的差异。”</li><li><p>确保只继承需要继承的部分。根据是否可覆盖、是否提供默认实现，可以分为：</p><ul><li>抽象且可覆盖的子程序。</li><li>可覆盖的子程序。</li><li>不可覆盖的子程序。</li></ul></li><li><p>不要覆盖一个不可覆盖的成员函数。</p></li><li>把共用的接口、数据及操作放到继承树中尽可能高的位置。</li><li>只有一个实例的类是值得怀疑的。（使用单件模式）</li><li>只有一个派生类的基类也是值得怀疑的。（提前设计）</li><li>派生后覆盖了某个子程序，但在其中没做任何操作（基类中有操作），这种情况也值得怀疑。（基类的设计问题。）</li><li>避免让继承体系过深。</li><li>尽量使用多态，避免大量的类型检查。（如果出现较为复杂的switch，就考虑一下多态。）</li><li>让所有数据都是<code>private</code>而非<code>protected</code>。“继承会破坏封装”，如果真的需要私有数据，就提供<code>protected</code>访问器函数。</li><li>慎用多重继承，设计良好的多重继承是能避免菱形继承的。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>如果多个类共享数据而非行为，应该共用对象，被这些类包含。</li><li>如果多个类共享行为而非数据，应该定义基类，被这些类继承。</li><li>如果多个类既共享数据又共享行为，应该定义基类，基类中定义共用数据和子程序，被这些类继承。</li><li>当你想由基类控制接口时，使用继承。</li><li>当你想自己控制接口时，使用包含。</li></ul><h3 id="成员函数和数据成员"><a href="#成员函数和数据成员" class="headerlink" title="成员函数和数据成员"></a>成员函数和数据成员</h3><ul><li>让类中子程序的数量尽可能少。</li><li>尽量隐式地产生你不需要地成员函数和运算符。</li><li>减少类所调用的不同子程序的数量。</li><li>对其他类的子程序的间接调用要尽可能少。</li><li><p>一般来说，应尽量减少类和类之间相互合作的范围。包括：</p><ul><li>所实例化的对象的种类。</li><li>在被实例化对象上直接调用的不同子程序的数量。</li><li>调用由其他对象返回的对象的子程序的数量。</li></ul></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>如果可能，应该在所有的构造函数中初始化所有的数据成员。（防御式编程）</li><li>用私有构造函数来强制实现单件属性。</li><li><p>优先采用深层复本（deep copies），除非论证可行，才采用浅层副本（shallow copies）。</p><ul><li>深层：开发和维护较为简单，性能也往往不会损失太多。</li><li>浅层：更快，但是增加了复杂度，容易出错。</li></ul></li></ul><h2 id="6-4-创建类的原因"><a href="#6-4-创建类的原因" class="headerlink" title="6.4 创建类的原因"></a>6.4 创建类的原因</h2><h3 id="创建原因"><a href="#创建原因" class="headerlink" title="创建原因"></a>创建原因</h3><ul><li>为现实世界中的对象建模。</li><li>为抽象的对象建模。</li><li>降低复杂度。</li><li>隔离复杂度。</li><li>隐藏实现细节。</li><li>限制变动的影响范围。</li><li>隐藏全局变量。（使用访问器子程序 access routine）</li><li>让参数传递更顺畅。</li><li>建立中心控制点。</li><li>让代码更易于重用。</li><li>为程序族做计划。</li><li>将相关操作包装到一起。</li><li>实现某种特定的重构。</li></ul><h3 id="应该避免的类"><a href="#应该避免的类" class="headerlink" title="应该避免的类"></a>应该避免的类</h3><ul><li>避免创建万能类。</li><li>消除无关紧要的类。</li><li>避免用动词命名的类。</li></ul><h2 id="6-5-与具体编程语言相关的问题"><a href="#6-5-与具体编程语言相关的问题" class="headerlink" title="6.5 与具体编程语言相关的问题"></a>6.5 与具体编程语言相关的问题</h2><p>不同语言之间可能有差异的地方：</p><ul><li>在继承层次中被覆盖的构造函数、析构函数的行为。</li><li>在异常处理时构造函数、析构函数的行为。</li><li>默认构造函数的重要性。</li><li>析构函数的调用时机。</li><li>覆盖运算符相关。</li><li>对象被创建和销毁时，或被声明时，或退出作用域时，处理内存的方式。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全2》读书笔记 第六章 可以工作的类&lt;/p&gt;
    
    </summary>
    
      <category term="《代码大全2》" scheme="http://ifanze.cn/categories/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>Shell CheatSheet</title>
    <link href="http://ifanze.cn/2018/06/24/Shell-CheatSheet/"/>
    <id>http://ifanze.cn/2018/06/24/Shell-CheatSheet/</id>
    <published>2018-06-24T08:17:10.000Z</published>
    <updated>2018-06-26T14:15:37.897Z</updated>
    
    <content type="html"><![CDATA[<p>经常需要编写 shell 脚本进行一些自动化操作或者简单的处理，这里记录一些小技巧。</p><a id="more"></a><!-- toc --><h2 id="写好shell脚本的13个技巧"><a href="#写好shell脚本的13个技巧" class="headerlink" title="写好shell脚本的13个技巧"></a>写好shell脚本的13个技巧</h2><blockquote><p>引用：<a href="https://codeburst.io/13-tips-tricks-for-writing-shell-scripts-with-awesome-ux-19a525ae05ae">https://codeburst.io/13-tips-tricks-for-writing-shell-scripts-with-awesome-ux-19a525ae05ae</a><br>中文版：<a href="https://mp.weixin.qq.com/s/ZaIX8jv9LMWmrHQb4ew-dQ">https://mp.weixin.qq.com/s/ZaIX8jv9LMWmrHQb4ew-dQ</a></p></blockquote><h3 id="1-提供-help"><a href="#1-提供-help" class="headerlink" title="1. 提供--help"></a>1. 提供<code>--help</code></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -ne 0 ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;@#"--help"&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'...help...\n'</span>;</span><br><span class="line">  <span class="built_in">exit</span> 0;</span><br><span class="line"><span class="keyword">fi</span>;</span><br></pre></td></tr></table></figure><ul><li><p>学到了：</p><ul><li><code>$@</code>输出所有参数。</li><li><code>$#</code>或<code>${ #@ }</code>输出参数长度。<em>（hexo报错，这里多加了空格）</em></li><li><code>#</code>用于按最短截断字符串，<code>##</code>用于按最长截断。</li><li><code>-eq</code>、<code>-ne</code>等只能用于数值，不能用于字符串。</li><li>字符串操作：<a href="https://blog.csdn.net/dongwuming/article/details/50605911">https://blog.csdn.net/dongwuming/article/details/50605911</a></li><li>命令行参数识别：<a href="https://www.jianshu.com/p/761b19247979">https://www.jianshu.com/p/761b19247979</a></li></ul></li></ul><h3 id="2-检查所有使用命令的可用性"><a href="#2-检查所有使用命令的可用性" class="headerlink" title="2. 检查所有使用命令的可用性"></a>2. 检查所有使用命令的可用性</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">_=$(<span class="built_in">command</span> -v docker);</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">exit</span> 127;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"start..."</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>command -v</code>寻找命令，弱寻找到该命令返回0。</li><li>使用<code>$?</code>获取上条命令的退出值。</li></ul><h3 id="3-独立于当前工作目录"><a href="#3-独立于当前工作目录" class="headerlink" title="3. 独立于当前工作目录"></a>3. 独立于当前工作目录</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">CURR_DIR=<span class="string">"<span class="variable">$(dirname $0)</span>"</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;CURR_DIR&#125;</span></span><br><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><ul><li><code>dirname file</code>可获取到当前目录到目标文件的相对路径。</li></ul><h3 id="4-输入使用环境变量还是参数？"><a href="#4-输入使用环境变量还是参数？" class="headerlink" title="4. 输入使用环境变量还是参数？"></a>4. 输入使用环境变量还是参数？</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do this</span></span><br><span class="line">AWS_ACCESS_TOKEN=<span class="string">'xxxxxxxxxxxx'</span> ./provision-everything</span><br><span class="line"><span class="comment"># and not</span></span><br><span class="line">./provisiong-everything --token <span class="string">'xxxxxxxxxxx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># do this</span></span><br><span class="line">./provision-everything --async --instance-count 400</span><br><span class="line"><span class="comment"># and not</span></span><br><span class="line">INSTANCE_COUNT=400 ASYNC=<span class="literal">true</span> ./provision-everything</span><br></pre></td></tr></table></figure><h3 id="5-打印对系统进行的所有操作"><a href="#5-打印对系统进行的所有操作" class="headerlink" title="5. 打印对系统进行的所有操作"></a>5. 打印对系统进行的所有操作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Downloading required document to ./downloaded... '</span>;</span><br><span class="line">wget -o ./downloaded https://some.site.com/downloaded;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Moving ./downloaded to /opt/downloaded...'</span>;</span><br><span class="line">mv ./downloaded /opt/;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Creating symlink to /opt/downloaded...'</span>;</span><br><span class="line">ln -s /opt/downloaded /usr/bin/downloaded;</span><br></pre></td></tr></table></figure><ul><li><code>printf -- &quot;xxxxx&quot;</code>可以让后面的字符串原样打印。</li></ul><h3 id="6-silent模式"><a href="#6-silent模式" class="headerlink" title="6. --silent模式"></a>6. <code>--silent</code>模式</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -ne 0 ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;@#"--silent"&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  stty -<span class="built_in">echo</span>;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># before point of intended output:</span></span><br><span class="line">stty +<span class="built_in">echo</span> &amp;&amp; <span class="built_in">printf</span> -- <span class="string">'intended output\n'</span>;</span><br><span class="line"><span class="comment"># silence it again till end of script</span></span><br><span class="line">stty -<span class="built_in">echo</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">stty +<span class="built_in">echo</span>;</span><br><span class="line"><span class="built_in">exit</span> 0;</span><br></pre></td></tr></table></figure><ul><li>利用<code>stty -echo</code>和<code>stty +echo</code>控制屏幕回显。但要注意如果程序中途异常状态没有设置回来。</li></ul><h3 id="7-捕获异常恢复输出显示"><a href="#7-捕获异常恢复输出显示" class="headerlink" title="7. 捕获异常恢复输出显示"></a>7. 捕获异常恢复输出显示</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">error_handle</span></span>() &#123;</span><br><span class="line">  stty <span class="built_in">echo</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;#@&#125;</span> -ne 0 ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;@#"--silent"&#125;</span>"</span> = <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">  stty -<span class="built_in">echo</span>;</span><br><span class="line">  <span class="built_in">trap</span> error_handle INT;</span><br><span class="line">  <span class="built_in">trap</span> error_handle TERM;</span><br><span class="line">  <span class="built_in">trap</span> error_handle KILL;</span><br><span class="line">  <span class="built_in">trap</span> error_handle EXIT;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="8-动态进度条"><a href="#8-动态进度条" class="headerlink" title="8. 动态进度条"></a>8. 动态进度条</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'Performing asynchronous action..'</span>;</span><br><span class="line">./trigger-action;</span><br><span class="line">DONE=0;</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$DONE</span> -eq 0 ]; <span class="keyword">do</span></span><br><span class="line">  ./async-checker;</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"$?"</span> = <span class="string">"0"</span> ]; <span class="keyword">then</span> DONE=1; <span class="keyword">fi</span>;</span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'.'</span>;</span><br><span class="line">  sleep 1;</span><br><span class="line"><span class="keyword">done</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">' DONE!\n'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="http://mywiki.wooledge.org/BashFAQ/034">http://mywiki.wooledge.org/BashFAQ/034</a></p></blockquote><h3 id="9-用颜色编码输出"><a href="#9-用颜色编码输出" class="headerlink" title="9. 用颜色编码输出"></a>9. 用颜色编码输出</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"doing something... \n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[37m someone else\s output \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[32m SUCCESS: yay \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[33m WARNING: hmm \033[0m\n"</span>;</span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">"\033[31m ERROR: fubar \033[0m\n"</span>;</span><br></pre></td></tr></table></figure><ul><li>有些脚本使用<code>\e</code>而不是<code>\033</code>，但要注意<code>\e</code>不适用于所有的 UNIX 系统。</li><li>所有可用颜色：<a href="https://misc.flogisoft.com/bash/tip_colors_and_formatting">https://misc.flogisoft.com/bash/tip_colors_and_formatting</a></li></ul><h3 id="10-出现错误立即退出脚本"><a href="#10-出现错误立即退出脚本" class="headerlink" title="10. 出现错误立即退出脚本"></a>10. 出现错误立即退出脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> +e;</span><br><span class="line">./script-1;</span><br><span class="line">./script-2; <span class="comment"># does not depend on ./script-1</span></span><br><span class="line">./script-3; <span class="comment"># does not depend on ./script-2</span></span><br><span class="line"><span class="built_in">set</span> -e;</span><br><span class="line">./script-4;</span><br><span class="line">./script-5; <span class="comment"># depends on success of ./script-4</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="11-自己执行清理工作"><a href="#11-自己执行清理工作" class="headerlink" title="11. 自己执行清理工作"></a>11. 自己执行清理工作</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">handle_exit_code</span></span>() &#123;</span><br><span class="line">  ERROR_CODE=<span class="string">"$?"</span>;</span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">"an error occurred. cleaning up now... "</span>;</span><br><span class="line">  <span class="comment"># ... cleanup code ...</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">"DONE.\nExiting with error code <span class="variable">$&#123;ERROR_CODE&#125;</span>.\n"</span>;</span><br><span class="line">  <span class="built_in">exit</span> <span class="variable">$&#123;ERROR_CODE&#125;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">trap</span> <span class="string">"handle_exit_code"</span> EXIT;</span><br><span class="line"><span class="comment"># ... actual script...</span></span><br></pre></td></tr></table></figure><h3 id="12-在退出时使用不同的错误码"><a href="#12-在退出时使用不同的错误码" class="headerlink" title="12. 在退出时使用不同的错误码"></a>12. 在退出时使用不同的错误码</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'X happened. Exiting with status code 1.\n'</span>;</span><br><span class="line">  <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span>;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span> != <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> -- <span class="string">'Y happened. Exiting with status code 2.\n'</span>;</span><br><span class="line">  <span class="built_in">exit</span> 2;</span><br><span class="line"><span class="keyword">fi</span>;</span><br></pre></td></tr></table></figure><h3 id="13-在结束时打印一个新行"><a href="#13-在结束时打印一个新行" class="headerlink" title="13. 在结束时打印一个新行"></a>13. 在结束时打印一个新行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># ... your awesome script ...</span></span><br><span class="line"><span class="built_in">printf</span> -- <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">exit</span> 0;</span><br></pre></td></tr></table></figure><ul><li>最好用<code>printf</code>代替<code>echo</code>，因为后者在不同系统中行为有差别。</li><li><code>printf</code>不会像<code>echo</code>那样在命令结束后添加一个换行符。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常需要编写 shell 脚本进行一些自动化操作或者简单的处理，这里记录一些小技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="macOS" scheme="http://ifanze.cn/tags/macOS/"/>
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="参考" scheme="http://ifanze.cn/tags/%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>《代码大全2》读书笔记 5</title>
    <link href="http://ifanze.cn/2018/06/23/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B(5)/"/>
    <id>http://ifanze.cn/2018/06/23/《代码大全2》(5)/</id>
    <published>2018-06-23T03:33:11.000Z</published>
    <updated>2018-06-24T12:14:07.253Z</updated>
    
    <content type="html"><![CDATA[<p>《代码大全2》读书笔记 第五章 软件构建中的设计。</p><a id="more"></a><!-- toc --><h1 id="5-软件构建中的设计"><a href="#5-软件构建中的设计" class="headerlink" title="5 软件构建中的设计"></a>5 软件构建中的设计</h1><h2 id="设计的层次"><a href="#设计的层次" class="headerlink" title="设计的层次"></a>设计的层次</h2><ol><li><p>软件系统</p><ul><li>比起直接从系统层次开始设计类，从子系统或包这些类的更高组织层次来思考往往会更好。</li></ul></li><li><p>分解为子系统和包</p><ul><li>如数据库、用户界面、业务规则、命令解释器、报表引擎等。</li><li>注意不同子系统之间的通讯规则，限制过多通信。</li><li><p>简化子系统之间的交互关系。由简单到复杂依次是：</p><ul><li>子系统A调用子系统B的子程序。</li><li>子系统A包含子系统B的类。</li><li>子系统A继承自子系统B。</li></ul></li><li><p>子系统应该是无环的。</p></li><li>程序较小时，谨慎跳过这一层的设计。</li><li><p>常见子系统：</p><ul><li>业务规则。</li><li>用户界面。</li><li>数据库访问。</li><li>对系统的依赖性。</li></ul></li></ul></li><li><p>分解为包中的类</p><ul><li>尤其要确定好接口。</li></ul></li><li><p>分解为类中的数据和子程序</p><ul><li>细化出类的私有子程序。</li></ul></li><li><p>子程序内部的设计</p><ul><li>编写伪代码。</li><li>选择算法。</li><li>组织子程序内部的代码块。</li><li>代码编写。</li></ul></li></ol><h2 id="设计构造块：启发式方法（Design-Building-Blocks-Heuristics）"><a href="#设计构造块：启发式方法（Design-Building-Blocks-Heuristics）" class="headerlink" title="设计构造块：启发式方法（Design Building Blocks: Heuristics）"></a>设计构造块：启发式方法（Design Building Blocks: Heuristics）</h2><h3 id="找到现实中的对象"><a href="#找到现实中的对象" class="headerlink" title="找到现实中的对象"></a>找到现实中的对象</h3><ul><li><p>步骤：</p><ul><li>辨识对象及其属性。</li><li>定义可对对象执行的操作。</li><li>确定每个对象可以对其他对象进行的操作。（包含、继承）</li><li>确定对象的哪些部分对其他对象可见。</li><li>定义每个对象的接口。（public接口：对其他所有对象，protected接口：对继承对象。）</li></ul></li><li><p>迭代方向：</p><ul><li>高层次的系统组织结构上。</li><li>对定义好的类进行细化。</li></ul></li></ul><h3 id="形成一定的抽象"><a href="#形成一定的抽象" class="headerlink" title="形成一定的抽象"></a>形成一定的抽象</h3><ul><li>子程序接口的层次上。</li><li>类接口的层次上。</li><li>包接口的层次上。</li></ul><h3 id="封装实现细节"><a href="#封装实现细节" class="headerlink" title="封装实现细节"></a>封装实现细节</h3><ul><li>除了从高层的细节来看待一个对象，你不能看到它的其他细节层次。</li><li>封装帮你管理复杂度的方法是不让你看到那些复杂度。</li></ul><h3 id="当继承能简化设计时就继承"><a href="#当继承能简化设计时就继承" class="headerlink" title="当继承能简化设计时就继承"></a>当继承能简化设计时就继承</h3><ul><li>继承的好处在于它能很好地辅佐抽象地概念。</li><li>技能能简化编程的工作。</li><li>使用不当也会带来很大弊端。</li></ul><h2 id="隐藏秘密（信息隐藏）"><a href="#隐藏秘密（信息隐藏）" class="headerlink" title="隐藏秘密（信息隐藏）"></a>隐藏秘密（信息隐藏）</h2><ul><li>设计类时，一个关键性的决策就是确定类的哪些特性应该对外可见，哪些应该隐藏。</li><li>类的接口应该尽可能少地暴露其内部工作机制。</li><li>设计类的接口也是一个迭代的过程。</li><li>一个例子：<code>typedef int IdType;</code>。</li><li>信息隐藏所说的秘密主要分为两大类：隐藏复杂度、隐藏变化源。</li></ul><h3 id="信息隐藏的障碍"><a href="#信息隐藏的障碍" class="headerlink" title="信息隐藏的障碍"></a>信息隐藏的障碍</h3><ul><li><strong>信息过度分散</strong>。如常量未使用宏或常量定义。</li><li><strong>循环依赖</strong>。如类A和类B调用彼此的子程序。</li><li><strong>把类内数据误认为全局数据</strong>。</li><li><strong>性能损耗</strong>。编码阶段，不用担心信息隐藏带来的性能损耗。</li></ul><h3 id="信息隐藏的价值"><a href="#信息隐藏的价值" class="headerlink" title="信息隐藏的价值"></a>信息隐藏的价值</h3><ul><li>方便修改。</li><li>启发设计。对比：使用面向对象的思想会定义<code>IdType</code>类，使设计复杂化。</li><li>有助于设计类的公开接口。不要为了追求方便暴露类的私有数据，多写代码来保护类的秘密。</li></ul><h2 id="找出容易改变的区域"><a href="#找出容易改变的区域" class="headerlink" title="找出容易改变的区域"></a>找出容易改变的区域</h2><ul><li><p>好的程序设计要适应变化，措施：</p><ul><li>找出看起来容易变化的项目。</li><li>把容易变化的项目分离出来，单独划分成类，或者集合成类。</li><li>把看起来容易变化的项目隔离开来。</li></ul></li><li><p>容易发生变化的区域：</p><ul><li>业务规则。</li><li>对硬件的依赖性。</li><li>输入和输出。</li><li>非标准的语言特性。</li><li>困难的设计区域和构建区域。</li><li><p>状态变量。</p><ul><li>将布尔换作枚举。</li><li>使用访问器子程序（access routine）取代对状态变量的直接检查。</li></ul></li><li><p>数据量的限制。</p></li></ul></li><li><p>预料不同程度的变化：</p><ul><li>让这些变化的影响或范围与发生该变化的可能性成正比。</li><li>优秀的设计者还能预料应对变化所需的成本。</li><li>好方法：找出程序中可能对用户有用的最小子集，接下来用微小的步伐扩充这个系统。</li></ul></li></ul><h2 id="保持松散耦合"><a href="#保持松散耦合" class="headerlink" title="保持松散耦合"></a>保持松散耦合</h2><ul><li><p>耦合标准：</p><ul><li><strong>规模</strong>。指模块之间的连接数，如：参数个数，公有方法个数。</li><li><strong>可见性</strong>。如：通过参数表传递优于修改全局数据。</li><li><strong>灵活性</strong>。指模块间的连接是否容易改动，包括新增一个模块使用这个连接。</li></ul></li><li><p>耦合的种类：</p><ul><li>简单的数据参数耦合：通过简单数据类型的参数来传递数据。</li><li>简单对象耦合：一个模块实例化一个对象。</li><li>对象参数耦合：对象A要求对象B传给它一个对象C。这种耦合关系比较紧密，要求对象B也了解对象C。</li><li><p>语义上的耦合：最难缠。一个模块使用了另一个模块的语法元素，还使用了它内部工作细节的语义知识。如：</p><ul><li>A向B传递一个控制标志，用它告诉B该做什么。（A需要了解B对该标志的使用）</li><li>B在A修改了某个全局数据之后使用该全局数据。（B假设A的修改符合B的要求，且A已经在恰当的时间被调用过）</li><li>A的接口要求A.init()必须先于A.proc()调用，B知道A.proc()无论如何都会调用A.init()，就没去调用A.init()。</li><li>A向B传C，因为A知道B只需要C的部分信息，就没有完全初始化C。</li><li>A向B传基类，B知道A实际传的是派生类，就直接当作派生类来用。</li></ul></li></ul></li><li><p>松散耦合使得你对一个模块的使用不用同时关注几件事——内部工作细节、全局数据修改、不确定的功能点等。否则就失去了抽象的意义，模块具有的管理复杂度的功能就丧失了。</p></li></ul><h2 id="查阅常用的设计模式"><a href="#查阅常用的设计模式" class="headerlink" title="查阅常用的设计模式"></a>查阅常用的设计模式</h2><ul><li><p>设计模式的益处：</p><ul><li>通过提供现成的抽象来减少复杂度。</li><li>把常见解决方案的细节予以制度化来减少出错。</li><li>通过提供多种设计方案带来启发。</li><li>把设计对话提升一个层次来简化交流。</li></ul></li><li><p>潜在陷阱：</p><ul><li>强迫代码适用于某个模式。</li><li>为了模式而模式。</li></ul></li></ul><h2 id="其他启发式方法"><a href="#其他启发式方法" class="headerlink" title="其他启发式方法"></a>其他启发式方法</h2><ul><li><strong>高内聚性</strong>。使类的代码集中在一个中心目标。更容易记住代码功能。</li><li><strong>构造分层结构</strong>。</li><li><strong>严格描述类契约</strong>。“如果你承诺提供数据x，y，z，且答应让这些数据具有特征a，b，c，我就承诺基于约束8，9，10，来执行操作1，2，3。”。</li><li><strong>分配职责</strong>。</li><li><strong>为测试而设计</strong>。</li><li><strong>避免失误</strong>。</li><li><strong>有意识地选择绑定时间</strong>。做早绑定的代码通常比较简单，但也缺乏灵活性。</li><li><strong>创建中央控制点</strong>。</li><li><strong>考虑使用蛮力突破</strong>。</li><li><strong>画一个图</strong>。</li><li><strong>保持设计的模块化</strong>。</li></ul><h1 id="设计实践"><a href="#设计实践" class="headerlink" title="设计实践"></a>设计实践</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《代码大全2》读书笔记 第五章 软件构建中的设计。&lt;/p&gt;
    
    </summary>
    
      <category term="《代码大全2》" scheme="http://ifanze.cn/categories/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="coding" scheme="http://ifanze.cn/tags/coding/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》读书笔记 2</title>
    <link href="http://ifanze.cn/2018/06/21/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B(2)/"/>
    <id>http://ifanze.cn/2018/06/21/《深入理解计算机系统》(2)/</id>
    <published>2018-06-21T04:09:00.000Z</published>
    <updated>2018-09-01T14:01:43.182Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》读书笔记 第二章 信息的表示和处理。<br><a id="more"></a></p><h1 id="2-信息的表示和处理"><a href="#2-信息的表示和处理" class="headerlink" title="2 信息的表示和处理"></a>2 信息的表示和处理</h1><h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><ul><li><strong>字节（byte）</strong>：最小的可寻址的内存单位。</li></ul><h3 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h3><ul><li>二进制、十进制、十六进制间的相互转化。</li></ul><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><ul><li>每台计算机都有一个 <strong>字长（word size）</strong>，指明指针数据的标称大小（nominal size)。</li><li>虚拟地址是以这样的一个字来编码的，所有字长决定了虚拟地址空间的最大大小（<code>0 ~ 2^w-1</code>）。</li><li>32位字长：4GB。</li><li>64位字长：16EB。</li><li>32位程序和64位程序的区别在于如何编译的，大多数64位机器也可运行32位机器编译的程序（向后兼容）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 prog.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -m64 prog.c</span></span><br></pre></td></tr></table></figure><ul><li>C语言中：<ul><li>即使是64位系统编译，<code>int</code>通常也只有4字节。</li><li>C语言中，<code>long</code>在32位程序中为4字节，在64位程序中为8字节。</li><li>ISO C99 引入了确定大小的数据类型：<code>int32_t</code>、<code>int64_t</code>。</li><li>除非有<code>unsigned</code>，类型默认是有符号的，<code>char</code>是个例外，C标准不保证这一点。</li></ul></li></ul><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x01234567</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                0x100   0x101   0x102   0x103</span></span><br><span class="line"><span class="comment">//大端法    ...     01      23      45      67      ...</span></span><br><span class="line"><span class="comment">//小端法    ...     67      45      23      01      ...</span></span><br></pre></td></tr></table></figure><ul><li><p>字节顺序很重要的场合：</p><ul><li>网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则。</li><li>阅读表示整数数据的字节序列时。如反汇编器（disassembler）生成的代码。</li><li>当编写规避正常的类型系统的程序时。如强制类型转换（cast）或使用联合（union）。</li></ul></li><li><p>值相等的整数和浮点数在字节模式上截然不同，不过一般能够通过移位相匹配。</p></li></ul><h3 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h3><ul><li>以<code>0</code>结尾的字符数组。</li><li>使用ASCII码作字符码将在任何系统上得到相同的结果，与字节顺序和字大小规则无关。</li></ul><h3 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h3><ul><li>二进制代码很少能在不同机器和操作系统组合之间移植。</li></ul><h3 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h3><ul><li><code>~</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>^</code></li></ul><h3 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h3><ul><li><code>~</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>^</code></li></ul><h3 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h3><ul><li><code>&amp;&amp;</code></li><li><code>||</code></li><li><code>!</code></li></ul><h3 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h3><ul><li>左移：丢弃最高的k位，在右端补k个0。</li><li>逻辑右移：在左端补k个0。</li><li><p>算术右移：在左端补k个最高有效位的值。</p></li><li><p>C语言标准并未明确定义有符号数使用哪种右移，但几乎所有的编译器/机器都使用算术右移。</p></li><li>如果移动k位，k超过了该数据类型的长度（w位），在许多机器上，将只考虑移位<code>log(2)w</code>位。</li><li>加减运算符优先级比移位运算符高。</li></ul><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><ul><li>典型的C语言有符号整数的正负值范围是不对称的，负数多1个。</li><li>C语言标准定义的有符号整数类型必须能够表示的最小范围的正负值范围是对称的，除了<code>*32_t</code>、<code>*64_t</code>这种。</li></ul><h3 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h3><ul><li>用函数<code>B2U-w</code>表示。</li><li>无符号编码的唯一性：该函数是个双射。</li></ul><h3 id="2-2-3-补码编码（Two’s-complement）"><a href="#2-2-3-补码编码（Two’s-complement）" class="headerlink" title="2.2.3 补码编码（Two’s complement）"></a>2.2.3 补码编码（Two’s complement）</h3><ul><li>用函数<code>B2T-w</code>表示。</li><li>补码编码的唯一性：该函数是个双射。</li></ul><p>有符号数的其他表示方法：</p><ul><li>反码（Ones’ Complement）</li><li>原码（Sign-Magnitude）</li></ul><h3 id="2-2-4-有符号数和无符号数之间的转换"><a href="#2-2-4-有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 有符号数和无符号数之间的转换"></a>2.2.4 有符号数和无符号数之间的转换</h3><ul><li>用函数<code>T2U-w</code>、<code>U2T-w</code>表示。</li><li>对大多数C语言实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能改变，但位模式不变。</li><li>表现在最终数值上：<ul><li>有符号转无符号：正数不变，负数加<code>2^w</code>。</li><li>无符号转有符号：范围内不变，范围外减<code>2^w</code>。</li></ul></li></ul><h3 id="2-2-5-C语言中的有符号数与无符号数"><a href="#2-2-5-C语言中的有符号数与无符号数" class="headerlink" title="2.2.5 C语言中的有符号数与无符号数"></a>2.2.5 C语言中的有符号数与无符号数</h3><ul><li>无符号数添加后缀<code>u</code>。</li><li>显式类型转换。</li><li>隐式类型转换。</li><li>格式化输出。</li><li>运算数的转换：有符号和无符号运算，将转为无符号并假设二者都是非负的。</li><li>C语言中<code>INT_MIN</code>往往定义成<code>-INT_MAX-1</code>。</li></ul><h3 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h3><ul><li>无符号数的零扩展：添加0。</li><li>补码数的符号扩展：添加最高有效位的值。</li><li>如果即需要扩展有需要改变符号，C语言标准要求：先改变大小，再完成符号转换。</li></ul><h3 id="2-2-7-截断数值"><a href="#2-2-7-截断数值" class="headerlink" title="2.2.7 截断数值"></a>2.2.7 截断数值</h3><ul><li>截断无符号数：丢弃高位。新值为<code>x mod 2^k</code>。</li><li>截断补码数值：丢弃高位，重新解释符号位。新值为<code>U2T-k(x mod 2^k)</code></li></ul><h3 id="2-2-8-关于有符号数与无符号数的建议"><a href="#2-2-8-关于有符号数与无符号数的建议" class="headerlink" title="2.2.8 关于有符号数与无符号数的建议"></a>2.2.8 关于有符号数与无符号数的建议</h3><ul><li>可以要求绝不使用无符号数。</li><li>如果仅仅想把数字作为位的集合，无符号数是非常有用的。</li></ul><h2 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h2><h3 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h3><ul><li><code>x+y</code>若溢出，最终结果相当于<code>x+y-2^w</code>。</li><li>判断<code>x+y</code>是否溢出的方法是与<code>x</code>或<code>y</code>进行比较。</li><li>无符号数取反，<code>-x</code>，最终结果相当于<code>2^w-x</code>。（<code>0</code>除外，依然是0）。</li></ul><h3 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h3><ul><li><code>x+y</code>若溢出，最终结果相当于<code>x+y-2^w</code>（正溢出）或<code>x+y+2^w</code>（负溢出）。</li><li>当且仅当<code>x&gt;0, y&gt;0, s&lt;=0</code>时，发生了正溢出。</li><li>当且仅当<code>x&lt;0, y&lt;0, s&gt;=0</code>时，发生了负溢出。</li></ul><h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><ul><li><code>-TMin-w</code>还是<code>TMin-W</code>。其他数正常。</li><li>补码非得位级计算方式一：<code>-x</code> -&gt; <code>~x+1</code>。</li><li>补码非得位级计算方式二：找到最右边的1，将它左边的所有位取反。</li></ul><h3 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h3><ul><li><code>x*y</code>若溢出，最终结果相当于<code>x*y mod 2^w</code>。</li></ul><h3 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h3><ul><li><code>x*y</code>若溢出，最终结果相当于<code>U2T-w(x*y mod 2^w)</code>。</li><li>无符号和补码乘法的位级等价性：同样的位向量，无论是做无符号乘法还是补码乘法，最终结果的位向量都是一样的。</li></ul><h3 id="2-3-6-乘以整数"><a href="#2-3-6-乘以整数" class="headerlink" title="2.3.6 乘以整数"></a>2.3.6 乘以整数</h3><ul><li>乘以2的幂：左移。(无论是无符号还是补码，无论是否溢出)</li><li>C语言编译器会试图用移位和加法替代乘法，如<code>x*14 = (x&lt;&lt;3) + (x&lt;&lt;2) + (x&lt;&lt;1);</code>，因为<code>14 = 2^3 + 2^2 + 2^1</code>，或者<code>x*14 = (x&lt;&lt;4) - (x&lt;&lt;1)</code>，因为<code>14 = 2^4 - 2^1</code>。</li></ul><h3 id="2-3-7-除以2的幂"><a href="#2-3-7-除以2的幂" class="headerlink" title="2.3.7 除以2的幂"></a>2.3.7 除以2的幂</h3><ul><li>整数的除法的结果总是向0舍入，即会向下舍入一个正值，或者向上舍入一个负值。</li><li>无符号：逻辑移位即可，即<code>x / 2^k = x &gt;&gt; k</code>，结果是向下舍入的。</li><li>补码：如果仅仅算术移位，对负数来说结果依然是向下舍入的。因此需要做点偏移：<code>x / 2^k = (x+(1&lt;&lt;k)-1) &gt;&gt; k</code>。</li></ul><h3 id="2-3-8-关于整数运算的最后思考"><a href="#2-3-8-关于整数运算的最后思考" class="headerlink" title="2.3.8 关于整数运算的最后思考"></a>2.3.8 关于整数运算的最后思考</h3><ul><li>计算机的整数运算实际上是一种模运算形式。</li><li>结果运算可能溢出。</li><li>补码提供了一种既能表示整数又能表示负数的灵活方法。</li><li>某些规定和数据类型让程序产生意想不到的行为。</li></ul><h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><ul><li>IEEE浮点标准。</li></ul><h3 id="2-4-1-二进制小数"><a href="#2-4-1-二进制小数" class="headerlink" title="2.4.1 二进制小数"></a>2.4.1 二进制小数</h3><ul><li>我们不能准确地表示一个二进制小数，只能近似地表示。</li><li>小数点左边位的权是2的正幂，右边是2的负幂。</li><li>用<code>1-ε</code>表示能表示的距离1最近且小于1的浮点数。</li></ul><h3 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h3><ul><li><p><code>V = (-1)^s * M * 2^E</code></p><ul><li>符号s（sign）。</li><li>尾数M（significand），一个二进制小数，范围在<code>1~2-ε</code>或<code>0~1-ε</code>。</li><li>阶码E（exponent）。</li></ul></li><li><p>浮点数的位表示分成三段：</p><ul><li>1位符号位。</li><li>k位阶码。<ul><li>float：8，范围：-126 ~ +127。</li><li>double：11，范围：-1022 ~ +1023。</li></ul></li><li>n位尾数。<ul><li>float：23</li><li>dobule：52</li></ul></li></ul></li><li><p>根据阶码的值，可以分为三种情况：</p><ol><li>规格化的（<code>E != 0 &amp;&amp; E != 255</code>）<ul><li>阶码部分表示成无符号数得到的值<code>e</code>并不是阶码，<code>E = e - Bias</code>，其中偏置码<code>Bias = 2^(k-1) - 1</code>。</li><li>尾数部分表示成浮点数得到的值<code>f</code>（0.xxxx）并不是尾数，为了获得额外一个精度，<code>M = f + 1</code>。即隐含的以1开头（implied leading 1）的表示。</li></ul></li><li>非规格化的（<code>E == 0</code>）<ul><li><code>E = 1 - Bias</code></li><li><code>M = f</code></li></ul></li><li>无穷大（<code>E == 0x1111..1111 &amp;&amp; M == 0</code>）、NaN（<code>E == 0x1111..1111 &amp;&amp; M != 0</code>）</li></ol></li></ul><h3 id="2-4-3-数值示例"><a href="#2-4-3-数值示例" class="headerlink" title="2.4.3 数值示例"></a>2.4.3 数值示例</h3><p><img src="http://static.ifanze.cn/CD54EFF3-B554-46AE-9124-DC2D532DA5EE.jpeg" alt=""></p><ul><li><p>比较浮点值的大小可以转化成比较无符号整型的大小。（负数时需要一些技巧，见练习2.84）</p></li><li><p>一般属性：</p><ul><li>值+0.0总有一个全为0的位表示。</li><li>最小的正非规格化值的位表示：0 000..000 000..001。其中，<code>M = f = 2^(-n)</code>，<code>E = -2^(k-1) + 2</code>。</li><li>最大的非规格化值的位表示：0 000..000 111..111。其中，<code>M = f = 1 - 2^(-n)</code>，<code>E = -2^(k-1) + 2</code>。（仅仅比最小正规格化值小一点）</li><li>最小的正规格化值的位表示：0 000..001 000..000。其中，<code>M = 1+f = 1</code>，<code>E = -2^(k-1) + 2</code>。</li><li>值1.0的位表示：0 100..000 000..000。其中，<code>M = 1+f = 1</code>，<code>E = 0</code>。</li><li>最大的正规格化值的位表示：0 111..110 111..111。其中，<code>M = 1+f = 2 - 2^(-n)</code>，<code>E = 2^(k-1) - 1</code>。</li></ul></li><li><p>练习把整数值转换成浮点形式对理解浮点表示非常有用。</p></li></ul><h3 id="2-4-4-舍入（rounding）"><a href="#2-4-4-舍入（rounding）" class="headerlink" title="2.4.4 舍入（rounding）"></a>2.4.4 舍入（rounding）</h3><ul><li>四种舍入方式：<ul><li>向偶数舍入。（可避免统计偏差。浮点数同样可用。二进制同样可用。）</li><li>向零舍入。</li><li>向下舍入。</li><li>向上舍入。</li></ul></li></ul><h3 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h3><ul><li>IEEE标准定义了一些规则，如：1/-0 = 负无穷，1/+0 = 正无穷。</li><li>实数的加法可能由于溢出得到无穷值，实数加法是可交换、不可结合的。</li><li>大多数值在浮点加法下都有逆元，无穷和NaN是例外。</li><li>浮点加法满足了单调性属性。若<code>a&gt;=b</code>，对任意<code>x</code>，<code>x+a &gt;= x+b</code>。无符号或补码加法不具备这个实数（和整数）加法的属性。</li><li>浮点乘法是可交换、不可结合的，在加法上也不具备分配性。</li><li>对于任何a、b、c（均不为NaN），浮点乘法满足如下单调性：<code>a&gt;=b &amp;&amp; c &gt;=0 =&gt; a*c &gt;= b*c</code>、<code>a&gt;=b &amp;&amp; c&lt;=0 =&gt; a*c &lt;= b*c</code>。无符号或补码的乘法没有这些单调性属性。</li><li>只要<code>a!=NaN</code>，就有<code>a * a &gt;= 0</code>。无符号或补码的乘法没有这些单调性属性。</li></ul><h3 id="2-4-6-C语言中的浮点数"><a href="#2-4-6-C语言中的浮点数" class="headerlink" title="2.4.6 C语言中的浮点数"></a>2.4.6 C语言中的浮点数</h3><ul><li>单精度和双精度使用向偶数舍入的舍入方式。</li><li>C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到无穷、NaN、-0等数值。</li><li>GCC字长引入<code>#define _GNU_SOURCE 1 #include &lt;math.h&gt;</code>来定义<code>INFINITHY</code>和<code>NAN</code>。</li><li><code>int</code>、<code>float</code>、<code>doublie</code>的互转：<ul><li><code>int</code>转<code>float</code>：不会溢出，但可能被舍入。</li><li><code>int</code>或<code>float</code>转<code>double</code>：能保留精确的数值。</li><li><code>double</code>转<code>float</code>：可能舍入，可能溢出成无穷。</li><li><code>float</code>或<code>double</code>转<code>int</code>：向零舍入，也可能溢出。C标准没对溢出做要求，Intel系微处理器指定位模式[10…00]为整数不确定值（integer indefinite），如<code>(int)+1e10</code>会得到<code>-21483648</code>。</li></ul></li></ul><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 2.1 二进制/十六进制转换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.2 二进制/十进制/十六进制转换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.3 二进制/十进制/十六进制转换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.4 十六进制加减运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.5 整数的大小端存储。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.6 值相等的整数和浮点数在字节模式上的比较。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.7 字符串的字节模式。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.8 位向量的布尔运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.9 布尔运算与三原色。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.10 使用<code>^</code>实现两数交换。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.11 使用<code>^</code>交换同一地址的值时导致的问题。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.12 使用掩码提取或设置个别位上的状态。</li><li style="list-style: none"><input type="checkbox"></input> 2.13 使用“设置位”、“清除位”操作实现“或”和“异或”运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.14 布尔运算和逻辑运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.15 只使用位级和逻辑运算实现<code>x==y</code>。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.16 移位运算。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.17 无符号数的编码和补码编码。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.18 十六进制转补码转十进制。</li><li style="list-style: none"><input type="checkbox"></input> 2.19 有符号数转无符号数。</li><li style="list-style: none"><input type="checkbox"></input> 2.20 分析2.19。</li><li style="list-style: none"><input type="checkbox"></input> 2.21 有符号和无符号进行运算。</li><li style="list-style: none"><input type="checkbox"></input> 2.22 验证补码数的符号扩展规则。</li><li style="list-style: none"><input type="checkbox"></input> 2.23 移位和符号转换的综合运用。</li><li style="list-style: none"><input type="checkbox"></input> 2.24 截断数值。</li><li style="list-style: none"><input type="checkbox"></input> 2.25 有符号数和无符号数混用导致的错误。</li><li style="list-style: none"><input type="checkbox"></input> 2.26 有符号数和无符号数混用导致的错误。</li><li style="list-style: none"><input type="checkbox"></input> 2.27 判断两个无符号数相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.28 无符号数求反。</li><li style="list-style: none"><input type="checkbox"></input> 2.29 可能溢出的补码加法。</li><li style="list-style: none"><input type="checkbox"></input> 2.30 判断两个补码相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.31 判断两个补码相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.32 判断两个补码相加是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.33 补码的非。</li><li style="list-style: none"><input type="checkbox"></input> 2.34 无符号乘法和补码乘法。</li><li style="list-style: none"><input type="checkbox"></input> 2.35 判断乘法是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.36 判断乘法是否溢出。</li><li style="list-style: none"><input type="checkbox"></input> 2.37 修复XDR库乘法漏洞。</li><li style="list-style: none"><input type="checkbox"></input> 2.38 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.39 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.40 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.41 移位和加法替代乘法的应用。</li><li style="list-style: none"><input type="checkbox"></input> 2.42 实现一个“除以16”的函数。</li><li style="list-style: none"><input type="checkbox"></input> 2.43 乘除综合练习。</li><li style="list-style: none"><input type="checkbox"></input> 2.44 整数运算综合练习。</li><li style="list-style: none"><input type="checkbox"></input> 2.45 二进制小数的表示。</li><li style="list-style: none"><input type="checkbox"></input> 2.46 二进制小数不精确引发的灾难性后果。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.47 填表，浮点数值范围。</li><li style="list-style: none"><input type="checkbox"></input> 2.48 推导浮点的位。</li><li style="list-style: none"><input type="checkbox"></input> 2.49 浮点精度。</li><li style="list-style: none"><input type="checkbox" checked></input> 2.50 二进制浮点数舍入到偶数</li><li style="list-style: none"><input type="checkbox"></input> 2.51 二进制浮点数舍入引发的灾难性后果。</li><li style="list-style: none"><input type="checkbox"></input> 2.52 二进制浮点数表示与舍入综合。</li><li style="list-style: none"><input type="checkbox"></input> 2.53 定义双精度无穷和0值的宏。</li><li style="list-style: none"><input type="checkbox"></input> 2.54 整数和浮点混合计算题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》读书笔记 第二章 信息的表示和处理。&lt;br&gt;
    
    </summary>
    
      <category term="《深入理解计算机系统》" scheme="http://ifanze.cn/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》读书笔记 1</title>
    <link href="http://ifanze.cn/2018/06/21/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B(1)/"/>
    <id>http://ifanze.cn/2018/06/21/《深入理解计算机系统》(1)/</id>
    <published>2018-06-21T03:09:00.000Z</published>
    <updated>2018-06-24T12:10:17.283Z</updated>
    
    <content type="html"><![CDATA[<p>《深入理解计算机系统》读书笔记 第一章 计算机系统漫游。<br><a id="more"></a></p><h1 id="1-计算机系统漫游"><a href="#1-计算机系统漫游" class="headerlink" title="1 计算机系统漫游"></a>1 计算机系统漫游</h1><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h2><p>从一个 Hello World 程序开始。</p><h2 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h2><p><img src="http://static.ifanze.cn/059DE969-4B39-4DD9-90DD-D7A19456C064.jpeg" alt=""></p><h2 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h2><ul><li>优化程序性能。</li><li>理解链接错误。</li><li>避免安全漏洞。</li></ul><h2 id="1-4-处理器读并解释存储在内存中的指令"><a href="#1-4-处理器读并解释存储在内存中的指令" class="headerlink" title="1.4 处理器读并解释存储在内存中的指令"></a>1.4 处理器读并解释存储在内存中的指令</h2><p>shell 是一个命令行解释器。</p><h3 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h3><ol><li><p>总线</p><ul><li>携带信息字节并负责在各个部件间传递。</li><li>通常设计成传送定长的字节块，也就是 <strong>字（word）</strong>。</li><li>大多数机器字长要么是4字节（32位），要么是8字节（64位）。</li></ul></li><li><p>I/O设备</p><ul><li>系统与外部世界的联系通道。</li><li>每个I/O设备都通过 <strong>控制器</strong> 或者 <strong>适配器</strong> 与I/O总线相连。</li><li>控制器是I/O设备本身或者系统的主印制电路板（主板）上的芯片组。</li><li>适配器是一块插在主板上的卡。</li></ul></li><li><p>主存</p><ul><li>临时存储设备，处理器执行程序时，用来存放程序和程序处理的数据。</li><li>物理上，由一组 <strong>动态随机存取存储器（DRAM）</strong> 芯片组成。</li><li>逻辑上，是一个线性的字节数组，每个字节都有唯一的地址（从0开始）。</li></ul></li><li><p>处理器</p><ul><li>CPU，解释（或执行）存储在主存中指令的引擎。</li><li>核心是一个大小为一个字的存储设备（或寄存器），称为 <strong>程序计数器（PC）</strong>。</li><li>任何时刻，PC都指向主存中的某条机器语言指令。</li><li>处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由 <strong>指令集架构</strong> 决定的。</li><li><p>指令所对应的简单操作并不多，它们围绕着 <strong>主存</strong>、<strong>寄存器文件（register file）</strong> 和 <strong>算术/逻辑单元（ALU）</strong> 进行。这些操作包括：</p><ul><li>加载。</li><li>存储。</li><li>操作。</li><li>跳转。</li></ul></li><li><p>现代处理器使用了非常复杂的机制来加速程序的执行。注意区分：</p><ul><li><strong>处理器的指令集架构</strong>：每条机器代码指令的效果。</li><li><strong>处理器的微体系架构</strong>：处理器实际是如何实现的。</li></ul></li></ul></li></ol><h3 id="1-4-2-运行Hello程序"><a href="#1-4-2-运行Hello程序" class="headerlink" title="1.4.2 运行Hello程序"></a>1.4.2 运行Hello程序</h3><ol><li>shell将我们输入的<code>./hello</code>逐一读入寄存器，再把它放入内存。</li><li>敲回车时，shell知道我们结束了命令的输入。shell将执行一系列指令来加载可执行的<code>hello</code>文件，将目标文件中的代码和数据从磁盘复制到主存。<ul><li>注：利用 直接存储器存取（DMA）技术，数据可以不通过处理器而字节从磁盘到达主存。</li></ul></li><li>处理器开始执行main中的机器语言指令，这些指令将字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示在屏幕上。</li></ol><h2 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h2><ul><li>系统花费了大量时间把信息从一个地方挪到另一个地方。</li><li>根据机械原理，较大存储设备要比较小存储设备运行得慢，快速设备得造价远高于同类的低速设备。</li><li><strong>高速缓存存储器（cache memory）</strong>：作为暂时的集结区域，存放处理器近期可能会需要的信息。分为L1、L2、L3。</li></ul><h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p><img src="http://static.ifanze.cn/3DD2FD2F-67B1-4F21-A61B-5C13C9CD3ED5.jpeg" alt=""></p><h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><ul><li>shell 和 hello 程序都没有直接访问键盘、显示器、磁盘、主存等硬件，而是依靠操作系统提供服务。</li><li>操作系统的两个基本功能：<ul><li>防止硬件被失控的应用程序滥用。</li><li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li></ul></li><li>操作系统使用以下几个抽象概念来实现这两个基本功能：<ul><li><strong>文件</strong>：对I/O设备的抽象。</li><li><strong>虚拟内存</strong>：对主存和磁盘I/O设备的抽象。</li><li><strong>进程</strong>：对处理器、主存和I/O设备的抽象。</li></ul></li></ul><h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><ul><li>操作系统为程序提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和I/O设备。</li><li><strong>并发运行</strong>：一个进程的指令和另一个进程的指令是交错执行的。</li><li><strong>上下文</strong>：操作系统保持跟踪进程运行所需的所有状态信息。</li><li><strong>上下文切换</strong>：操作系统把处理器的控制权从当前进程转移到某个新进程。它是由内核（kernel）管理的。</li><li><strong>内核</strong>：操作系统代码常驻内存的部分，不是一个独立的进程，时系统管理全部进程所用代码和数据结构的集合。</li><li>当应用程序需要操作系统的某些操作时，比如读写文件，它就执行一条特殊的 <strong>系统调用（system call）</strong> 指令，将控制权传递给内核，内核执行请求并返回应用程序。</li></ul><h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><ul><li>多线程比多进程更容易共享数据。</li><li>往往比进程更高效。</li></ul><h3 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h3><ul><li>Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的。</li></ul><p><img src="http://static.ifanze.cn/6C8172FF-0CB9-42A7-BCD6-9388D1DAEB11.jpeg" alt=""></p><ul><li>区：<ul><li><strong>程序代码和数据</strong>。代码从一个固定地址开始，紧接着C全局变量。是直接按照可执行目标文件的内容初始化的。</li><li><strong>堆</strong>。</li><li><strong>共享库</strong>。</li><li><strong>栈</strong>。</li><li><strong>内核虚拟内存</strong>。为内核保留，不允许应用程序读写或直接调用内核代码定义的函数，必须调用内核来执行这些操作。</li></ul></li></ul><h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><ul><li>文件就是字节序列。</li><li>每个I/O设备，包括磁盘、键盘、显示器、网络，等可以看成文件。</li></ul><h2 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h2><p><img src="http://static.ifanze.cn/65C98DBF-964A-42AA-AA0D-D99FB6B74B92.jpeg" alt=""></p><h2 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h2><h3 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h3><ul><li>思想：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li></ul><blockquote><p>若系统执行某应用程序需要时间为<code>T-old</code>，假设系统某部分所需执行时间与该时间的比例为<code>a</code>，而该部分性能提升比例为<code>k</code>。由此计算加速比：<br><code>S = T-old/T-new = 1 / ((1-a) + a/k)</code></p></blockquote><h3 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h3><ul><li><strong>并发（concurrency）</strong>：同时具有多个活动的系统。</li><li><strong>并行（parallelism）</strong>：用并发来使一个系统运行得更快。</li></ul><p>并行可以用在计算机系统的多个抽象层次上：</p><ol><li><p>线程级并发</p><ul><li>单处理器系统。</li><li>多处理系统。<ul><li>多核处理器。<img src="http://static.ifanze.cn/6CBC7CD7-5628-480C-A7FC-E9F9CF441ACA.jpeg" alt=""></li><li>超线程（hyperthreading），或称同时多线程（simultaneous multi-threading）。允许一个CPU执行多个控制流，它涉及到CPU某些硬件有多个备份，如程序计数器、寄存器文件。</li></ul></li></ul></li><li><p>指令级并行</p><ul><li>早期处理器，执行一条指令需要3~10个时钟周期。</li><li>现在的处理器使用了许多聪明的技巧来同时处理多达100条指令。</li><li><strong>流水线（piplining）</strong>：将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤，这些阶段可以并行地操作。</li><li>如果处理器可以达到比一个周期一条指令更快地执行速率，就称之为 <strong>超标量（super-scalar）处理器</strong>。</li></ul></li><li><p>单指令、多数据并行（SIMD并行）</p><ul><li>在最低层次上，许多现代处理器拥有特殊地硬件，允许一条指令产生多个可以并行执行地操作。</li><li>可以提高对影像、声音、视频数据地处理效率。</li><li>有些编译器会试图从C程序中自动抽取SIMD并行性，但更好地方法是用编译器支持地特殊向量数据类型来写程序。</li></ul></li></ol><h3 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h3><ul><li>再增加一个抽象：虚拟机，是对整个计算机的抽象，包括操作系统、处理器和程序。</li></ul><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><ul><li style="list-style: none"><input type="checkbox" checked></input> 1.1 Amdahl定律公式的应用</li><li style="list-style: none"><input type="checkbox" checked></input> 1.2 Amdahl定律公式的应用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《深入理解计算机系统》读书笔记 第一章 计算机系统漫游。&lt;br&gt;
    
    </summary>
    
      <category term="《深入理解计算机系统》" scheme="http://ifanze.cn/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="linux" scheme="http://ifanze.cn/tags/linux/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>libevent笔记</title>
    <link href="http://ifanze.cn/2018/04/16/libevent%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifanze.cn/2018/04/16/libevent笔记/</id>
    <published>2018-04-16T03:18:48.000Z</published>
    <updated>2018-09-08T09:08:34.067Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/nmathewson/libevent-book">https://github.com/nmathewson/libevent-book</a></p><a id="more"></a><!-- toc --><p>Libevent is a library for writing fast portable nonblocking IO. </p><h1 id="1-Design-Goals"><a href="#1-Design-Goals" class="headerlink" title="1 Design Goals"></a>1 Design Goals</h1><ul><li>Portability</li><li>Speed</li><li>Scalability</li><li>Convenience</li></ul><h1 id="2-Components"><a href="#2-Components" class="headerlink" title="2 Components"></a>2 Components</h1><ul><li>evutil</li><li>event &amp; event_base</li><li>bufferevent</li><li>evbuffer</li><li>evhttp</li><li>evdns</li><li>evrpc</li></ul><h1 id="3-Libraries"><a href="#3-Libraries" class="headerlink" title="3 Libraries"></a>3 Libraries</h1><ul><li>libevent_core</li><li>libevent_extra</li><li>libevent [outdated]</li><li>libevent_pthreads</li><li>libevent_openssl</li></ul><h1 id="4-Headers"><a href="#4-Headers" class="headerlink" title="4 Headers"></a>4 Headers</h1><ul><li>API headers</li><li>Compatibility headers</li><li>Structure headers</li></ul><h1 id="5-Setup"><a href="#5-Setup" class="headerlink" title="5 Setup"></a>5 Setup</h1><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_log_callback</span><span class="params">(event_log_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_log_cb)(int severity, const char *msg);</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_DEBUG 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_MSG   1</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_WARN  2 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_ERR   3 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_logging</span><span class="params">(<span class="keyword">ev_uint32_t</span> which)</span></span>;</span><br><span class="line"><span class="comment">// #define EVENT_DBG_NONE 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_DBG_ALL 0xffffffffu</span></span><br></pre></td></tr></table></figure><h2 id="Handle-Error"><a href="#Handle-Error" class="headerlink" title="Handle Error"></a>Handle Error</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_fatal_callback</span><span class="params">(event_fatal_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_fatal_cb)(int err);</span></span><br></pre></td></tr></table></figure><h2 id="Manage-Memory"><a href="#Manage-Memory" class="headerlink" title="Manage Memory"></a>Manage Memory</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_mem_functions</span><span class="params">(</span></span></span><br><span class="line">    void *(*malloc_fn)(size_t sz),</span><br><span class="line">    <span class="keyword">void</span> *(*realloc_fn)(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz),</span><br><span class="line">    <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr));</span><br></pre></td></tr></table></figure><h2 id="Locks-and-threading"><a href="#Locks-and-threading" class="headerlink" title="Locks and threading"></a>Locks and threading</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef WIN32</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_windows_threads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef _EVENT_HAVE_PTHREAD</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_pthreads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_PTHREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_lock_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_lock_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_lock_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int lock_api_version; </span></span><br><span class="line"><span class="comment">//     unsigned supported_locktypes; </span></span><br><span class="line"><span class="comment">//     void *(*alloc)(unsigned locktype); </span></span><br><span class="line"><span class="comment">//     void (*free)(void *lock, unsigned locktype); </span></span><br><span class="line"><span class="comment">//     int (*lock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">//     int (*unlock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define EVTHREAD_WRITE  0x04 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_READ   0x08 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_TRY    0x10</span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_RECURSIVE 1 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_READWRITE 2 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCK_API_VERSION 1 </span></span><br><span class="line"></span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_condition_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_condition_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_condition_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int condition_api_version; </span></span><br><span class="line"><span class="comment">//     void *(*alloc_condition)(unsigned condtype); </span></span><br><span class="line"><span class="comment">//     void (*free_condition)(void *cond); </span></span><br><span class="line"><span class="comment">//     int (*signal_condition)(void *cond, int broadcast); </span></span><br><span class="line"><span class="comment">//     int (*wait_condition)(void *cond, void *lock, const struct timeval *timeout); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_enable_lock_debugging</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_debug_unassign</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Detect-Version"><a href="#Detect-Version" class="headerlink" title="Detect Version"></a>Detect Version</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION_NUMBER 0x02000300 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION <span class="meta-string">"2.0.3-alpha"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_get_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">ev_uint32_t</span> event_get_version_number(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><h2 id="Free-global-structures"><a href="#Free-global-structures" class="headerlink" title="Free global structures"></a>Free global structures</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">libevent_global_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="6-event-base"><a href="#6-event-base" class="headerlink" title="6 event_base"></a>6 event_base</h1><h2 id="Recognized-backend"><a href="#Recognized-backend" class="headerlink" title="Recognized backend"></a>Recognized backend</h2><ul><li>select</li><li>poll</li><li>epoll</li><li>kqueue</li><li>devpoll</li><li>evport</li><li>win32</li></ul><h2 id="Turn-off"><a href="#Turn-off" class="headerlink" title="Turn off"></a>Turn off</h2><ul><li>Set environment variables. e.g. <code>EVENT_NOKQUEUE</code>.</li><li>Call <code>event_config_avoid_method()</code> below.</li></ul><h2 id="New-amp-free-amp-reinit"><a href="#New-amp-free-amp-reinit" class="headerlink" title="New &amp; free &amp; reinit"></a>New &amp; free &amp; reinit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_free</span><span class="params">(struct event_base *base)</span></span>;  <span class="comment">// 不会 deallocate any of the events that are currently associated with the event_base, or close any of their sockets, or free any of their pointers.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;      <span class="comment">// call after fork() in child proc</span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure><h2 id="New-with-event-config"><a href="#New-with-event-config" class="headerlink" title="New with event_config"></a>New with event_config</h2><p>To avoid specific available backend by name, or by feature.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_config *<span class="title">event_config_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct event_base <span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_config_free</span><span class="params">(struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg,<span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_require_features</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_method_feature feature)</span></span>;</span><br><span class="line"><span class="comment">// enum event_method_feature &#123;     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_ET = 0x01,    (支持边缘触发。)</span></span><br><span class="line"><span class="comment">//     EV_FEATURE_O1 = 0x02,    (增/删一个 event, 或激活一个 event 都能在O(1)完成。) (Windows 上没有。)</span></span><br><span class="line"><span class="comment">//     EV_FEATURE_FDS = 0x04,   (支持通用的文件描述符，不止 socket。) (Linux 上不能和 O(1) 同时满足。)</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_flag</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_base_config_flag flag)</span></span>;</span><br><span class="line"><span class="comment">// enum event_base_config_flag &#123;</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NOLOCK = 0x01,                   (不在 event_base 上使用锁，换取性能。)</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_IGNORE_ENV = 0x02,               (不检查 EVENT_* 环境变量，不推荐)</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,             (On Windows only, this flag makes Libevent enable any necessary IOCP dispatch logic on startup, rather than on-demand.)</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,            (每个 timeout callback 后检查时间，更耗性能。)</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,     (同环境变量EVENT_EPOLL_USE_CHANGELIST，允许使用更快速的 "changelist"-based backend，但这种方式可能会触发内核 bug)</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_PRECISE_TIMER = 0x20             （使用 slower-but-more-precise 的计时，前提是系统支持）</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_num_cpus_hint</span><span class="params">(struct event_config *cfg, <span class="keyword">int</span> cpus)</span>      <span class="comment">// 目前只对使用了 IOCP 的 Windows 有用，指定 multithreading 中最大可利用的 CPU 核数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_max_dispatch_interval</span><span class="params">(struct event_config *cfg, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timeval *max_interval, <span class="keyword">int</span> max_callbacks, <span class="keyword">int</span> min_priority)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">event_get_supported_methods</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">enum</span> event_method_feature <span class="title">event_base_get_features</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>;   <span class="comment">// 与 EV_FEATURE_ET、EV_FEATURE_O1、EV_FEATURE_FDS 进行 &amp; 运算。</span></span><br><span class="line">event_get_method()          <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure><h2 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> n_priorities)</span></span>;    <span class="comment">// 优先级数量：1 ~ EVENT_MAX_PRIORITIES，但优先级本身是从 0 开始的。这个函数必须在任何事件前调用！事件默认值为 n_priorities / 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_get_npriorities</span><span class="params">(struct event_base *base)</span></span>;                    <span class="comment">// 返回设定值。</span></span><br><span class="line">event_priority_init()       <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure><h1 id="7-Event-loop"><a href="#7-Event-loop" class="headerlink" title="7 Event loop"></a>7 Event loop</h1><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>default: run until no more events registered in it.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="comment">// #define EVLOOP_ONCE             0x01 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NONBLOCK         0x02 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br></pre></td></tr></table></figure><h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct timeval *tv)</span></span>;     <span class="comment">// exit after all active events cb done.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;  <span class="comment">// exit after current one cb done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_exit</span><span class="params">(struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_break</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopcontinue</span><span class="params">(struct event_base *)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="internal-time-cache"><a href="#internal-time-cache" class="headerlink" title="internal time cache"></a>internal time cache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_gettimeofday_cached</span><span class="params">(struct event_base *base, struct timeval *tv_out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_update_cache_time</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="dump-status"><a href="#dump-status" class="headerlink" title="dump status"></a>dump status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_dump_events</span><span class="params">(struct event_base *base, FILE *f)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="iterate-events"><a href="#iterate-events" class="headerlink" title="iterate events"></a>iterate events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_foreach_event</span><span class="params">(struct event_base *base, event_base_foreach_event_cb fn, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// typedef int (*event_base_foreach_event_cb)(const struct event_base *, const struct event *, void *)</span></span><br></pre></td></tr></table></figure><h2 id="obsolete-methods"><a href="#obsolete-methods" class="headerlink" title="obsolete methods"></a>obsolete methods</h2><ul><li><code>event_dispatch()</code></li><li><code>event_loop()</code></li><li><code>event_loopexit()</code></li><li><code>event_loopbreak()</code></li></ul><h1 id="8-Events"><a href="#8-Events" class="headerlink" title="8 Events"></a>8 Events</h1><h2 id="conditions"><a href="#conditions" class="headerlink" title="conditions:"></a>conditions:</h2><ul><li>fd being ready to read from or write to.</li><li>fd becoming ready to read from or write to (Edge-triggered IO only).</li><li>a timeout expiring.</li><li>a signal occuring.</li><li>a user-triggered event.</li></ul><h2 id="status"><a href="#status" class="headerlink" title="status:"></a>status:</h2><ul><li>initialized -&gt; pending (by <code>add</code>)</li><li>pending -&gt; active (condition trigger an event occur, cb run)</li><li>active -&gt; pending (persistent) -&gt; <code>delete</code> -&gt; non-pending -&gt; <code>add</code> -&gt; pending</li><li>active -&gt; non-pending (non-persistent)</li></ul><h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, event_callback_fn cb, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="comment">// typedef void (*event_callback_fn)(evutil_socket_t, short, void *); </span></span><br><span class="line"><span class="comment">// #define EV_TIMEOUT      0x01 </span></span><br><span class="line"><span class="comment">// #define EV_READ         0x02 </span></span><br><span class="line"><span class="comment">// #define EV_WRITE        0x04 </span></span><br><span class="line"><span class="comment">// #define EV_SIGNAL       0x08 </span></span><br><span class="line"><span class="comment">// #define EV_PERSIST      0x10 </span></span><br><span class="line"><span class="comment">// #define EV_ET           0x20 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *event)</span></span>;</span><br></pre></td></tr></table></figure><p>You can’t create an event that receives itself as a cb argument. Instead:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_self_cbarg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Timeout-only-events"><a href="#Timeout-only-events" class="headerlink" title="Timeout-only events"></a>Timeout-only events</h2><p>no benefit beyond clarifying your code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(base, callback, arg) \     </span></span><br><span class="line">event_new((base), <span class="number">-1</span>, <span class="number">0</span>, (callback), (arg)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv) \    </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_pending(ev, tv_out) \     </span></span><br><span class="line">event_pending((ev), EV_TIMEOUT, (tv_out))</span><br></pre></td></tr></table></figure><h2 id="Signal-events"><a href="#Signal-events" class="headerlink" title="Signal events"></a>Signal events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(base, signum, cb, arg) \     </span></span><br><span class="line">event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv) \     </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, what, tv_out) \     </span></span><br><span class="line">event_pending((ev), (what), (tv_out))</span><br></pre></td></tr></table></figure><ul><li>Don’t set a timeout on a signal event.</li><li>It’s safe to call functions that you aren’t supposed to call from a regulat POSIX signal handler.</li><li>With most backends, only one event_base per process at a time can be listening for signals. If you add signal events to two event_base at once - even if the signals are different - only one event_base will receive signals. (kqueue doesn’t have this limitation.)</li></ul><h2 id="Heap-allocation-events"><a href="#Heap-allocation-events" class="headerlink" title="Heap-allocation events"></a>Heap-allocation events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int event_assign(struct event *event, struct event_base *base, evutil_socket_t fd, short what, void (*callback)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_assign(event, base, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, <span class="number">-1</span>, <span class="number">0</span>, callback, arg) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(event, base, signum, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, signum, EV_SIGNAL|EV_PERSIST, callback, arg)</span><br></pre></td></tr></table></figure><ul><li>Your code won’t be binary-compatible with future versions of libevent as the size of a event may differ. To check, make use of this function:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> event_get_struct_event_size(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure><ul><li>May return a value less than <code>sizeof(event)</code> because of padding bytes at the end.</li><li>Never call <code>event_assign</code> on an event that is already pending. call <code>event_del()</code> first.</li></ul><h2 id="Pending-and-Non-pending"><a href="#Pending-and-Non-pending" class="headerlink" title="Pending and Non-pending"></a>Pending and Non-pending</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_remove_timer</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *event, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Inspecting-Event-Status"><a href="#Inspecting-Event-Status" class="headerlink" title="Inspecting Event Status"></a>Inspecting Event Status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, <span class="keyword">short</span> what, struct timeval *tv_out)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> event_get_fd(<span class="keyword">const</span> struct event *ev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; <span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event, struct event_base **base_out, <span class="keyword">evutil_socket_t</span> *fd_out, <span class="keyword">short</span> *events_out, event_callback_fn *callback_out, <span class="keyword">void</span> **arg_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event *<span class="title">event_base_get_running_event</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="One-off-events"><a href="#One-off-events" class="headerlink" title="One-off events"></a>One-off events</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure><ul><li>If you don’t need to add an event more than once, or delete it once it has been added, and it doesn’t have to persistent, use <code>event_base_once</code>.</li><li>It doesn’t support <code>EV_SIGNAL</code> or <code>EV_PERSIST</code>.</li><li>Can’t be deleted or manually activated.</li></ul><h2 id="Manually-activating-an-event"><a href="#Manually-activating-an-event" class="headerlink" title="Manually activating an event"></a>Manually activating an event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *ev, <span class="keyword">int</span> what, <span class="keyword">short</span> ncalls)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Don’t calling <code>event_active</code> recursively on the same event.</li></ul><h2 id="Optimizing-common-timeouts"><a href="#Optimizing-common-timeouts" class="headerlink" title="Optimizing common timeouts"></a>Optimizing common timeouts</h2><ul><li>Libevent use a binary algorithm to keep track of pending events’ timeouts, which gives performance of O(lg n) for adding and deleting each event timeout.</li><li>If you have a large number of events with the same timeout, a doubly-linked queue will be better.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct timeval *<span class="title">event_base_init_common_timeout</span><span class="params">( struct event_base *base, <span class="keyword">const</span> struct timeval *duration)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Distinguish-an-initialized-event-and-a-cleared-event"><a href="#Distinguish-an-initialized-event-and-a-cleared-event" class="headerlink" title="Distinguish an initialized event and a cleared event"></a>Distinguish an initialized event and a cleared event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_initialized</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_initialized(ev) event_initialized(ev) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_initialized(ev) event_initialized(ev)</span></span><br></pre></td></tr></table></figure><h1 id="9-Helper"><a href="#9-Helper" class="headerlink" title="9 Helper"></a>9 Helper</h1><h2 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h2><ul><li><p>evutil_socket_t  </p></li><li><p>ev_uint64_t       EV_UINT64_MAX       0</p></li><li>ev_int64_t        EV_INT64_MAX        EV_INT64_MIN</li><li>ev_uint32_t       EV_UINT32_MAX       0</li><li>ev_int32_t        EV_INT32_MAX        EV_INT32_MIN</li><li>ev_uint16_t       EV_UINT16_MAX       0</li><li>ev_int16_t        EV_INT16_MAX        EV_INT16_MIN</li><li>ev_uint8_t        EV_UINT8_MAX        0</li><li><p>ev_int8_t         EV_INT8_MAX         EV_INT8_MIN</p></li><li><p>ev_ssize_t        EV_SSIZE_MIN        EV_SSIZE_MAX</p></li><li>ev_off_t          </li><li>ev_socket_t</li><li>ev_intptr_t</li><li>ev_uintptr_t</li></ul><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timeradd(tvp, uvp, vvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timersub(tvp, uvp, vvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerisset(tvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timercmp(tvp, uvp, cmp)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_closesocket</span><span class="params">(<span class="keyword">evutil_socket_t</span> s)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SOCKET_ERROR() </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SET_SOCKET_ERROR(errcode) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_geterror(sock) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_error_to_string(errcode)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_nonblocking</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_listen_socket_reuseable</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_closeonexec</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">evutil_socket_t</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_int64_t</span> evutil_strtoll(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">char</span> **endptr, <span class="keyword">int</span> base);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_snprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strcasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strncasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">evutil_inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_parse_sockaddr_port</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, struct sockaddr *out, <span class="keyword">int</span> *outlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_sockaddr_cmp</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa1, <span class="keyword">const</span> struct sockaddr *sa2, <span class="keyword">int</span> include_port)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_offsetof(type, field) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_get_bytes</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_secure_rng_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_add_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dat, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="10-Bufferevents"><a href="#10-Bufferevents" class="headerlink" title="10 Bufferevents"></a>10 Bufferevents</h1><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><ul><li>socket-based bufferevents</li><li>asynchronous-IO bufferevents (Windows IOCP only, experimental)</li><li>filtering bufferevents (for example, to compress or translate data)</li><li>paired bufferevents (two bufferevents transmit data to one another)</li></ul><h2 id="BufferEvents-and-evbuffers"><a href="#BufferEvents-and-evbuffers" class="headerlink" title="BufferEvents and evbuffers"></a>BufferEvents and evbuffers</h2><ul><li><code>&lt;event2/bufferevent.h&gt;</code></li><li><code>&lt;event2/buffer.h&gt;</code></li><li>Every bufferevent has an input buffer and an output buffer. These are of type “struct evbuffer”. </li><li>Every bufferevent has two data-related callbacks: a read callback and a write callback. </li></ul><h2 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h2><ul><li>The read callback is called whenever any data is read from the underlying transport.</li><li>The write callback is called whenever enough data from the output buffer is emptied to the underlying transport.</li></ul><h2 id="Watermarks"><a href="#Watermarks" class="headerlink" title="Watermarks"></a>Watermarks</h2><ul><li>Read low-water mark (defaults to 0)</li><li>Read high-water mark (defaults to unlimited)</li><li>Write low-water mark (defaults to 0)</li><li>Write high-water mark (have special meaning in filtering bufferevents)</li></ul><h2 id="Callbacks-1"><a href="#Callbacks-1" class="headerlink" title="Callbacks"></a>Callbacks</h2><p>When a connection is closed or an error occurs. Flags:</p><ul><li><code>BEV_EVENT_READING</code></li><li><code>BEV_EVENT_WRITING</code></li><li><code>BEV_EVENT_ERROR</code></li><li><code>BEV_EVENT_TIMEOUT</code></li><li><code>BEV_EVENT_EOF</code></li><li><code>BEV_EVENT_CONNECTED</code></li></ul><h2 id="Deferred-callbacks"><a href="#Deferred-callbacks" class="headerlink" title="Deferred callbacks"></a>Deferred callbacks</h2><p>By default, bufferevent and evbuffer ‘s callbacks are executed <strong>immediately</strong>. But it may make trouble. </p><p>For example, one callback moves data into evbuffer A when it grows empty, and another one put data out of A when it grows full. You may risk a stack overflow if the dependency grows nasty enough.</p><p>To solve this, you can use deferred callbacks. It is queued as part of the <code>event_loop()</code>, and invoked after the regular events’ callbacks.</p><h2 id="Option-Flags"><a href="#Option-Flags" class="headerlink" title="Option Flags"></a>Option Flags</h2><ul><li><code>BEV_OPT_CLOSE_ON_FREE</code>: When the bufferevent is freed, close the underlying transport, such as socket.</li><li><code>BEV_OPT_THREADSAFE</code></li><li><code>BEV_OPT_DEFER_CALLBACKS</code></li><li><code>BEV_OPT_UNLOCK_CALLBACKS</code>: When threadsafe is set and invoking the user-provided callback, release the lock.</li></ul><h1 id="11-Socket-based-Bufferevents"><a href="#11-Socket-based-Bufferevents" class="headerlink" title="11 Socket-based Bufferevents"></a>11 Socket-based Bufferevents</h1><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">enum</span> bufferevent_options options)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>fd 需要是 non-blocking 的，可以使用<code>evutil_make_socket_nonblocking()</code>。</li><li>不想现在指定 fd 可以将其设为 -1。</li></ul><h2 id="Launch"><a href="#Launch" class="headerlink" title="Launch"></a>Launch</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, struct sockaddr *address, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect_hostname</span><span class="params">(struct bufferevent *bev, struct evdns_base *dns_base, <span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">int</span> port)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_get_dns_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>If no socket set, it will allocates a new nonblocking one.</li></ul><h2 id="Generic-operations"><a href="#Generic-operations" class="headerlink" title="Generic operations"></a>Generic operations</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_getcb</span><span class="params">(struct bufferevent *bufev, bufferevent_data_cb *readcb_ptr, bufferevent_data_cb *writecb_ptr, bufferevent_event_cb *eventcb_ptr, <span class="keyword">void</span> **cbarg_ptr)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx); </span></span><br><span class="line"><span class="comment">// typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>; <span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>; <span class="comment">// EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>; <span class="comment">// EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setwatermark</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events, <span class="keyword">size_t</span> lowmark, <span class="keyword">size_t</span> highmark)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>bufferevent_free</code> will free the bufferevent as soon as possible, probably won’t flush data on write buffer.</li><li><code>BEV_OPT_CLOSE_ON_FREE</code> will close its transport underlying it - such as socket - when free.</li><li>By default, a newly created bufferevent has writing enabled, but not reading. </li></ul><h2 id="Manipulate-Data"><a href="#Manipulate-Data" class="headerlink" title="Manipulate Data"></a>Manipulate Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_input</span><span class="params">(struct bufferevent *bufev)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_output</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> bufferevent_read(struct bufferevent *bufev, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size); </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_read_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_set_timeouts</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> struct timeval *timeout_read, <span class="keyword">const</span> struct timeval *timeout_write)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_flush</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> iotype, <span class="keyword">enum</span> bufferevent_flush_mode state)</span></span>; </span><br><span class="line"><span class="comment">// iotype: EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="comment">// state: BEV_NORMAL, BEV_FLUSH, or BEV_FINISHED</span></span><br></pre></td></tr></table></figure><ul><li>It won’t be timeout if r/w is disabled or no data to r/w.</li><li>If timeout, invoke cb with <code>BEV_EVENT_TIMEOUT|BEV_EVENT_READING</code> or <code>BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING</code>.</li></ul><h2 id="Type-specific-functions"><a href="#Type-specific-functions" class="headerlink" title="Type-specific functions"></a>Type-specific functions</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket-based only</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_priority_set</span><span class="params">(struct bufferevent *bufev, <span class="keyword">int</span> pri)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_get_priority</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_setfd</span><span class="params">(struct bufferevent *bufev, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="keyword">evutil_socket_t</span> bufferevent_getfd(struct bufferevent *bufev);</span><br><span class="line"></span><br><span class="line"><span class="function">struct event_base *<span class="title">bufferevent_get_base</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_get_underlying</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Locking-and-Unlocking"><a href="#Locking-and-Unlocking" class="headerlink" title="Locking and Unlocking"></a>Locking and Unlocking</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_lock</span><span class="params">(struct bufferevent *bufev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_unlock</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Required threading support activated and <code>BEV_OPT_THREADSAFE</code> on creation.</li></ul><h1 id="12-Bufferevents-Advanced-topics"><a href="#12-Bufferevents-Advanced-topics" class="headerlink" title="12 Bufferevents: Advanced topics"></a>12 Bufferevents: Advanced topics</h1><h2 id="Paired-bufferevents"><a href="#Paired-bufferevents" class="headerlink" title="Paired bufferevents"></a>Paired bufferevents</h2><p>All bytes written on one are received on the other, without via the network stack.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_pair_new</span><span class="params">(struct event_base *base, <span class="keyword">int</span> options, struct bufferevent *pair[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_pair_get_partner</span><span class="params">(struct bufferevent *bev)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>BEV_OPT_CLOSE_ON_FREE</code> has no effect.</li><li><code>BEV_OPT_DEFER_CALLBACKS</code> is always on.</li></ul><h2 id="Filtering-bufferevents"><a href="#Filtering-bufferevents" class="headerlink" title="Filtering bufferevents"></a>Filtering bufferevents</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct bufferevent *bufferevent_filter_new(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void (*free_context)(void *), void *ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum bufferevent_filter_result &#123;         </span></span><br><span class="line"><span class="comment">//     BEV_OK = 0,         </span></span><br><span class="line"><span class="comment">//     BEV_NEED_MORE = 1,         </span></span><br><span class="line"><span class="comment">//     BEV_ERROR = 2 </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"><span class="comment">// typedef enum bufferevent_filter_result (*bufferevent_filter_cb)( </span></span><br><span class="line"><span class="comment">//     struct evbuffer *source, </span></span><br><span class="line"><span class="comment">//     struct evbuffer *destination, </span></span><br><span class="line"><span class="comment">//     ev_ssize_t dst_limit, </span></span><br><span class="line"><span class="comment">//     enum bufferevent_flush_mode mode, </span></span><br><span class="line"><span class="comment">//     void *ctx</span></span><br><span class="line"><span class="comment">// );</span></span><br></pre></td></tr></table></figure><h2 id="Limit-max-single-r-w-size"><a href="#Limit-max-single-r-w-size" class="headerlink" title="Limit max single r/w size"></a>Limit max single r/w size</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_max_single_read</span><span class="params">(struct bufferevent *bev, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_max_single_write</span><span class="params">(struct bufferevent *bev, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_single_read(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_single_write(struct bufferevent *bev);</span><br></pre></td></tr></table></figure><h2 id="Rate-limiting"><a href="#Rate-limiting" class="headerlink" title="Rate-limiting"></a>Rate-limiting</h2><p>algorithm: token bucket.</p><ul><li>read bucket &amp; write bucket.</li><li>refill rate: determines the max average rate.</li><li>max burst size: determines the max number of bytes that will be r/w in a single burst.</li><li>timing unit: smoothness of the traffic.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_RATE_LIMIT_MAX EV_SSIZE_MAX </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ev_token_bucket_cfg</span>;</span> </span><br><span class="line"><span class="function">struct ev_token_bucket_cfg *<span class="title">ev_token_bucket_cfg_new</span><span class="params">(         </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> read_rate, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> read_burst,         </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> write_rate, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> write_burst, c</span></span></span><br><span class="line"><span class="function"><span class="params">    onst struct timeval *tick_len</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_token_bucket_cfg_free</span><span class="params">(struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_rate_limit</span><span class="params">(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Rate-limiting-on-group"><a href="#Rate-limiting-on-group" class="headerlink" title="Rate-limiting on group"></a>Rate-limiting on group</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_rate_limit_group</span>;</span> </span><br><span class="line"><span class="function">struct bufferevent_rate_limit_group *<span class="title">bufferevent_rate_limit_group_new</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_set_cfg</span><span class="params">(struct bufferevent_rate_limit_group *group, <span class="keyword">const</span> struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_free</span><span class="params">(struct bufferevent_rate_limit_group *)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_add_to_rate_limit_group</span><span class="params">(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_remove_from_rate_limit_group</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Inspecting-rate-limiting"><a href="#Inspecting-rate-limiting" class="headerlink" title="Inspecting rate-limiting"></a>Inspecting rate-limiting</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_read_limit(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_write_limit(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_rate_limit_group_get_read_limit( struct bufferevent_rate_limit_group *); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_rate_limit_group_get_write_limit( struct bufferevent_rate_limit_group *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_to_read(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_to_write(struct bufferevent *bev);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_get_totals</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_uint64_t</span> *total_read_out, <span class="keyword">ev_uint64_t</span> *total_written_out)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_reset_totals</span><span class="params">( struct bufferevent_rate_limit_group *grp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Manually-adjusting-rate-limits"><a href="#Manually-adjusting-rate-limits" class="headerlink" title="Manually adjusting rate limits"></a>Manually adjusting rate limits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_decrement_read_limit</span><span class="params">(struct bufferevent *bev, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_decrement_write_limit</span><span class="params">(struct bufferevent *bev, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_decrement_read</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_decrement_write</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_ssize_t</span> decr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Setting-the-smallest-share-possible-in-a-rate-limited-group"><a href="#Setting-the-smallest-share-possible-in-a-rate-limited-group" class="headerlink" title="Setting the smallest share possible in a rate-limited group "></a>Setting the smallest share possible in a rate-limited group </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_set_min_share</span><span class="params">( struct bufferevent_rate_limit_group *group, <span class="keyword">size_t</span> min_share)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Bufferevents-and-SSL"><a href="#Bufferevents-and-SSL" class="headerlink" title="Bufferevents and SSL"></a>Bufferevents and SSL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bufferevent_ssl_state &#123;         </span><br><span class="line">    BUFFEREVENT_SSL_OPEN = <span class="number">0</span>,         </span><br><span class="line">    BUFFEREVENT_SSL_CONNECTING = <span class="number">1</span>,         </span><br><span class="line">    BUFFEREVENT_SSL_ACCEPTING = <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_openssl_filter_new</span><span class="params">(struct event_base *base, struct bufferevent *underlying, SSL *ssl, <span class="keyword">enum</span> bufferevent_ssl_state state, <span class="keyword">int</span> options)</span></span>; </span><br><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_openssl_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, SSL *ssl, <span class="keyword">enum</span> bufferevent_ssl_state state, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SSL *<span class="title">bufferevent_openssl_get_ssl</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">bufferevent_get_openssl_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_ssl_renegotiate</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_openssl_get_allow_dirty_shutdown</span><span class="params">(struct bufferevent *bev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_openssl_set_allow_dirty_shutdown</span><span class="params">(struct bufferevent *bev, <span class="keyword">int</span> allow_dirty_shutdown)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="13-Evbuffers"><a href="#13-Evbuffers" class="headerlink" title="13 Evbuffers"></a>13 Evbuffers</h1><h2 id="Create-amp-free"><a href="#Create-amp-free" class="headerlink" title="Create &amp; free"></a>Create &amp; free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">evbuffer_new</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_free</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Thread-Safety"><a href="#Thread-Safety" class="headerlink" title="Thread-Safety"></a>Thread-Safety</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_enable_locking</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *lock)</span></span>;  <span class="comment">// NULL is legal, it will allocate a new lock.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_lock</span><span class="params">(struct evbuffer *buf)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_unlock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Inspecting-an-evbuffer"><a href="#Inspecting-an-evbuffer" class="headerlink" title="Inspecting an evbuffer"></a>Inspecting an evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_length(<span class="keyword">const</span> struct evbuffer *buf);</span><br><span class="line"><span class="keyword">size_t</span> evbuffer_get_contiguous_space(<span class="keyword">const</span> struct evbuffer *buf);</span><br></pre></td></tr></table></figure><h2 id="Adding-Data"><a href="#Adding-Data" class="headerlink" title="Adding Data"></a>Adding Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_printf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_vprintf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_expand</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Move-Data"><a href="#Move-Data" class="headerlink" title="Move Data"></a>Move Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer *src)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_buffer</span><span class="params">(struct evbuffer *src, struct evbuffer *dst, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Adding-Data-to-the-front"><a href="#Adding-Data-to-the-front" class="headerlink" title="Adding Data to the front"></a>Adding Data to the front</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer* src)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Rearranging-the-internal-layout"><a href="#Rearranging-the-internal-layout" class="headerlink" title="Rearranging the internal layout"></a>Rearranging the internal layout</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">evbuffer_pullup</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Remove-Data"><a href="#Remove-Data" class="headerlink" title="Remove Data "></a>Remove Data </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_drain</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Copying-Data"><a href="#Copying-Data" class="headerlink" title="Copying Data"></a>Copying Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout_from(struct evbuffer *buf, <span class="keyword">const</span> struct evbuffer_ptr *pos, <span class="keyword">void</span> *data_out, <span class="keyword">size_t</span> datlen);</span><br></pre></td></tr></table></figure><h2 id="Line-oriented-Input"><a href="#Line-oriented-Input" class="headerlink" title="Line-oriented Input"></a>Line-oriented Input</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evbuffer_readln</span><span class="params">(struct evbuffer *buffer, <span class="keyword">size_t</span> *n_read_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"><span class="comment">// enum evbuffer_eol_style &#123;         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_ANY,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_CRLF,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_CRLF_STRICT,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_LF,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_NUL </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search</span><span class="params">(struct evbuffer *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_range</span><span class="params">(struct evbuffer *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start, <span class="keyword">const</span> struct evbuffer_ptr *end)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_eol</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *start, <span class="keyword">size_t</span> *eol_len_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"><span class="comment">// struct evbuffer_ptr &#123;         </span></span><br><span class="line"><span class="comment">//     ev_ssize_t pos; </span></span><br><span class="line"><span class="comment">//     struct &#123;                 </span></span><br><span class="line"><span class="comment">//         /* internal fields */        </span></span><br><span class="line"><span class="comment">//     &#125; _internal; </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_ptr_set</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *pos, <span class="keyword">size_t</span> position, <span class="keyword">enum</span> evbuffer_ptr_how how)</span></span>;</span><br><span class="line"><span class="comment">// enum evbuffer_ptr_how &#123;         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_PTR_SET,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_PTR_ADD </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Inspecting-data-without-copying-it"><a href="#Inspecting-data-without-copying-it" class="headerlink" title="Inspecting data without copying it"></a>Inspecting data without copying it</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_peek</span><span class="params">(struct evbuffer *buffer, <span class="keyword">ev_ssize_t</span> len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec_out, <span class="keyword">int</span> n_vec)</span></span>;</span><br><span class="line"><span class="comment">// struct evbuffer_iovec &#123; </span></span><br><span class="line"><span class="comment">//     void *iov_base;         </span></span><br><span class="line"><span class="comment">//     size_t iov_len; </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure><h2 id="Adding-data-to-an-evbuffer-directly"><a href="#Adding-data-to-an-evbuffer-directly" class="headerlink" title="Adding data to an evbuffer directly"></a>Adding data to an evbuffer directly</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_reserve_space</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_commit_space</span><span class="params">(struct evbuffer *buf, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Network-IO-with-evbuffers"><a href="#Network-IO-with-evbuffers" class="headerlink" title="Network IO with evbuffers"></a>Network IO with evbuffers</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write_atmost</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">ev_ssize_t</span> howmuch)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_read</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> howmuch)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Evbuffers-and-callbacks"><a href="#Evbuffers-and-callbacks" class="headerlink" title="Evbuffers and callbacks"></a>Evbuffers and callbacks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_entry</span>;</span> </span><br><span class="line"><span class="function">struct evbuffer_cb_entry *<span class="title">evbuffer_add_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);</span></span><br><span class="line"><span class="comment">// struct evbuffer_cb_info &#123;         </span></span><br><span class="line"><span class="comment">//     size_t orig_size;         </span></span><br><span class="line"><span class="comment">//     size_t n_added;         </span></span><br><span class="line"><span class="comment">//     size_t n_deleted; </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb_entry</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *ent)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVBUFFER_CB_ENABLED 1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_set_flags</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_clear_flags</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_defer_callbacks</span><span class="params">(struct evbuffer *buffer, struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Avoiding-data-copies-with-evbuffer-based-IO"><a href="#Avoiding-data-copies-with-evbuffer-based-IO" class="headerlink" title="Avoiding data copies with evbuffer-based IO"></a>Avoiding data copies with evbuffer-based IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_reference</span><span class="params">(struct evbuffer *outbuf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen, evbuffer_ref_cleanup_cb cleanupfn, <span class="keyword">void</span> *extra)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evbuffer_ref_cleanup_cb)(const void *data, size_t datalen, void *extra);</span></span><br></pre></td></tr></table></figure><h2 id="Adding-a-file-to-an-evbuffer"><a href="#Adding-a-file-to-an-evbuffer" class="headerlink" title="Adding a file to an evbuffer"></a>Adding a file to an evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_file</span><span class="params">(struct evbuffer *output, <span class="keyword">int</span> fd, <span class="keyword">ev_off_t</span> offset, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Fine-grained-control-with-file-segments"><a href="#Fine-grained-control-with-file-segments" class="headerlink" title="Fine-grained control with file segments"></a>Fine-grained control with file segments</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_file_segment</span>;</span> </span><br><span class="line"><span class="function">struct evbuffer_file_segment *<span class="title">evbuffer_file_segment_new</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">ev_off_t</span> offset, <span class="keyword">ev_off_t</span> length, <span class="keyword">unsigned</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_file_segment_free</span><span class="params">(struct evbuffer_file_segment *seg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_file_segment</span><span class="params">(struct evbuffer *buf, struct evbuffer_file_segment *seg, <span class="keyword">ev_off_t</span> offset, <span class="keyword">ev_off_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_file_segment_cleanup_cb)</span><span class="params">( struct evbuffer_file_segment <span class="keyword">const</span> *seg, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_file_segment_add_cleanup_cb</span><span class="params">(struct evbuffer_file_segment *seg, evbuffer_file_segment_cleanup_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Adding-an-evbuffer-to-another-by-reference"><a href="#Adding-an-evbuffer-to-another-by-reference" class="headerlink" title="Adding an evbuffer to another by reference"></a>Adding an evbuffer to another by reference</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer_reference</span><span class="params">(struct evbuffer *outbuf, struct evbuffer *inbuf)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="Making-an-evbuffer-add-or-remove-only"><a href="#Making-an-evbuffer-add-or-remove-only" class="headerlink" title="Making an evbuffer add- or remove-only"></a>Making an evbuffer add- or remove-only</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_freeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_unfreeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="14-Connection-listeners-evconnlistener"><a href="#14-Connection-listeners-evconnlistener" class="headerlink" title="14 Connection listeners: evconnlistener "></a>14 Connection listeners: evconnlistener </h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">int</span> socklen)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evconnlistener_cb)(struct evconnlistener *listener, evutil_socket_t sock, struct sockaddr *addr, int len, void *ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_disable</span><span class="params">(struct evconnlistener *lev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_enable</span><span class="params">(struct evconnlistener *lev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">evutil_socket_t</span> evconnlistener_get_fd(struct evconnlistener *lev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">evconnlistener_get_base</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_error_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_errorcb errorcb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evconnlistener_errorcb)(struct evconnlistener *lis, void *ptr);</span></span><br></pre></td></tr></table></figure><p>flag:</p><ul><li><code>LEV_OPT_LEAVE_SOCKETS_BLOCKING</code></li><li><code>LEV_OPT_CLOSE_ON_FREE</code></li><li><code>LEV_OPT_CLOSE_ON_EXEC</code></li><li><code>LEV_OPT_REUSEABLE</code></li><li><code>LEV_OPT_THREADSAFE</code></li><li><code>LEV_OPT_DISABLED</code></li><li><code>LEV_OPT_DEFERRED_ACCEPT</code></li></ul><h1 id="15-Use-DNS"><a href="#15-Use-DNS" class="headerlink" title="15 Use DNS"></a>15 Use DNS</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/nmathewson/libevent-book&quot;&gt;https://github.com/nmathewson/libevent-book&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="libevent" scheme="http://ifanze.cn/tags/libevent/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》笔记</title>
    <link href="http://ifanze.cn/2018/04/10/%E3%80%8AEffective%20C++%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifanze.cn/2018/04/10/《Effective C++》笔记/</id>
    <published>2018-04-10T08:53:56.000Z</published>
    <updated>2018-06-24T10:09:09.025Z</updated>
    
    <content type="html"><![CDATA[<p>刚入职时看《Effective C++》记录的笔记</p><a id="more"></a><!-- toc --><h1 id="0-导读"><a href="#0-导读" class="headerlink" title="0 导读"></a>0 导读</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>声明式（declaration）。</li><li>签名式（signature）。</li><li>定义式（definition）。</li><li><p>初始化（initialization）。</p></li><li><p>default 构造函数是一个可被调用而不带任何实参的函数，或者每个参数都有缺省值。</p></li><li>用 <code>explicit</code> 修饰的构造函数不能执行隐式类型转换。如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x  = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>);       <span class="comment">//错误</span></span><br><span class="line">doSomething(B(<span class="number">28</span>));    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>copy construction 被用来“以同型对象初始化自我对象”。</li><li>copy assignment 被用来“从另一个同型对象中拷贝其值到自我对象”。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();                                       <span class="comment">// default construction</span></span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);                      <span class="comment">// copy construction</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);           <span class="comment">// copy assignment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w1;                            <span class="comment">// default construction</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;                    <span class="comment">// copy construction</span></span><br><span class="line">Widget w3 = w2;                  <span class="comment">// copy construction</span></span><br><span class="line">w1 = w2;                              <span class="comment">// copy assignment</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doSomething</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">doSomething(w1);              <span class="comment">// copy construction (passed by value)</span></span><br></pre></td></tr></table></figure><ul><li>undefined behavior。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::out &lt;&lt; *p;</span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> c = name[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1 让自己习惯C++"></a>1 让自己习惯C++</h1><h2 id="条款01：View-C-as-a-federation-of-languages"><a href="#条款01：View-C-as-a-federation-of-languages" class="headerlink" title="条款01：View C++ as a federation of languages."></a>条款01：View C++ as a federation of languages.</h2><p>C++ 现在已经是一个多重范型编程语言（multiparadigm programming language），同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式(metaprogramming）。</p><p>可将 C++ 视为由以下几个次语言构成：</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><h2 id="条款02：Prefer-consts-enums-and-inlines-to-defines"><a href="#条款02：Prefer-consts-enums-and-inlines-to-defines" class="headerlink" title="条款02：Prefer consts, enums, and inlines to #defines."></a>条款02：Prefer consts, enums, and inlines to #defines.</h2><p>使用 const 替换 #define 的好处：</p><ul><li>方便追踪编译错误。</li><li>使用 symbolic debugger 时将其记录进符号表。</li></ul><p>注意两点：</p><ul><li>Constant pointers 的 const 有两种形式：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> name = <span class="string">"Scott"</span>;</span><br><span class="line"><span class="comment">// 当然最好用：</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Scott"</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Class的专属常量用 static：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;      <span class="comment">// 声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;     <span class="comment">//定义式，不要放在头文件中，不用给数值。</span></span><br></pre></td></tr></table></figure><p>C++ 通常要求对使用的任何东西提供一个定义式，这里类的 static 的整数类型（integral type: int, char, bool）只要不取他们的地址就可以不用声明式。但如果需要取地址或编译器坚持需要定义式，就必须提供定义式。并且这种“in-class 初值设定”也只允许对整数常量进行。</p><p>旧时编译器可能要将初值设定放在定义式中，如果编译期间一定要知道该常量值，比如这里 scores 数组的声明，可以使用“the enum hack”补偿做法，即<code>enum { NumTurns = 5 };</code>。</p><p>这样做的好处有：</p><ul><li>它的行为更像 #define 而不像 const，比如不支持取地址。</li><li>优秀的编译器不会为“整型 const 对象”设定另外的空间，除非你创建一个指向该对象的 pointer 或 reference，而不够优秀的编译器却可能如此。Enums 不会导致非必要的你内存分配。</li><li>是 template metaprogramming 的基础技术，非常实用。</li></ul><p>另外，#define 的另一个误用情况是用来实现宏（macros），缺点很多。应使用 template inline 函数，可带来宏的效率以及一般函数的所有可预料行为和类型安全性（type safety）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款03：Use-const-whenever-possible"><a href="#条款03：Use-const-whenever-possible" class="headerlink" title="条款03：Use const whenever possible."></a>条款03：Use const whenever possible.</h2><p>const 的一般用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p;     <span class="comment">// 被指物是常量，同 char const * p;</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;    <span class="comment">// 指针自身是常量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;     <span class="comment">//  T* const，指针本身是常量。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter;  <span class="comment">//  const T*，被指物是常量。</span></span><br></pre></td></tr></table></figure><p>const 在函数的返回值、参数、成员函数自身都有很强大的用法。</p><ul><li>函数返回常量值，可在不放弃安全性和高效性的同时降低使用意外。比如，有理数的乘法操作符：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"><span class="comment">// 阻止了使用类似 if ( a * b = c ) 这样的代码。</span></span><br></pre></td></tr></table></figure><ul><li>使用 const 参数阻止对参数的改动。</li><li>使用 const 成员函数一可使 class 的接口更容易被理解，二是使操作 const 对象成为可能。</li></ul><p>C++的一个重要特性：两个成员函数如果只是常量性（constness）不同，可以被重载。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">'x'</span>;        <span class="comment">// 错误。</span></span><br></pre></td></tr></table></figure><p>成员函数如果是 const 意味着什么？</p><ul><li>bitwise constness（physical constness）：成员函数不更改对象的任何成员变量（任何 bit），这是编译器理解的 const。但存在这种情况：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;ctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;            <span class="comment">// 正确。</span></span><br></pre></td></tr></table></figure><ul><li>logical constness（conceptual constness）：成员函数可以修改它所处理的对象内的某些 bits，但只有在客户侦测不出的情况下才得如此。这是编写程序时应具备的习惯。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> TextBlock::length() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);      <span class="comment">// 错误，const 成员函数内不能改变这些变量值。</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法是把<code>textLength</code>和<code>lengthIsValid</code>声明为mutable。</p><p>对于第一个 TextBlock 例子，还有个问题，如果函数体很长，如还包括边界检验（bounds checking）、日志访问信息（logged access info）、数据完善性检验等，会有大量的重复代码。</p><p>这时可利用常量性转除（casting away constness），即便一般来说使用 casting 是一个糟糕的想法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; TextBook::<span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[postion];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>&amp; TextBook::<span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先转为 const TextBlock&amp; 再将 const 属性移除。</p><h2 id="条款04：Make-sure-that-objects-are-initialized-before-they’re-used"><a href="#条款04：Make-sure-that-objects-are-initialized-before-they’re-used" class="headerlink" title="条款04：Make sure that objects are initialized before they’re used."></a>条款04：Make sure that objects are initialized before they’re used.</h2><p>初始化（initialization）和赋值（assignment）是两个概念。</p><p>请对类的所有成员变量使用 member initialization list 方式进行初始化。</p><p>如果是有多个构造函数，为避免代码冗长，可将性能差不多的初始化封装到函数中转变成赋值函数，实现伪初始化（pseudo-initialization）。</p><p>初始化的顺序是固定的，按照声明次序，而不是初始化列表的次序。</p><p>对于不同编译单元内定义的 non-local static 对象（包括 global 对象、定义于 namespace 作用域内的对象、在 classes 内、在函数内、在 file 作用域内被声明为 static 的对象），C++ 并无明确定义。为应对这种情况，应以 local static 对象替换 non-local static 对象，这也是 Singleton 模式的思想。</p><h1 id="2-Constructors-Destructors-and-Assignment-Operators"><a href="#2-Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="2 Constructors, Destructors, and Assignment Operators"></a>2 Constructors, Destructors, and Assignment Operators</h1><h2 id="条款05：Know-what-functions-C-silently-writes-and-calls"><a href="#条款05：Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="条款05：Know what functions C++ silently writes and calls."></a>条款05：Know what functions C++ silently writes and calls.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~Empty() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些函数惟有在被需要的时候才会创建。</p><p>注意析构函数是 non-virtual 的，除非基类有 virtual 析构函数。</p><p>默认的 copy 构造函数：使用调用相应成员类型的 copy 构造函数，或者通过拷贝每一个 bits 来对每个成员变量进行初始化。</p><p>默认的 copy assignment：同上，但若生成的代码不合法或者没有机会证明它有意义，则不会生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NamedObject&lt;<span class="keyword">int</span>&gt; p(str1, <span class="number">2</span>);</span><br><span class="line">NamedObject&lt;<span class="keyword">int</span>&gt; s(str2, <span class="number">3</span>);</span><br><span class="line">p = s;                          <span class="comment">// 由于 reference 不能改变指向，const 成员无法被修改，所以不会生成 copy assignment</span></span><br></pre></td></tr></table></figure><h2 id="条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><a href="#条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want" class="headerlink" title="条款06：Explicitly disallow the use of compiler-generated functions you do not want."></a>条款06：Explicitly disallow the use of compiler-generated functions you do not want.</h2><p>定义为 private，可以阻止人们调用它。（编译器报错）</p><p>为了进一步阻止成员函数和 friend 函数调用，应只声明而不去定义这些函数。（连接器报错）</p><p>为了方便使用，可以让它继承这样的 Uncopyable 基类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123; &#125;</span><br><span class="line">    ~Uncopyable() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并且，使用时不一定要用 public 继承它，析构函数不一定得是 virtual。可能导致多重继承，多重继承有时会阻止这种 empty base class optimization。</p><p>Boost 库里也有相关的版本，叫 noncopyable。</p><h2 id="条款07：Declare-destructors-virtual-in-polymorphic-base-classes"><a href="#条款07：Declare-destructors-virtual-in-polymorphic-base-classes" class="headerlink" title="条款07：Declare destructors virtual in polymorphic base classes."></a>条款07：Declare destructors virtual in polymorphic base classes.</h2><p>基类指针指向派生类，只有在析构函数为虚函数的情况下才能销毁整个派生类对象。</p><p>但也不能因此把所有类的析构函数都声明成 virtual，由于这份信息由 vptr（virtual table pointer）指向的 vtbl（virtual table）维护，这会增大每个对象的大小。许多人的心得是：只有当 class 内含有至少一个 virtual 函数，才为它声明 virtual destructor。</p><p>注意：string 类的析构函数是 non-virtual 的。</p><p>进一步的，可将析构函数声明为 pure virtual 以实现抽象类。注意提供一份定义，因为编译器会在派生类的析构函数中创建对 ~AWOV 的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV( ) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，给 base classes 一个 virtual 析构函数，这个规则只适用于 polymorphic（带多态性质的）base classes 身上。因为有些基类的设计并不是为了多态，甚至不是为了继承。</p><h2 id="条款08：Prevent-exceptions-from-leaving-destructors"><a href="#条款08：Prevent-exceptions-from-leaving-destructors" class="headerlink" title="条款08：Prevent exceptions from leaving destructors."></a>条款08：Prevent exceptions from leaving destructors.</h2><p>不鼓励在析构函数中抛出异常，会导致程序过早结束或不明确行为。</p><p>所以可以将这些逻辑从析构函数转移到普通函数，交由用户进行调用。</p><p>若析构函数必须处理异常，则要在捕捉到异常后吞下不传播或者结束程序。</p><h2 id="条款09：Never-call-virtual-functions-during-construction-or-destruction"><a href="#条款09：Never-call-virtual-functions-during-construction-or-destruction" class="headerlink" title="条款09：Never call virtual functions during construction or destruction"></a>条款09：Never call virtual functions during construction or destruction</h2><p>在基类构造期间，virtual 函数不是 virtual 函数。</p><p>构造函数中调用的函数里调用了 virtual functions 的情况更加难以发现。</p><h2 id="条款10：Have-assignment-operators-return-a-reference-to-this"><a href="#条款10：Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="条款10：Have assignment operators return a reference to *this."></a>条款10：Have assignment operators return a reference to *this.</h2><p>以支持连锁赋值。</p><h2 id="条款11：Handle-assignment-to-self-in-operator"><a href="#条款11：Handle-assignment-to-self-in-operator" class="headerlink" title="条款11：Handle assignment to self in operator="></a>条款11：Handle assignment to self in operator=</h2><p>三种方式：</p><ul><li>证同测试（identity test）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><ul><li>把焦点放在实现异常安全性（exception safety）上。复制指针所指空间前保证别删除原空间。这样甚至不需要进行证同测试，因为证同测试也需要成本。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 copy and swap 技术。（详见条款 29）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);<span class="comment">// 成员函数，交换*this和参数。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以以 by value 的方式进行优化，牺牲清晰性，却可令编译器有时生成更高效的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12：Copy-all-parts-of-an-object"><a href="#条款12：Copy-all-parts-of-an-object" class="headerlink" title="条款12：Copy all parts of an object."></a>条款12：Copy all parts of an object.</h2><p>当为一个类编写 copy constructor 或者 copy assignment 时，请确保：</p><ol><li>赋值所有 local 成员变量。</li><li>调用所有 base classes 内的适当 copying 函数。</li></ol><p>当然，不能在 copy assignment 操作符中调用 copy 构造函数。<br>反之同样无意义。<br>如果重复代码较多，不妨建立一个 init 成员函数。</p><h1 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理</h1><h2 id="条款13：Use-objects-to-manage-resources"><a href="#条款13：Use-objects-to-manage-resources" class="headerlink" title="条款13：Use objects to manage resources."></a>条款13：Use objects to manage resources.</h2><p>把资源放进对象内，在析构函数中确保资源被释放。</p><p>对于单一区块或函数内的资源，应该在控制流离开那个区块或函数时被释放，可以利用标准库中的<code>auto_ptr</code>，即智能指针，其析构函数自动对其所指对象调用 delete。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>体现的思想：</p><ul><li>获得资源后立刻放进管理对象，即资源取得时机便是初始化时机（Resource Acquisition Is Initialization, RAII）。（在构造函数中获得资源）</li><li>运用析构函数确保资源被释放。（在析构函数中释放资源）</li></ul><p>注意：使用<code>auto_ptr</code>时不要让多个该指针指向同一对象，为此，它有个性质：若通过 copy constructor 或 copy assignment 复制它们，它们会变成 null。</p><p>这意味着<code>auto_ptr</code>并非管理动态分配资源的神兵利器，例如，STL 容器要求其元素发挥正常的复制行为，所以这些容器容不得<code>auto_ptr</code>。</p><p>它的一个替代方案是引用计数型智慧指针（reference-counting smart pointer，RCSP）。追踪有多少对象指向该资源，实现类似垃圾回收（garbage collection）的行为，不同的是无法打破环状引用（cycles of references）。它的一种实现就是 TR1 的tr1::shared_ptr。</p><p>注意，这两个方案都是在其析构函数中做 delete 而不是 delete[]。因此不能用在动态分配而得的 array 身上，即便它能通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; aps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; spi(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>]);</span><br></pre></td></tr></table></figure><p>这种时候推荐用 vector 和 string。</p><h2 id="条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="条款14：Think carefully about copying behavior in resource-managing classes."></a>条款14：Think carefully about copying behavior in resource-managing classes.</h2><p>有时你需要简历自己的资源管理类，一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Lock(Mutex* pm) : mutexPtr(pm)&#123;</span><br><span class="line">        lock(mutexptr);<span class="comment">// 构造时加锁</span></span><br><span class="line">    &#125;<span class="comment">// 析构时释放</span></span><br><span class="line">    ~Lock()&#123;</span><br><span class="line">        unlock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Mutex *mutexPtr;<span class="comment">// 互斥器对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这很好，但如果Lock对象被复制（一个RAII对象被复制），会发生什么事？可能的选择：</p><ul><li>禁止复制。</li><li>引用计数法。对这个例子，可以将 mutexPtr 改为 <code>tr1::shared_ptr</code>类型，但由于引用次数为0时默认执行的是释放操作而不是 unlock，需要在构造时为它指定第二个参数：删除器（deleter）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)&#123;// 增加了一个参数</span><br><span class="line">        lock(mutexPtr.get());<span class="comment">// 使用get，条款15。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不用再定义析构函数。</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;<span class="comment">// 互斥器对象使用 shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制底部资源。即深度复制（deep copying）。</li><li>转移底部资源的拥有权。</li></ul><h2 id="条款15：Provide-access-to-raw-resources-in-resource-managing-class"><a href="#条款15：Provide-access-to-raw-resources-in-resource-managing-class" class="headerlink" title="条款15：Provide access to raw resources in resource-managing class"></a>条款15：Provide access to raw resources in resource-managing class</h2><p>例如你使用<code>auto_ptr</code>或<code>tr1::shared_ptr</code>对某类对象进行管理，而 API 要求使用该对象的原始指针。这时可用 get() 成员函数进行显式转换，获得智能指针内部的原始指针（的复件）。当然，这两个类也实现了<code>operator*</code>和<code>operator-&gt;</code>，用于隐式转换。</p><p>如果是自己写的类，也可提供类似 get() 的接口。也最好提供隐式转换的接口，如从<code>auto_ptr&lt;Font&gt;</code>转为<code>FontHandle</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会增加出错的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Font f1(getFont());</span><br><span class="line">FontHandle f2 = f1;<span class="comment">// 会执行隐式转换后复制，而不是直接复制。</span></span><br></pre></td></tr></table></figure><p>所以不太推荐，要权衡。</p><p>RAII 类暴露原始资源与“封装性”并不矛盾，它的存在并不是为了封装而是为了确保一个特殊行为——资源释放——会放生。</p><h2 id="条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="条款16：Use the same form in corresponding uses of new and delete"></a>条款16：Use the same form in corresponding uses of new and delete</h2><p>new 用 delete，new …[x] 用 delete[]，混用会产生未定义的行为。</p><p>尽量避免对数组类型进行 typedef。</p><h2 id="条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="条款17：Store newed objects in smart pointers in standalone statements."></a>条款17：Store newed objects in smart pointers in standalone statements.</h2><p>以独立语句将新对象置于智能指针，否则有资源泄漏的风险。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure><p>因为 C++ 编译器未必是在 shared_ptr 将新对象添加进来之前执行 priority()，若这时 priority() 出错，新资源的指针会遗失。</p><h1 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4 设计与声明"></a>4 设计与声明</h1><h2 id="条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="条款18：Make interfaces easy to use correctly and hard to use incorrectly."></a>条款18：Make interfaces easy to use correctly and hard to use incorrectly.</h2><ul><li>好的接口很容易被正确使用，不容易被误用。</li><li>促进被正确使用的方法包括：接口的一致性、与内置类型的行为兼容。</li><li>阻止误用的方法包括：建立新类型、限制类型上的操作、束缚对象值、消除客户的资源管理责任。</li><li>tr1::shared_ptr 支持定制型删除器，这可防范 cross-DLL problem，即在一个 DLL 中被 new 创建，却在另一个 DLL 中被 delete 销毁。</li><li>使用 tr1::shared_ptr 等消除某些客户错误的同时，也值得我们关注其使用成本。</li></ul><h2 id="条款19：Treat-class-design-as-type-design"><a href="#条款19：Treat-class-design-as-type-design" class="headerlink" title="条款19：Treat class design as type design."></a>条款19：Treat class design as type design.</h2><ul><li>新 type 的对象应该如何被创建和销毁？（构造、析构、new、delete）</li><li>对象的初始化和赋值有什么样的区别？</li><li>新 type 的对象如果被 passed by value，意味着什么？（copy constructor）</li><li>什么是新 type 的合法值？</li><li>你的新 type 需要配合某个继承图系（inheritance graph）吗？（受其束缚，如 virtual）</li><li>你的新 type 需要什么样的转换？</li><li>什么样的操作符和函数对此新 type 而言是合理的？</li><li>什么样的标准函数应该驳回？（声明为 private）</li><li>谁该取用新 type 的成员？（public/private/protected、friends）</li><li>什么是新 type 的未声明接口（undeclared interface）？</li><li>你的新 type 有多么一般化？（class template）</li><li>你真的需要一个新 type 吗？（使用 non-member function 或者 template？）</li></ul><h2 id="条款20：Prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#条款20：Prefer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="条款20：Prefer pass-by-reference-to-const to pass-by-value."></a>条款20：Prefer pass-by-reference-to-const to pass-by-value.</h2><p>更高效，且可避免切割问题（slicing problem）。</p><p>你可以合理假设“pass-by-value 并不昂贵”的唯一对象就是内置类型、STL 迭代器、函数对象。</p><h2 id="条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object" class="headerlink" title="条款 21：Don’t try to return a reference when you must return an object."></a>条款 21：Don’t try to return a reference when you must return an object.</h2><p>比如<code>operator*</code>。</p><p>绝不要返回一个指向 local stack 上对象的 pointer 或 reference，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。</p><h2 id="条款22：Declare-data-members-private"><a href="#条款22：Declare-data-members-private" class="headerlink" title="条款22：Declare data members private."></a>条款22：Declare data members private.</h2><ul><li>语法一致性。</li><li>细微划分访问控制。</li><li>封装性与“当其内容改变时可能造成的代码破坏量”成反比。</li><li>protected 并不比 public 更具封装性。</li></ul><h2 id="条款23：Prefer-non-member-non-friend-functions-to-member-functions"><a href="#条款23：Prefer-non-member-non-friend-functions-to-member-functions" class="headerlink" title="条款23：Prefer non-member non-friend functions to member functions."></a>条款23：Prefer non-member non-friend functions to member functions.</h2><p>可以增加封装性、包裹弹性（packaging flexibility）、机能扩充性。</p><p>比如一些便利函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;<span class="comment">// member function的写法。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123; ... &#125;<span class="comment">// non-member，non-friend的写法。</span></span><br></pre></td></tr></table></figure><p>另外，如果有很多这样的便利函数，可以按照机能划分到不同的头文件、不同的 namespace 下。</p><h2 id="条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="条款24：Declare non-member functions when type conversions should apply to all parameters"></a>条款24：Declare non-member functions when type conversions should apply to all parameters</h2><p>比如想要创建一个实数类，让它既能实现“Rational <em> int”，又想让它能够实现“int </em> Rational”的运算（内含隐性转换），就需要：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational &amp;rhs)&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>注意，不用把它声明为 friend，friend 能避免就避免。</p><h2 id="条款25：Consider-support-for-a-non-throwing-swap"><a href="#条款25：Consider-support-for-a-non-throwing-swap" class="headerlink" title="条款25：Consider support for a non-throwing swap."></a>条款25：Consider support for a non-throwing swap.</h2><p>（有点绕）</p><h1 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h1><h2 id="条款26：Postpone-variable-definitions-as-long-as-possible"><a href="#条款26：Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="条款26：Postpone variable definitions as long as possible."></a>条款26：Postpone variable definitions as long as possible.</h2><p>尽可能延后变量定义式的出现。</p><h2 id="条款27：Minimize-casting"><a href="#条款27：Minimize-casting" class="headerlink" title="条款27：Minimize casting."></a>条款27：Minimize casting.</h2><p>两种旧式转型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T) expr;</span><br><span class="line">T(expr);</span><br></pre></td></tr></table></figure><p>四种新式转型：</p><ul><li><code>const_cast&lt;T&gt;(expr)</code>。常量性转除（cast away the constness）。</li><li><code>dynamic_cast&lt;T&gt;(expr)</code>。安全向下转型（safe downcasting）。执行速度很慢。</li><li><code>reinterpret_cast&lt;T&gt;(expr)</code>。低级转换，行为取决于编译器（不可抑制），很少用。</li><li><p><code>static_cast&lt;T&gt;(expr)</code>。强迫隐式转换，包括：</p><ul><li>non-const 转 const</li><li>int 转 double</li><li>void<em> 转 T</em></li><li>pointer-to-base 转 pointer-to-derived</li></ul></li></ul><p>唯一使用旧时转型的时机：explicit 构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">doSomeWork(Widget(<span class="number">15</span>));</span><br><span class="line">doSomeWork(<span class="keyword">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure><p>转型可能会做很多事，甚至在基类指针转化为派生类指针时会改变指针的地址。</p><p>dynamic_cast 一般用于将基类指针转为派生类指针，然后执行派生类中才有的函数。但尽量用派生类的指针类型或在基类中声明 virtual 来避免使用它。</p><p>如果转型是必要的，把它隐匿在函数中，不要交给客户。</p><h2 id="条款28：Avoid-returning-“handles”-to-object-internals"><a href="#条款28：Avoid-returning-“handles”-to-object-internals" class="headerlink" title="条款28：Avoid returning “handles” to object internals."></a>条款28：Avoid returning “handles” to object internals.</h2><p>避免返回指向对象内部某对象的 handles（包括 references、pointers、iterators），会破坏封装性。</p><p>如果是返回 const 的对象引用，记得用两个 const，即便如此，也存在着“handle 比其所指对象更长寿”的风险。</p><h2 id="条款29：Strive-for-exception-safe-code"><a href="#条款29：Strive-for-exception-safe-code" class="headerlink" title="条款29：Strive for exception-safe code."></a>条款29：Strive for exception-safe code.</h2><p>异常安全性的两个条件：</p><ul><li>当异常被抛出时，不泄露任何资源。</li><li>当异常被抛出时，不允许数据败坏。</li></ul><p>异常安全函数（Exception-safe function）提供以下三个保证之一：</p><ul><li>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。</li><li>强烈保证：如果异常被抛出，程序状态不改变（恢复到调用前的状态）。（copy-and-swap）</li><li>不抛掷（nothrow）保证：承诺绝不抛出异常，</li></ul><p>（有个例子没仔细看）</p><h2 id="条款30：Understand-the-ins-and-outs-of-inlining"><a href="#条款30：Understand-the-ins-and-outs-of-inlining" class="headerlink" title="条款30：Understand the ins and outs of inlining."></a>条款30：Understand the ins and outs of inlining.</h2><ul><li>将大多数 inlining 限制在小型、被频繁使用的函数上。</li><li>不要只因为 function templates 出现在头文件，将就它们声明为 inline。</li></ul><h2 id="条款31：Minimize-compilation-dependecies-between-files"><a href="#条款31：Minimize-compilation-dependecies-between-files" class="headerlink" title="条款31：Minimize compilation dependecies between files."></a>条款31：Minimize compilation dependecies between files.</h2><p>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。可以使用 Handle classes 和 Interface classes。</p><p>程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用。</p><p>一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; create(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> Date&amp; birthday</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday)</span><br><span class="line">        : theName(name), theBirthday(birthday)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson()&#123; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">//略去实现</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//略去实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; Person::create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name, </span><br><span class="line">                                            <span class="keyword">const</span> Date&amp; birthday)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; pp(Person::create(name, dateOfBirth));</span><br></pre></td></tr></table></figure><h1 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6 继承与面向对象设计"></a>6 继承与面向对象设计</h1><h2 id="条款32：Make-sure-public-inheritance-models-“is-a-”"><a href="#条款32：Make-sure-public-inheritance-models-“is-a-”" class="headerlink" title="条款32：Make sure public inheritance models “is-a.”"></a>条款32：Make sure public inheritance models “is-a.”</h2><p>public 继承意味着“is-a”，适用于 base classes 身上的每一件事一定也适用于 derived classes 身上。</p><h2 id="条款33：Avoid-hiding-inherited-names"><a href="#条款33：Avoid-hiding-inherited-names" class="headerlink" title="条款33：Avoid hiding inherited names."></a>条款33：Avoid hiding inherited names.</h2><ul><li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有人希望如此。</li><li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数（forwarding functions）。</li></ul><h2 id="条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="headerlink" title="条款34：Differentiate between inheritance of interface and inheritance of implementation."></a>条款34：Differentiate between inheritance of interface and inheritance of implementation.</h2><ul><li>接口继承和实现继承不同 ，在 public 继承之下，derived classes 总是继承 base class 的接口。</li><li>pure virtual 函数只具体指定接口继承。</li><li>impure virtual 函数具体指定接口继承及缺省实现继承。</li><li>non-virtual 函数具体指定接口继承以及强制性实现继承。</li></ul><h2 id="条款35：Consider-alternatives-to-virtual-functions"><a href="#条款35：Consider-alternatives-to-virtual-functions" class="headerlink" title="条款35：Consider alternatives to virtual functions"></a>条款35：Consider alternatives to virtual functions</h2><p>virtual 的替代方案：</p><ul><li>使用 non-virtual interface（NVI）手法，那是 Template Method 设计模式的一种特殊模式。它以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的 virtual 函数。</li><li>将 virtual 函数替换为“函数指针成员变量”，这是 Strategy 设计模式的一种分解表现形式。</li><li>以 tr1::function 成员变量替换 virtual 函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。</li><li>将继承体系内的 vitual 函数替换为另一个继承体系的 virtual 函数。这是 Strategy 设计模式的传统实现手法。</li></ul><h2 id="条款36：Never-redefine-an-inherited-non-virtual-function"><a href="#条款36：Never-redefine-an-inherited-non-virtual-function" class="headerlink" title="条款36：Never redefine an inherited non-virtual function."></a>条款36：Never redefine an inherited non-virtual function.</h2><h2 id="条款37：Never-redefine-a-function’s-inherited-default-parameter-value"><a href="#条款37：Never-redefine-a-function’s-inherited-default-parameter-value" class="headerlink" title="条款37：Never redefine a function’s inherited default parameter value."></a>条款37：Never redefine a function’s inherited default parameter value.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;draw();</span><br></pre></td></tr></table></figure><ul><li>Rectangle 中赋予了不同的缺省参数值，很槽糕。</li><li>这里 pr 调用的是派生类复写后的 virtual 函数，但是缺省参数不是 Green 而是 Red（由静态类型决定）。</li><li>使用virtual 函数的替代设计，如 NVI（non-virtual interface）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        doDraw(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><a href="#条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition" class="headerlink" title="条款38：Model “has-a” or “is-implemented-in-terms-of” through composition."></a>条款38：Model “has-a” or “is-implemented-in-terms-of” through composition.</h2><p>复合（composition），同义词有分层（layering）、内含（containment）、聚合（aggregation）、内嵌（embedding）等。它的意义（has-a）和 public 继承（is-a）完全不同。</p><h2 id="条款39：Use-private-inheritance-judiciously"><a href="#条款39：Use-private-inheritance-judiciously" class="headerlink" title="条款39：Use private inheritance judiciously."></a>条款39：Use private inheritance judiciously.</h2><ul><li>private 继承意味着 is-implemented-in-terms-of（根据某物实现出）。通常比复合（composition）的级别低，但当派生类需要访问 protected base class 的成员，或需重新定义继承而来的 virtual 函数时，这么设计是合理的。</li><li>和复合不同，private 继承可以造成 empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li></ul><h2 id="条款40：Use-multiple-inheritance-judiciously"><a href="#条款40：Use-multiple-inheritance-judiciously" class="headerlink" title="条款40：Use multiple inheritance judiciously."></a>条款40：Use multiple inheritance judiciously.</h2><ul><li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li><li>virtual 继承会增加大小、速度、初始化及赋值复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具使用价值的情况。</li><li>多重继承的确有正当用途。其中一个情节涉及“public 继承某个 Interface class”和“private 继承某个协助实现的 class”的组合。</li></ul><h1 id="7-模板和范型编程"><a href="#7-模板和范型编程" class="headerlink" title="7 模板和范型编程"></a>7 模板和范型编程</h1><h2 id="条款41：Understand-implicit-interfaces-and-compile-time-polymorphism"><a href="#条款41：Understand-implicit-interfaces-and-compile-time-polymorphism" class="headerlink" title="条款41：Understand implicit interfaces and compile-time polymorphism."></a>条款41：Understand implicit interfaces and compile-time polymorphism.</h2><ul><li>classes 和 templates 都支持接口（interfaces）和多态（polymorphism）。</li><li>对 classes 而言接口是显式的，以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li><li>对 template 参数而言，接口是隐式的，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析，发生于编译期。</li></ul><h2 id="条款42：Understand-the-two-meanings-of-typename"><a href="#条款42：Understand-the-two-meanings-of-typename" class="headerlink" title="条款42：Understand the two meanings of typename."></a>条款42：Understand the two meanings of typename.</h2><ul><li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li><li>typename 还有个功能是标识嵌套从属类型名称（nested dependent name）。但不得在 base class lists 或 member initialization list 内使用。</li></ul><p>一个正确的使用例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款43：Know-how-to-access-names-in-templatized-base-classes"><a href="#条款43：Know-how-to-access-names-in-templatized-base-classes" class="headerlink" title="条款43：Know how to access names in templatized base classes."></a>条款43：Know how to access names in templatized base classes.</h2><p>当我们从 Object Oriented C++ 跨进 Template C++ 后，继承就没有那样畅行无阻了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        sendClear(info);<span class="comment">// 调用基类函数，无法通过编译。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种解决方式：</p><ol><li>调用前加上<code>this-&gt;</code>。</li><li>使用using声明式。</li><li>使用作用域声明符明确指示，但会关闭 virtual 绑定行为。</li></ol><h2 id="条款44：Factor-parameter-independent-code-out-of-templates"><a href="#条款44：Factor-parameter-independent-code-out-of-templates" class="headerlink" title="条款44：Factor parameter-independent code out of templates."></a>条款44：Factor parameter-independent code out of templates.</h2><ul><li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li><li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。</li><li>因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚入职时看《Effective C++》记录的笔记&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Docker CheatSheet</title>
    <link href="http://ifanze.cn/2018/02/23/Docker-CheatSheet/"/>
    <id>http://ifanze.cn/2018/02/23/Docker-CheatSheet/</id>
    <published>2018-02-23T08:40:23.000Z</published>
    <updated>2019-01-06T15:27:10.967Z</updated>
    
    <content type="html"><![CDATA[<p>阅读 Docker 官方文档的笔记。</p><a id="more"></a><!-- toc --><h1 id="Get-Started-Part-1-Orientation-and-setup"><a href="#Get-Started-Part-1-Orientation-and-setup" class="headerlink" title="Get Started, Part 1: Orientation and setup"></a>Get Started, Part 1: Orientation and setup</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## List Docker CLI commands</span></span><br><span class="line">docker</span><br><span class="line">docker container --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Display Docker version and info</span></span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="comment">## Excecute Docker image</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment">## List Docker images</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment">## List Docker containers (running, all, all in quiet mode)</span></span><br><span class="line">docker container ls</span><br><span class="line">docker container ls -all</span><br><span class="line">docker container ls -a -q</span><br></pre></td></tr></table></figure><h1 id="Get-Started-Part-2-Containers"><a href="#Get-Started-Part-2-Containers" class="headerlink" title="Get Started, Part 2: Containers"></a>Get Started, Part 2: Containers</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .  <span class="comment"># Create image using this directory's Dockerfile</span></span><br><span class="line">docker run -p 4000:80 friendlyhello  <span class="comment"># Run "friendlyname" mapping port 4000 to 80</span></span><br><span class="line">docker run -d -p 4000:80 friendlyhello         <span class="comment"># Same thing, but in detached mode</span></span><br><span class="line">docker container ls                                <span class="comment"># List all running containers</span></span><br><span class="line">docker container ls -a             <span class="comment"># List all containers, even those not running</span></span><br><span class="line">docker container stop &lt;<span class="built_in">hash</span>&gt;           <span class="comment"># Gracefully stop the specified container</span></span><br><span class="line">docker container <span class="built_in">kill</span> &lt;<span class="built_in">hash</span>&gt;         <span class="comment"># Force shutdown of the specified container</span></span><br><span class="line">docker container rm &lt;<span class="built_in">hash</span>&gt;        <span class="comment"># Remove specified container from this machine</span></span><br><span class="line">docker container rm $(docker container ls -a -q)         <span class="comment"># Remove all containers</span></span><br><span class="line">docker image ls -a                             <span class="comment"># List all images on this machine</span></span><br><span class="line">docker image rm &lt;image id&gt;            <span class="comment"># Remove specified image from this machine</span></span><br><span class="line">docker image rm $(docker image ls -a -q)   <span class="comment"># Remove all images from this machine</span></span><br><span class="line">docker login             <span class="comment"># Log in this CLI session using your Docker credentials</span></span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  <span class="comment"># Tag &lt;image&gt; for upload to registry</span></span><br><span class="line">docker push username/repository:tag            <span class="comment"># Upload tagged image to registry</span></span><br><span class="line">docker run username/repository:tag                   <span class="comment"># Run image from a registry</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Copy the current directory contents into the container at /app</span></span></span><br><span class="line"><span class="bash">COPY . /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install any needed packages specified in requirements.txt</span></span></span><br><span class="line"><span class="bash">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Make port 80 available to the world outside this container</span></span></span><br><span class="line"><span class="bash">EXPOSE 80</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Define environment variable</span></span></span><br><span class="line"><span class="bash">ENV NAME World</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Run app.py when the container launches</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h1 id="Get-Started-Part-3-Services"><a href="#Get-Started-Part-3-Services" class="headerlink" title="Get Started, Part 3: Services"></a>Get Started, Part 3: Services</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls                                            <span class="comment"># List stacks or apps</span></span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  <span class="comment"># Run the specified Compose file</span></span><br><span class="line">docker service ls                 <span class="comment"># List running services associated with an app</span></span><br><span class="line">docker service ps &lt;service&gt;                  <span class="comment"># List tasks associated with an app</span></span><br><span class="line">docker inspect &lt;task or container&gt;                   <span class="comment"># Inspect task or container</span></span><br><span class="line">docker container ls -q                                      <span class="comment"># List container IDs</span></span><br><span class="line">docker stack rm &lt;appname&gt;                             <span class="comment"># Tear down an application</span></span><br><span class="line">docker swarm leave --force      <span class="comment"># Take down a single node swarm from the manager</span></span><br></pre></td></tr></table></figure><h1 id="Get-Started-Part-4-Swarms"><a href="#Get-Started-Part-4-Swarms" class="headerlink" title="Get Started, Part 4: Swarms"></a>Get Started, Part 4: Swarms</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --driver virtualbox myvm1 <span class="comment"># Create a VM (Mac, Win7, Linux)</span></span><br><span class="line">docker-machine create -d hyperv --hyperv-virtual-switch <span class="string">"myswitch"</span> myvm1 <span class="comment"># Win10</span></span><br><span class="line">docker-machine env myvm1                <span class="comment"># View basic information about your node</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker node ls"</span>         <span class="comment"># List the nodes in your swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker node inspect &lt;node ID&gt;"</span>        <span class="comment"># Inspect a node</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker swarm join-token -q worker"</span>   <span class="comment"># View join token</span></span><br><span class="line">docker-machine ssh myvm1   <span class="comment"># Open an SSH session with the VM; type "exit" to end</span></span><br><span class="line">docker node ls                <span class="comment"># View nodes in swarm (while logged on to manager)</span></span><br><span class="line">docker-machine ssh myvm2 <span class="string">"docker swarm leave"</span>  <span class="comment"># Make the worker leave the swarm</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker swarm leave -f"</span> <span class="comment"># Make master leave, kill swarm</span></span><br><span class="line">docker-machine ls <span class="comment"># list VMs, asterisk shows which VM this shell is talking to</span></span><br><span class="line">docker-machine start myvm1            <span class="comment"># Start a VM that is currently not running</span></span><br><span class="line">docker-machine env myvm1      <span class="comment"># show environment variables and command for myvm1</span></span><br><span class="line"><span class="built_in">eval</span> $(docker-machine env myvm1)         <span class="comment"># Mac command to connect shell to myvm1</span></span><br><span class="line">&amp; <span class="string">"C:\Program Files\Docker\Docker\Resources\bin\docker-machine.exe"</span> env myvm1 | Invoke-Expression   <span class="comment"># Windows command to connect shell to myvm1</span></span><br><span class="line">docker stack deploy -c &lt;file&gt; &lt;app&gt;  <span class="comment"># Deploy an app; command shell must be set to talk to manager (myvm1), uses local Compose file</span></span><br><span class="line">docker-machine scp docker-compose.yml myvm1:~ <span class="comment"># Copy file to node's home dir (only required if you use ssh to connect to manager and deploy the app)</span></span><br><span class="line">docker-machine ssh myvm1 <span class="string">"docker stack deploy -c &lt;file&gt; &lt;app&gt;"</span>   <span class="comment"># Deploy an app using ssh (you must have first copied the Compose file to myvm1)</span></span><br><span class="line"><span class="built_in">eval</span> $(docker-machine env -u)     <span class="comment"># Disconnect shell from VMs, use native docker</span></span><br><span class="line">docker-machine stop $(docker-machine ls -q)               <span class="comment"># Stop all running VMs</span></span><br><span class="line">docker-machine rm $(docker-machine ls -q) <span class="comment"># Delete all VMs and their disk images</span></span><br></pre></td></tr></table></figure><h1 id="Dockerfile-Sample"><a href="#Dockerfile-Sample" class="headerlink" title="Dockerfile Sample"></a>Dockerfile Sample</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Copy the current directory contents into the container at /app</span></span></span><br><span class="line"><span class="bash">ADD . /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install any needed packages specified in requirements.txt</span></span></span><br><span class="line"><span class="bash">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Make port 80 available to the world outside this container</span></span></span><br><span class="line"><span class="bash">EXPOSE 80</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Define environment variable</span></span></span><br><span class="line"><span class="bash">ENV NAME World</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Run app.py when the container launches</span></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span></span><br></pre></td></tr></table></figure><h1 id="docker-compose-yml-Sample"><a href="#docker-compose-yml-Sample" class="headerlink" title="docker-compose.yml Sample"></a>docker-compose.yml Sample</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line">    <span class="comment"># replace username/repo:tag with your name and image details</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">username/repo:tag</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      replicas:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      restart_policy:</span></span><br><span class="line"><span class="attr">        condition:</span> <span class="string">on-failure</span></span><br><span class="line"><span class="attr">      resources:</span></span><br><span class="line"><span class="attr">        limits:</span></span><br><span class="line"><span class="attr">          cpus:</span> <span class="string">"0.1"</span></span><br><span class="line"><span class="attr">          memory:</span> <span class="number">50</span><span class="string">M</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"80:80"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">  visualizer:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">dockersamples/visualizer:stable</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:8080"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/var/run/docker.sock:/var/run/docker.sock"</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"6379:6379"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"/home/docker/data:/data"</span></span><br><span class="line"><span class="attr">    deploy:</span></span><br><span class="line"><span class="attr">      placement:</span></span><br><span class="line"><span class="attr">        constraints:</span> <span class="string">[node.role</span> <span class="string">==</span> <span class="string">manager]</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">redis-server</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">webnet</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  webnet:</span></span><br></pre></td></tr></table></figure><h1 id="Docker-development-best-practices"><a href="#Docker-development-best-practices" class="headerlink" title="Docker development best practices"></a>Docker development best practices</h1><ol><li><p>Keep images small</p><ul><li>Start with an appropriate base image.</li><li>Use <strong>multistage builds</strong>, or reduce the number of layers by minimizing the number of <code>RUN</code> command.</li><li>Creating your own base image, if you have multiple images with a lot in common.</li><li>Use the production image as the base image for the debug image.</li><li>Tag images with useful tags.</li></ul></li><li><p>Persist data</p><ul><li>Avoid storing data in writable layer using storage drivers, instead, using <strong>volumes</strong>.</li><li>Use <strong>bind mounts</strong> during development and production.</li><li>For production, use <strong>secrets</strong> and <strong>configs</strong> to store sensitive/non-sensitive data.</li></ul></li><li><p>Use swarm services when possible</p><ul><li>Design the app with the ability to scale using swarm services.</li><li>Even only need a single instance, swarm services is better.</li><li>Use <code>docker stack deploy</code> instead of <code>docker pull</code>.</li></ul></li></ol><h1 id="Dockerfile-Reference"><a href="#Dockerfile-Reference" class="headerlink" title="Dockerfile Reference "></a>Dockerfile Reference </h1><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure><h2 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h2><ul><li>Comment: <code>#</code>.</li><li>Parser directives: <ul><li>Only one at present: <code># escape=\</code>. </li><li>Must be at the very top of a Dockerfile.</li><li>Line continuation characters are not supported.</li></ul></li></ul><h2 id="Environment-replacement"><a href="#Environment-replacement" class="headerlink" title="Environment replacement"></a>Environment replacement</h2><ul><li><code>ENV</code></li><li><code>${var}</code></li><li><code>${var:-word}</code></li><li><code>${var:+word}</code></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> abc=hello</span><br><span class="line"><span class="keyword">ENV</span> abc=bye def=$abc        <span class="comment"># def is hello</span></span><br><span class="line"><span class="keyword">ENV</span> ghi=$abc                <span class="comment"># ghi is bye</span></span><br></pre></td></tr></table></figure><h2 id="dockerignore-file"><a href="#dockerignore-file" class="headerlink" title=".dockerignore file"></a>.dockerignore file</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># comment</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br><span class="line">*.md</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure><ul><li><code>ARG</code> is the only instruction that may precede <code>FROM</code>.</li><li><code>FROM</code> can appear multiple times.</li></ul><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>2 forms:</p><ul><li>shell form: <code>RUN &lt;command&gt;</code> , it will run in a shell which by default is <code>/bin/sh -c</code> or <code>cmd /S /C</code>.</li><li>exec form: <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>.</li></ul><p>note: it is the shell that is doing the environment variable expansion, not docker. so:</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"echo"</span>, <span class="string">"<span class="variable">$HOME</span>"</span> ]             <span class="comment"># incorrect</span></span></span><br><span class="line"><span class="bash">RUN [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]    <span class="comment"># correct</span></span></span><br></pre></td></tr></table></figure><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>3 forms:</p><ul><li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (exec form, this is the preferred form)</li><li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (as default parameters to ENTRYPOINT)</li><li><code>CMD command param1 param2</code> (shell form)</li></ul><p>Note: </p><ul><li>Only one <code>CMD</code> allowed, or, the last will take effect.</li><li>If the user specifies arguments to <code>docker run</code> then they will override the default specified in <code>CMD</code>.</li><li><code>CMD</code> does not execute anything at build time.</li></ul><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure><p>Adds metadata to an image, such as <code>MAINTAINER</code>.</p><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure><p>Override at runtime:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80/tcp -p 80:80/udp ...</span><br></pre></td></tr></table></figure><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> myName=<span class="string">"John Doe"</span> myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> myName John Doe</span><br><span class="line"><span class="keyword">ENV</span> myDog Rex The Dog</span><br><span class="line"><span class="keyword">ENV</span> myCat fluffy</span><br></pre></td></tr></table></figure><p>To set a value for a single command, use <code>RUN &lt;key&gt;=&lt;value&gt; &lt;command&gt;</code>.</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>2 forms:</p><ul><li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</code></li><li><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</code> (this form is required for paths containing whitespace)</li></ul><p>note:</p><ul><li><code>&lt;dest&gt;</code> is an absolute path, or a path relative to <code>WORKDIR</code>.</li><li><code>&lt;user&gt;:&lt;group&gt;</code> will be <code>0</code> by default. Setting them through <code>UID/GID</code> or <code>username/groupname</code> is OK.</li><li>Using <code>username/groupname</code> require the base image contain <code>/etc/passwd</code> and <code>/etc/group</code>.</li></ul><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>Almost same as <code>ADD</code>, but:</p><ul><li><code>ADD</code> allows <code>&lt;src&gt;</code> to be an URL</li><li>If the <code>&lt;src&gt;</code> parameter of <code>ADD</code> is an archive in a recognised compression format, it will be unpacked</li></ul><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>2 forms:</p><ul><li><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec form, preferred)</li><li><code>ENTRYPOINT command param1 param2</code> (shell form)</li></ul><p>note:</p><ul><li>Unlike <code>CMD</code>, <code>ENTRYPOINT</code> won’t be replaced by command line arguments, those arguments will be appended after all elements in an <strong>exec form</strong> <code>ENTRYPOINT</code>.</li><li>You can override the <code>ENTRYPOINT</code> instruction using the <code>docker run --entrypoint flag</code>.</li><li><strong>shell form</strong> <code>ENTRYPOINT</code> can prevent <code>CMD</code> or command line arguments from being used, however, container’s <code>PID 1</code> will be <code>/bin/sh</code> rather than the executable. So the executable won’t receive the <code>SIGTERM</code> signal from <code>docker stop &lt;container&gt;</code>.</li><li>Only one <code>CMD</code> allowed, or, the last will take effect.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读 Docker 官方文档的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="参考" scheme="http://ifanze.cn/tags/%E5%8F%82%E8%80%83/"/>
    
      <category term="docker" scheme="http://ifanze.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>macOS CheatSheet</title>
    <link href="http://ifanze.cn/2018/02/23/macOS-CheatSheet/"/>
    <id>http://ifanze.cn/2018/02/23/macOS-CheatSheet/</id>
    <published>2018-02-23T07:55:07.000Z</published>
    <updated>2018-06-24T10:01:44.362Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用的一些命令。</p><a id="more"></a><!-- toc --><h1 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">brew doctor</span><br><span class="line">brew update</span><br><span class="line">brew upgrade</span><br><span class="line"></span><br><span class="line">brew search wget</span><br><span class="line">brew info wget</span><br><span class="line">brew install wget</span><br><span class="line">brew list</span><br><span class="line"></span><br><span class="line">brew cask search iterm2</span><br><span class="line">brew cask info iterm2</span><br><span class="line">brew install iterm2</span><br><span class="line">brew cask list</span><br></pre></td></tr></table></figure><h1 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br><span class="line">nvm install v8.9.4</span><br><span class="line">nvm use v8.9.4</span><br><span class="line">nvm current</span><br><span class="line">nvm ls</span><br><span class="line">nvm <span class="built_in">alias</span> default v8.9.4</span><br></pre></td></tr></table></figure><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"Post Title"</span></span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br><span class="line">hexo clean</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常用的一些命令。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="macOS" scheme="http://ifanze.cn/tags/macOS/"/>
    
      <category term="参考" scheme="http://ifanze.cn/tags/%E5%8F%82%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>macOS 重装与软件管理</title>
    <link href="http://ifanze.cn/2018/02/23/macOS-%E9%87%8D%E8%A3%85%E4%B8%8E%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://ifanze.cn/2018/02/23/macOS-重装与软件管理/</id>
    <published>2018-02-23T07:12:20.000Z</published>
    <updated>2018-04-18T13:47:16.426Z</updated>
    
    <content type="html"><![CDATA[<p>高效管理计算机。</p><a id="more"></a><!-- toc --><p>为了保持 macOS 系统环境的整洁，养成良好、高效的软件管理和使用习惯，决定在过年之际重装一次 macOS。日后在 Mac 使用过程中保持以下几个原则：</p><ul><li>不安装破解软件，付费或替换为同类免费软件。（可是 Photoshop ……）</li><li>所有系统权限需求弱的软件使用 Mac App Store 安装和管理。（除 Evernote，记得 MAS 版不支持代码块）</li><li>桌面程序使用 Homebrew Cask 安装和管理。</li><li>命令行程序使用 Homebrew 安装和管理。</li><li>使用 pyenv 和 nvm 安装和管理 python 和 node.js 的多版本。</li><li>学习和利用 docker 做开发环境的搭建。</li><li>利用 iCloud、Github 对文件和程序配置文件作备份，对有跨平台使用需求的使用 Google Drive。</li><li>再次重装系统时需要注意 QQ、微信、企业QQ 的聊天记录迁移。</li></ul><h1 id="macOS-的重装"><a href="#macOS-的重装" class="headerlink" title="macOS 的重装"></a>macOS 的重装</h1><p>官方文档：<a href="https://support.apple.com/zh-cn/HT204904">https://support.apple.com/zh-cn/HT204904</a></p><p>大致步骤就是：</p><ol><li><code>⌘R</code>开机进恢复模式。</li><li>抹掉 macOS 所在宗卷。</li><li>重新安装 macOS。（需要联网和等待）</li></ol><p>值得一提的是，系统安装过程中，利用无线网 -&gt; 加入其他网络可以让菜单栏焦点回到桌面上，然后打开终端，这时可以使用一些辅助命令，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df -h                       <span class="comment"># 查看硬盘宗卷信息</span></span><br><span class="line">caffeinate -u -t 14400      <span class="comment"># 阻止系统休眠</span></span><br></pre></td></tr></table></figure><p>重装后，正常设置系统、iCloud 账户。</p><h1 id="最高优先级"><a href="#最高优先级" class="headerlink" title="最高优先级"></a>最高优先级</h1><h2 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Meng Fanze&quot;</span><br><span class="line">git config --global user.email ifanze@outlook.com</span><br></pre></td></tr></table></figure><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h2><p><a href="https://github.com/robbyrussell/oh-my-zsh/">https://github.com/robbyrussell/oh-my-zsh/</a><br><a href="https://github.com/zsh-users/zsh-autosuggestions/">https://github.com/zsh-users/zsh-autosuggestions/</a></p><p>配置文件恢复：<code>.zshrc</code>、<code>.zsh_history</code></p><h2 id="安装-homebrew"><a href="#安装-homebrew" class="headerlink" title="安装 homebrew"></a>安装 homebrew</h2><p><a href="https://github.com/Homebrew/brew/">https://github.com/Homebrew/brew/</a></p><h1 id="Mac-App-Store-列表"><a href="#Mac-App-Store-列表" class="headerlink" title="Mac App Store 列表"></a>Mac App Store 列表</h1><ul><li>WeChat</li><li>MWeb</li><li>1Password</li></ul><h1 id="Homebrew-Cask-列表"><a href="#Homebrew-Cask-列表" class="headerlink" title="Homebrew Cask 列表"></a>Homebrew Cask 列表</h1><ul><li>docker</li><li>evernote</li><li>iterm2</li><li>surge</li><li>steam</li><li>dash</li></ul><h1 id="Homebrew-列表"><a href="#Homebrew-列表" class="headerlink" title="Homebrew 列表"></a>Homebrew 列表</h1><ul><li>mas</li><li>nvm</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高效管理计算机。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://ifanze.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="macOS" scheme="http://ifanze.cn/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>《C++ Primer》读书笔记 13</title>
    <link href="http://ifanze.cn/2017/12/24/%E3%80%8AC++%20Primer%E3%80%8B(13)/"/>
    <id>http://ifanze.cn/2017/12/24/《C++ Primer》(13)/</id>
    <published>2017-12-24T07:41:00.000Z</published>
    <updated>2018-06-24T10:06:04.459Z</updated>
    
    <content type="html"><![CDATA[<p>《C++ Primer》读书笔记 第十三章 拷贝控制</p><a id="more"></a><!-- toc --><h1 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h1><p>拷贝控制操作（copy control）：</p><ul><li>拷贝构造函数（copy constructor）</li><li>拷贝赋值运算符（copy-assignment operator）</li><li>移动构造函数（move constructor）</li><li>移动赋值运算符（move-assignment operator）</li><li>析构函数（destructor）</li></ul><h1 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h1><h2 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h2><p>第一个参数是自身类型的引用（且几乎总是<code>const</code>、不是<code>explicit</code>的），任何额外参数都有默认值。</p><p>如未定义，会有合成版本（即使定义了其他构造函数），依次拷贝类的非静态成员，包括数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">'.'</span>)</span></span>;               <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(dots)</span></span>;                     <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="built_in">string</span> s2 = dots;                   <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-9999"</span>;    <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="built_in">string</span> nines = <span class="built_in">string</span>(<span class="number">100</span>, <span class="string">'9'</span>);    <span class="comment">// 拷贝初始化</span></span><br></pre></td></tr></table></figure><p>拷贝初始化也可能是由移动构造函数完成。</p><p>拷贝初始化时机：</p><ul><li>使用<code>=</code>定义对象。</li><li>将一个对象作为实参传递给一个非引用类型的形参。</li><li>返回一个对象（非引用）。</li><li>列表初始化一个数组中的元素或一个聚合类中的成员。</li><li>类中对所分配对象执行拷贝初始化操作。如 STL 中的<code>insert</code>等。</li></ul><p>注意拷贝构造函数是不是<code>explicit</code>的，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(<span class="number">10</span>);     <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>编译器可能绕过拷贝/移动构造函数，而直接创建对象。（但拷贝/移动构造函数依然需要是存在且可访问的）</p><h2 id="13-1-2-拷贝赋值运算符"><a href="#13-1-2-拷贝赋值运算符" class="headerlink" title="13.1.2 拷贝赋值运算符"></a>13.1.2 拷贝赋值运算符</h2><p>如果未定义，会有合成版本，会将右侧运算对象的每个非静态成员赋予左侧运算对象的相应成员，包括数组。</p><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p><h2 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h2><p>调用时机：</p><ul><li>离开作用域。</li><li>当对象被销毁时，其成员被销毁。</li><li>容器被销毁时，其元素被销毁。</li><li>动态分配的对象，使用<code>delete</code>进行销毁。</li><li>对于临时对象，当创建它的完整表达式结束时被销毁。</li></ul><h2 id="13-1-4-三-五法则"><a href="#13-1-4-三-五法则" class="headerlink" title="13.1.4 三/五法则"></a>13.1.4 三/五法则</h2><ul><li>需要析构函数的类也需要拷贝构造函数和拷贝赋值运算符。</li><li>需要拷贝操作的类也需要赋值操作，反之亦然。</li></ul><h2 id="13-1-5-使用-default"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用 = default"></a>13.1.5 使用 = default</h2><p>显式要求编译器生成合成的版本，只能对编译器可以合成的默认构造函数或拷贝控制成员使用。</p><p>在类内使用将声明为内联的，如果不希望这样，应只在类外定义使用。</p><h2 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h2><p>使用<code>= delete</code>，必须出现在第一次声明的时候，可以对任何函数使用，除了析构函数（会造成不能释放这些对象）。</p><p>合成的拷贝控制成员可能是删除的：</p><ul><li>合成析构函数：当某成员的析构函数是删除的或者不可访问的。</li><li>合成拷贝构造函数：当某成员的拷贝构造函数或析构函数是删除的或者不可访问的。</li><li>合成拷贝赋值运算符：当某个成员的拷贝赋值运算符是删除的或不可访问的，或类的成员中有<code>const</code>或引用。</li><li>默认构造函数：当某个成员的析构函数是删除的或者不可访问的，或类的成员中有没有类内初始化器的<code>const</code>或引用。</li></ul><p>使用<code>private</code>阻止拷贝的缺点是：友元和成员函数依然能够拷贝。对此可以只声明不定义，这样在试图拷贝时会报链接错误。</p><h1 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h1><p>（实例）</p><h1 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.ps, rhs.ps);</span><br><span class="line">    swap(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里调用的是<code>swap</code>，而不是<code>std::swap</code>，是想让在用户版本和 std 版本中自动匹配合适的函数。</p><p>有了交换操作后，可以用它更简单的定义赋值运算符，即拷贝并交换（copy and swap）。它是异常安全的，且能正确处理自赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-4-拷贝控制示例"><a href="#13-4-拷贝控制示例" class="headerlink" title="13.4 拷贝控制示例"></a>13.4 拷贝控制示例</h1><p>（实例）</p><h1 id="13-5-动态内存管理类"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类</h1><p>（实例）</p><p>引出移动。</p><h1 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h1><p>很多情况会发生对象拷贝，某些时候对象拷贝后就立刻被销毁了。使用移动可以大幅度提升性能。</p><h2 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h2><ul><li>只能绑定到一个将要销毁的对象（往往意味着也没有其他用户）。</li><li>变量是左值，不能将右值引用直接绑定到一个变量上，即使这个变量是右值引用类型。</li></ul><p>可以使用<code>&lt;utility&gt;</code>中的<code>std::move</code>将一个左值显式地转换为对应的右值引用类型。告诉编译器：我有一个左值，但我希望像一个右值一样处理它，承诺不再使用它的值，除了对其赋值和销毁，因为移后源对象（moved-from）依然是一个有效的、可析构的状态，但不能对它的值做任何假设。</p><h2 id="13-6-2-移动构造函数和移动赋值运算符"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符</h2><p>类似拷贝构造函数，只是第一个参数是右值引用类型。</p><p>注意确保移动后的对象处在销毁它是无害的的状态，如将指针置为<code>nullptr</code>。</p><p>移动构造函数一般是<code>noexcept</code>的，由于它窃取资源而不分配资源。该关键字写在定义和声明的参数列表后，分号和冒号前。声明和定义都必须指定。</p><p>如果容器的元素是我们的自定义类型，如果不告诉编译器我们的移动构造函数是<code>noexcept</code>的，在进行一些操作时，如对<code>vector</code>进行需要增大内存分配的<code>push_back</code>操作，容器会不敢使用移动构造函数而是使用拷贝构造函数，因为它需要对异常发生时自身的行为提供保障：当异常发生时，vector 自身不会发生变化。</p><p>移动赋值运算符与析构函数和移动构造函数执行相同的工作。与移动构造函数一样，如果不抛异常就该标记为<code>noexcept</code>。</p><p>与拷贝不同，编译器根本不会为某些类合成移动操作。特别是当一个类定义了自己的拷贝函数、拷贝赋值运算符或者析构函数。没有移动构造函数后，根据正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，才会合成。</p><p>可以移动的成员包括：内置类型可以移动，有移动操作的类类型成员也能移动。</p><p>与拷贝不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们使用<code>=default</code>，且编译器不能移动所有成员，它会是删除的。例外是：</p><p>（一二三四，我选择不依赖合成而是自己定义= =）</p><p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</p><p>如果一个类既有移动构造函数，也有拷贝构造函数。则移动右值，拷贝左值。但如果没有移动构造函数，右值也被拷贝。</p><p>引入移动操作后，<em>13.3</em>中的拷贝并交换赋值运算符在定义了移动构造函数之后会兼容移动操作。单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p><p>更新三/五法则：所有五个拷贝控制成员应该看作一个整体：如果定义了任何一个拷贝操作，就应该定义五个。这些类通常拥有一个资源。</p><p>移动迭代器：通过解引用得到返回一个指向元素的右值引用。使用<code>make_move_iterator</code>函数。例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line"><span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br></pre></td></tr></table></figure><h2 id="13-6-3-右值引用和成员函数"><a href="#13-6-3-右值引用和成员函数" class="headerlink" title="13.6.3 右值引用和成员函数"></a>13.6.3 右值引用和成员函数</h2><p>如果一个成员函数同时提供拷贝和移动版本，则一般使用与拷贝/移动构造函数和赋值运算符相同的参数模式：一个版本接受一个指向<code>const</code>的左值引用，一个版本接受一个指向非<code>const</code>的右值引用。</p><p>一般来说，我们不需要为函数操作定义接受一个<code>const X&amp;&amp;</code>或一个普通的<code>X&amp;</code>参数的版本。</p><p>通常，我们在一个对象上调用成员函数，而不管对象是一个左值还是一个右值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1= <span class="string">"xxxx"</span>, s2=<span class="string">"xxxx"</span>;</span><br><span class="line"><span class="keyword">auto</span> n = (s1 + s2).find(<span class="string">'a'</span>);</span><br><span class="line">s1 + s2 = <span class="string">"wow!"</span>;</span><br></pre></td></tr></table></figure><p>在旧标准中，我们没法阻止这种使用方式，为了向后兼容性，新标准依然允许。但是有方法进行阻止：限定<code>this</code>的左值/右值属性，像限制其<code>const</code>属性那样在参数列表后放置<code>&amp;</code>或<code>&amp;&amp;</code>。如果需要同时放置<code>const</code>，<code>const</code>在前。需要同时在声明和定义中指定。</p><p>重载方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;            <span class="comment">// 可用于可改变的右值</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;       <span class="comment">// 可用于任何类型的 Foo</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：定义<code>const</code>成员函数时，可以定义两个版本：差别是有没有<code>const</code>。但引用限定的函数不一样，必须对所有函数都加上引用限定符，或者所有都不加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《C++ Primer》读书笔记 第十三章 拷贝控制&lt;/p&gt;
    
    </summary>
    
      <category term="《C++ Primer》" scheme="http://ifanze.cn/categories/%E3%80%8AC-Primer%E3%80%8B/"/>
    
    
      <category term="C++" scheme="http://ifanze.cn/tags/C/"/>
    
      <category term="读书" scheme="http://ifanze.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
