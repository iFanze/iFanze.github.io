<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="孟凡泽的博客"><title>《Effective C++》笔记 | Meng Fanze's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《Effective C++》笔记</h1><a id="logo" href="/.">Meng Fanze's Blog</a><p class="description">C++、Web、Game</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/guestbook/"><i class="fa fa-comments"> 留言</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《Effective C++》笔记</h1><div class="post-meta">Apr 10, 2018<span> | </span><span class="category"><a href="/categories/笔记/">笔记</a></span></div><a class="disqus-comment-count" href="/2018/04/10/《Effective C++》笔记/#vcomment"><span class="valine-comment-count" data-xid="/2018/04/10/《Effective C++》笔记/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-导读"><span class="toc-text">0 导读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#术语"><span class="toc-text">术语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-让自己习惯C"><span class="toc-text">1 让自己习惯C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款01：View-C-as-a-federation-of-languages"><span class="toc-text">条款01：View C++ as a federation of languages.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款02：Prefer-consts-enums-and-inlines-to-defines"><span class="toc-text">条款02：Prefer consts, enums, and inlines to #defines.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款03：Use-const-whenever-possible"><span class="toc-text">条款03：Use const whenever possible.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款04：Make-sure-that-objects-are-initialized-before-they’re-used"><span class="toc-text">条款04：Make sure that objects are initialized before they’re used.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Constructors-Destructors-and-Assignment-Operators"><span class="toc-text">2 Constructors, Destructors, and Assignment Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款05：Know-what-functions-C-silently-writes-and-calls"><span class="toc-text">条款05：Know what functions C++ silently writes and calls.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><span class="toc-text">条款06：Explicitly disallow the use of compiler-generated functions you do not want.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款07：Declare-destructors-virtual-in-polymorphic-base-classes"><span class="toc-text">条款07：Declare destructors virtual in polymorphic base classes.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款08：Prevent-exceptions-from-leaving-destructors"><span class="toc-text">条款08：Prevent exceptions from leaving destructors.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款09：Never-call-virtual-functions-during-construction-or-destruction"><span class="toc-text">条款09：Never call virtual functions during construction or destruction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款10：Have-assignment-operators-return-a-reference-to-this"><span class="toc-text">条款10：Have assignment operators return a reference to *this.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款11：Handle-assignment-to-self-in-operator"><span class="toc-text">条款11：Handle assignment to self in operator=</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款12：Copy-all-parts-of-an-object"><span class="toc-text">条款12：Copy all parts of an object.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-资源管理"><span class="toc-text">3 资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款13：Use-objects-to-manage-resources"><span class="toc-text">条款13：Use objects to manage resources.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes"><span class="toc-text">条款14：Think carefully about copying behavior in resource-managing classes.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款15：Provide-access-to-raw-resources-in-resource-managing-class"><span class="toc-text">条款15：Provide access to raw resources in resource-managing class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete"><span class="toc-text">条款16：Use the same form in corresponding uses of new and delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements"><span class="toc-text">条款17：Store newed objects in smart pointers in standalone statements.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-设计与声明"><span class="toc-text">4 设计与声明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><span class="toc-text">条款18：Make interfaces easy to use correctly and hard to use incorrectly.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款19：Treat-class-design-as-type-design"><span class="toc-text">条款19：Treat class design as type design.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款20：Prefer-pass-by-reference-to-const-to-pass-by-value"><span class="toc-text">条款20：Prefer pass-by-reference-to-const to pass-by-value.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object"><span class="toc-text">条款 21：Don’t try to return a reference when you must return an object.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款22：Declare-data-members-private"><span class="toc-text">条款22：Declare data members private.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款23：Prefer-non-member-non-friend-functions-to-member-functions"><span class="toc-text">条款23：Prefer non-member non-friend functions to member functions.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><span class="toc-text">条款24：Declare non-member functions when type conversions should apply to all parameters</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款25：Consider-support-for-a-non-throwing-swap"><span class="toc-text">条款25：Consider support for a non-throwing swap.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-实现"><span class="toc-text">5 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款26：Postpone-variable-definitions-as-long-as-possible"><span class="toc-text">条款26：Postpone variable definitions as long as possible.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款27：Minimize-casting"><span class="toc-text">条款27：Minimize casting.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款28：Avoid-returning-“handles”-to-object-internals"><span class="toc-text">条款28：Avoid returning “handles” to object internals.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款29：Strive-for-exception-safe-code"><span class="toc-text">条款29：Strive for exception-safe code.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款30：Understand-the-ins-and-outs-of-inlining"><span class="toc-text">条款30：Understand the ins and outs of inlining.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款31：Minimize-compilation-dependecies-between-files"><span class="toc-text">条款31：Minimize compilation dependecies between files.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-继承与面向对象设计"><span class="toc-text">6 继承与面向对象设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款32：Make-sure-public-inheritance-models-“is-a-”"><span class="toc-text">条款32：Make sure public inheritance models “is-a.”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款33：Avoid-hiding-inherited-names"><span class="toc-text">条款33：Avoid hiding inherited names.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><span class="toc-text">条款34：Differentiate between inheritance of interface and inheritance of implementation.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款35：Consider-alternatives-to-virtual-functions"><span class="toc-text">条款35：Consider alternatives to virtual functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款36：Never-redefine-an-inherited-non-virtual-function"><span class="toc-text">条款36：Never redefine an inherited non-virtual function.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款37：Never-redefine-a-function’s-inherited-default-parameter-value"><span class="toc-text">条款37：Never redefine a function’s inherited default parameter value.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><span class="toc-text">条款38：Model “has-a” or “is-implemented-in-terms-of” through composition.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款39：Use-private-inheritance-judiciously"><span class="toc-text">条款39：Use private inheritance judiciously.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款40：Use-multiple-inheritance-judiciously"><span class="toc-text">条款40：Use multiple inheritance judiciously.</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-模板和范型编程"><span class="toc-text">7 模板和范型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#条款41：Understand-implicit-interfaces-and-compile-time-polymorphism"><span class="toc-text">条款41：Understand implicit interfaces and compile-time polymorphism.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款42：Understand-the-two-meanings-of-typename"><span class="toc-text">条款42：Understand the two meanings of typename.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款43：Know-how-to-access-names-in-templatized-base-classes"><span class="toc-text">条款43：Know how to access names in templatized base classes.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条款44：Factor-parameter-independent-code-out-of-templates"><span class="toc-text">条款44：Factor parameter-independent code out of templates.</span></a></li></ol></li></ol></div></div><div class="post-content"><p>刚入职时看《Effective C++》记录的笔记</p>
<a id="more"></a>
<!-- toc -->
<h1 id="0-导读"><a href="#0-导读" class="headerlink" title="0 导读"></a>0 导读</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>声明式（declaration）。</li>
<li>签名式（signature）。</li>
<li>定义式（definition）。</li>
<li><p>初始化（initialization）。</p>
</li>
<li><p>default 构造函数是一个可被调用而不带任何实参的函数，或者每个参数都有缺省值。</p>
</li>
<li>用 <code>explicit</code> 修饰的构造函数不能执行隐式类型转换。如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x  = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>);       <span class="comment">//错误</span></span><br><span class="line">doSomething(B(<span class="number">28</span>));    <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li>copy construction 被用来“以同型对象初始化自我对象”。</li>
<li>copy assignment 被用来“从另一个同型对象中拷贝其值到自我对象”。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();                                       <span class="comment">// default construction</span></span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);                      <span class="comment">// copy construction</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);           <span class="comment">// copy assignment</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w1;                            <span class="comment">// default construction</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;                    <span class="comment">// copy construction</span></span><br><span class="line">Widget w3 = w2;                  <span class="comment">// copy construction</span></span><br><span class="line">w1 = w2;                              <span class="comment">// copy assignment</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">doSomething</span><span class="params">(Widget w)</span></span>;</span><br><span class="line">doSomething(w1);              <span class="comment">// copy construction (passed by value)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>undefined behavior。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::out &lt;&lt; *p;</span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> c = name[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h1 id="1-让自己习惯C"><a href="#1-让自己习惯C" class="headerlink" title="1 让自己习惯C++"></a>1 让自己习惯C++</h1><h2 id="条款01：View-C-as-a-federation-of-languages"><a href="#条款01：View-C-as-a-federation-of-languages" class="headerlink" title="条款01：View C++ as a federation of languages."></a>条款01：View C++ as a federation of languages.</h2><p>C++ 现在已经是一个多重范型编程语言（multiparadigm programming language），同时支持过程形式（procedural）、面向对象形式（object-oriented）、函数形式（functional）、泛型形式（generic）、元编程形式(metaprogramming）。</p>
<p>可将 C++ 视为由以下几个次语言构成：</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<h2 id="条款02：Prefer-consts-enums-and-inlines-to-defines"><a href="#条款02：Prefer-consts-enums-and-inlines-to-defines" class="headerlink" title="条款02：Prefer consts, enums, and inlines to #defines."></a>条款02：Prefer consts, enums, and inlines to #defines.</h2><p>使用 const 替换 #define 的好处：</p>
<ul>
<li>方便追踪编译错误。</li>
<li>使用 symbolic debugger 时将其记录进符号表。</li>
</ul>
<p>注意两点：</p>
<ul>
<li>Constant pointers 的 const 有两种形式：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> name = <span class="string">"Scott"</span>;</span><br><span class="line"><span class="comment">// 当然最好用：</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Scott"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Class的专属常量用 static：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;      <span class="comment">// 声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;     <span class="comment">//定义式，不要放在头文件中，不用给数值。</span></span><br></pre></td></tr></table></figure>
<p>C++ 通常要求对使用的任何东西提供一个定义式，这里类的 static 的整数类型（integral type: int, char, bool）只要不取他们的地址就可以不用声明式。但如果需要取地址或编译器坚持需要定义式，就必须提供定义式。并且这种“in-class 初值设定”也只允许对整数常量进行。</p>
<p>旧时编译器可能要将初值设定放在定义式中，如果编译期间一定要知道该常量值，比如这里 scores 数组的声明，可以使用“the enum hack”补偿做法，即<code>enum { NumTurns = 5 };</code>。</p>
<p>这样做的好处有：</p>
<ul>
<li>它的行为更像 #define 而不像 const，比如不支持取地址。</li>
<li>优秀的编译器不会为“整型 const 对象”设定另外的空间，除非你创建一个指向该对象的 pointer 或 reference，而不够优秀的编译器却可能如此。Enums 不会导致非必要的你内存分配。</li>
<li>是 template metaprogramming 的基础技术，非常实用。</li>
</ul>
<p>另外，#define 的另一个误用情况是用来实现宏（macros），缺点很多。应使用 template inline 函数，可带来宏的效率以及一般函数的所有可预料行为和类型安全性（type safety）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条款03：Use-const-whenever-possible"><a href="#条款03：Use-const-whenever-possible" class="headerlink" title="条款03：Use const whenever possible."></a>条款03：Use const whenever possible.</h2><p>const 的一般用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p;     <span class="comment">// 被指物是常量，同 char const * p;</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p;    <span class="comment">// 指针自身是常量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;     <span class="comment">//  T* const，指针本身是常量。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter;  <span class="comment">//  const T*，被指物是常量。</span></span><br></pre></td></tr></table></figure>
<p>const 在函数的返回值、参数、成员函数自身都有很强大的用法。</p>
<ul>
<li>函数返回常量值，可在不放弃安全性和高效性的同时降低使用意外。比如，有理数的乘法操作符：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line"><span class="comment">// 阻止了使用类似 if ( a * b = c ) 这样的代码。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 const 参数阻止对参数的改动。</li>
<li>使用 const 成员函数一可使 class 的接口更容易被理解，二是使操作 const 对象成为可能。</li>
</ul>
<p>C++的一个重要特性：两个成员函数如果只是常量性（constness）不同，可以被重载。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> position) &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];</span><br><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">ctb[<span class="number">0</span>] = <span class="string">'x'</span>;        <span class="comment">// 错误。</span></span><br></pre></td></tr></table></figure>
<p>成员函数如果是 const 意味着什么？</p>
<ul>
<li>bitwise constness（physical constness）：成员函数不更改对象的任何成员变量（任何 bit），这是编译器理解的 const。但存在这种情况：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;ctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;            <span class="comment">// 正确。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>logical constness（conceptual constness）：成员函数可以修改它所处理的对象内的某些 bits，但只有在客户侦测不出的情况下才得如此。这是编写程序时应具备的习惯。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> length() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> TextBlock::length() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);      <span class="comment">// 错误，const 成员函数内不能改变这些变量值。</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法是把<code>textLength</code>和<code>lengthIsValid</code>声明为mutable。</p>
<p>对于第一个 TextBlock 例子，还有个问题，如果函数体很长，如还包括边界检验（bounds checking）、日志访问信息（logged access info）、数据完善性检验等，会有大量的重复代码。</p>
<p>这时可利用常量性转除（casting away constness），即便一般来说使用 casting 是一个糟糕的想法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; TextBook::<span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) <span class="keyword">const</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> text[postion];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>&amp; TextBook::<span class="keyword">operator</span>[] (<span class="built_in">std</span>::<span class="keyword">size_t</span> postion) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先转为 const TextBlock&amp; 再将 const 属性移除。</p>
<h2 id="条款04：Make-sure-that-objects-are-initialized-before-they’re-used"><a href="#条款04：Make-sure-that-objects-are-initialized-before-they’re-used" class="headerlink" title="条款04：Make sure that objects are initialized before they’re used."></a>条款04：Make sure that objects are initialized before they’re used.</h2><p>初始化（initialization）和赋值（assignment）是两个概念。</p>
<p>请对类的所有成员变量使用 member initialization list 方式进行初始化。</p>
<p>如果是有多个构造函数，为避免代码冗长，可将性能差不多的初始化封装到函数中转变成赋值函数，实现伪初始化（pseudo-initialization）。</p>
<p>初始化的顺序是固定的，按照声明次序，而不是初始化列表的次序。</p>
<p>对于不同编译单元内定义的 non-local static 对象（包括 global 对象、定义于 namespace 作用域内的对象、在 classes 内、在函数内、在 file 作用域内被声明为 static 的对象），C++ 并无明确定义。为应对这种情况，应以 local static 对象替换 non-local static 对象，这也是 Singleton 模式的思想。</p>
<h1 id="2-Constructors-Destructors-and-Assignment-Operators"><a href="#2-Constructors-Destructors-and-Assignment-Operators" class="headerlink" title="2 Constructors, Destructors, and Assignment Operators"></a>2 Constructors, Destructors, and Assignment Operators</h1><h2 id="条款05：Know-what-functions-C-silently-writes-and-calls"><a href="#条款05：Know-what-functions-C-silently-writes-and-calls" class="headerlink" title="条款05：Know what functions C++ silently writes and calls."></a>条款05：Know what functions C++ silently writes and calls.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~Empty() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些函数惟有在被需要的时候才会创建。</p>
<p>注意析构函数是 non-virtual 的，除非基类有 virtual 析构函数。</p>
<p>默认的 copy 构造函数：使用调用相应成员类型的 copy 构造函数，或者通过拷贝每一个 bits 来对每个成员变量进行初始化。</p>
<p>默认的 copy assignment：同上，但若生成的代码不合法或者没有机会证明它有意义，则不会生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NamedObject&lt;<span class="keyword">int</span>&gt; p(str1, <span class="number">2</span>);</span><br><span class="line">NamedObject&lt;<span class="keyword">int</span>&gt; s(str2, <span class="number">3</span>);</span><br><span class="line">p = s;                          <span class="comment">// 由于 reference 不能改变指向，const 成员无法被修改，所以不会生成 copy assignment</span></span><br></pre></td></tr></table></figure>
<h2 id="条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want"><a href="#条款06：Explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want" class="headerlink" title="条款06：Explicitly disallow the use of compiler-generated functions you do not want."></a>条款06：Explicitly disallow the use of compiler-generated functions you do not want.</h2><p>定义为 private，可以阻止人们调用它。（编译器报错）</p>
<p>为了进一步阻止成员函数和 friend 函数调用，应只声明而不去定义这些函数。（连接器报错）</p>
<p>为了方便使用，可以让它继承这样的 Uncopyable 基类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123; &#125;</span><br><span class="line">    ~Uncopyable() &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并且，使用时不一定要用 public 继承它，析构函数不一定得是 virtual。可能导致多重继承，多重继承有时会阻止这种 empty base class optimization。</p>
<p>Boost 库里也有相关的版本，叫 noncopyable。</p>
<h2 id="条款07：Declare-destructors-virtual-in-polymorphic-base-classes"><a href="#条款07：Declare-destructors-virtual-in-polymorphic-base-classes" class="headerlink" title="条款07：Declare destructors virtual in polymorphic base classes."></a>条款07：Declare destructors virtual in polymorphic base classes.</h2><p>基类指针指向派生类，只有在析构函数为虚函数的情况下才能销毁整个派生类对象。</p>
<p>但也不能因此把所有类的析构函数都声明成 virtual，由于这份信息由 vptr（virtual table pointer）指向的 vtbl（virtual table）维护，这会增大每个对象的大小。许多人的心得是：只有当 class 内含有至少一个 virtual 函数，才为它声明 virtual destructor。</p>
<p>注意：string 类的析构函数是 non-virtual 的。</p>
<p>进一步的，可将析构函数声明为 pure virtual 以实现抽象类。注意提供一份定义，因为编译器会在派生类的析构函数中创建对 ~AWOV 的调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV( ) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，给 base classes 一个 virtual 析构函数，这个规则只适用于 polymorphic（带多态性质的）base classes 身上。因为有些基类的设计并不是为了多态，甚至不是为了继承。</p>
<h2 id="条款08：Prevent-exceptions-from-leaving-destructors"><a href="#条款08：Prevent-exceptions-from-leaving-destructors" class="headerlink" title="条款08：Prevent exceptions from leaving destructors."></a>条款08：Prevent exceptions from leaving destructors.</h2><p>不鼓励在析构函数中抛出异常，会导致程序过早结束或不明确行为。</p>
<p>所以可以将这些逻辑从析构函数转移到普通函数，交由用户进行调用。</p>
<p>若析构函数必须处理异常，则要在捕捉到异常后吞下不传播或者结束程序。</p>
<h2 id="条款09：Never-call-virtual-functions-during-construction-or-destruction"><a href="#条款09：Never-call-virtual-functions-during-construction-or-destruction" class="headerlink" title="条款09：Never call virtual functions during construction or destruction"></a>条款09：Never call virtual functions during construction or destruction</h2><p>在基类构造期间，virtual 函数不是 virtual 函数。</p>
<p>构造函数中调用的函数里调用了 virtual functions 的情况更加难以发现。</p>
<h2 id="条款10：Have-assignment-operators-return-a-reference-to-this"><a href="#条款10：Have-assignment-operators-return-a-reference-to-this" class="headerlink" title="条款10：Have assignment operators return a reference to *this."></a>条款10：Have assignment operators return a reference to *this.</h2><p>以支持连锁赋值。</p>
<h2 id="条款11：Handle-assignment-to-self-in-operator"><a href="#条款11：Handle-assignment-to-self-in-operator" class="headerlink" title="条款11：Handle assignment to self in operator="></a>条款11：Handle assignment to self in operator=</h2><p>三种方式：</p>
<ul>
<li>证同测试（identity test）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>把焦点放在实现异常安全性（exception safety）上。复制指针所指空间前保证别删除原空间。这样甚至不需要进行证同测试，因为证同测试也需要成本。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">delete</span> pOrig;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 copy and swap 技术。（详见条款 29）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);</span><br><span class="line">    swap(temp);				<span class="comment">// 成员函数，交换*this和参数。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以以 by value 的方式进行优化，牺牲清晰性，却可令编译器有时生成更高效的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条款12：Copy-all-parts-of-an-object"><a href="#条款12：Copy-all-parts-of-an-object" class="headerlink" title="条款12：Copy all parts of an object."></a>条款12：Copy all parts of an object.</h2><p>当为一个类编写 copy constructor 或者 copy assignment 时，请确保：</p>
<ol>
<li>赋值所有 local 成员变量。</li>
<li>调用所有 base classes 内的适当 copying 函数。</li>
</ol>
<p>当然，不能在 copy assignment 操作符中调用 copy 构造函数。<br>反之同样无意义。<br>如果重复代码较多，不妨建立一个 init 成员函数。</p>
<h1 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理</h1><h2 id="条款13：Use-objects-to-manage-resources"><a href="#条款13：Use-objects-to-manage-resources" class="headerlink" title="条款13：Use objects to manage resources."></a>条款13：Use objects to manage resources.</h2><p>把资源放进对象内，在析构函数中确保资源被释放。</p>
<p>对于单一区块或函数内的资源，应该在控制流离开那个区块或函数时被释放，可以利用标准库中的<code>auto_ptr</code>，即智能指针，其析构函数自动对其所指对象调用 delete。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>体现的思想：</p>
<ul>
<li>获得资源后立刻放进管理对象，即资源取得时机便是初始化时机（Resource Acquisition Is Initialization, RAII）。（在构造函数中获得资源）</li>
<li>运用析构函数确保资源被释放。（在析构函数中释放资源）</li>
</ul>
<p>注意：使用<code>auto_ptr</code>时不要让多个该指针指向同一对象，为此，它有个性质：若通过 copy constructor 或 copy assignment 复制它们，它们会变成 null。</p>
<p>这意味着<code>auto_ptr</code>并非管理动态分配资源的神兵利器，例如，STL 容器要求其元素发挥正常的复制行为，所以这些容器容不得<code>auto_ptr</code>。</p>
<p>它的一个替代方案是引用计数型智慧指针（reference-counting smart pointer，RCSP）。追踪有多少对象指向该资源，实现类似垃圾回收（garbage collection）的行为，不同的是无法打破环状引用（cycles of references）。它的一种实现就是 TR1 的tr1::shared_ptr。</p>
<p>注意，这两个方案都是在其析构函数中做 delete 而不是 delete[]。因此不能用在动态分配而得的 array 身上，即便它能通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; aps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>]);</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; spi(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>]);</span><br></pre></td></tr></table></figure>
<p>这种时候推荐用 vector 和 string。</p>
<h2 id="条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes"><a href="#条款14：Think-carefully-about-copying-behavior-in-resource-managing-classes" class="headerlink" title="条款14：Think carefully about copying behavior in resource-managing classes."></a>条款14：Think carefully about copying behavior in resource-managing classes.</h2><p>有时你需要简历自己的资源管理类，一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Lock(Mutex* pm) : mutexPtr(pm)&#123;</span><br><span class="line">        lock(mutexptr);			<span class="comment">// 构造时加锁</span></span><br><span class="line">    &#125;							<span class="comment">// 析构时释放</span></span><br><span class="line">    ~Lock()&#123;</span><br><span class="line">        unlock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Mutex *mutexPtr;		<span class="comment">// 互斥器对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这很好，但如果Lock对象被复制（一个RAII对象被复制），会发生什么事？可能的选择：</p>
<ul>
<li>禁止复制。</li>
<li>引用计数法。对这个例子，可以将 mutexPtr 改为 <code>tr1::shared_ptr</code>类型，但由于引用次数为0时默认执行的是释放操作而不是 unlock，需要在构造时为它指定第二个参数：删除器（deleter）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)&#123;		// 增加了一个参数</span><br><span class="line">        lock(mutexPtr.get());								<span class="comment">// 使用get，条款15。</span></span><br><span class="line">    &#125;					</span><br><span class="line">    <span class="comment">// 不用再定义析构函数。</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;		<span class="comment">// 互斥器对象使用 shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line">Mutex m;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>复制底部资源。即深度复制（deep copying）。</li>
<li>转移底部资源的拥有权。</li>
</ul>
<h2 id="条款15：Provide-access-to-raw-resources-in-resource-managing-class"><a href="#条款15：Provide-access-to-raw-resources-in-resource-managing-class" class="headerlink" title="条款15：Provide access to raw resources in resource-managing class"></a>条款15：Provide access to raw resources in resource-managing class</h2><p>例如你使用<code>auto_ptr</code>或<code>tr1::shared_ptr</code>对某类对象进行管理，而 API 要求使用该对象的原始指针。这时可用 get() 成员函数进行显式转换，获得智能指针内部的原始指针（的复件）。当然，这两个类也实现了<code>operator*</code>和<code>operator-&gt;</code>，用于隐式转换。</p>
<p>如果是自己写的类，也可提供类似 get() 的接口。也最好提供隐式转换的接口，如从<code>auto_ptr&lt;Font&gt;</code>转为<code>FontHandle</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样会增加出错的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Font f1(getFont());</span><br><span class="line">FontHandle f2 = f1;		<span class="comment">// 会执行隐式转换后复制，而不是直接复制。</span></span><br></pre></td></tr></table></figure>
<p>所以不太推荐，要权衡。</p>
<p>RAII 类暴露原始资源与“封装性”并不矛盾，它的存在并不是为了封装而是为了确保一个特殊行为——资源释放——会放生。</p>
<h2 id="条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete"><a href="#条款16：Use-the-same-form-in-corresponding-uses-of-new-and-delete" class="headerlink" title="条款16：Use the same form in corresponding uses of new and delete"></a>条款16：Use the same form in corresponding uses of new and delete</h2><p>new 用 delete，new …[x] 用 delete[]，混用会产生未定义的行为。</p>
<p>尽量避免对数组类型进行 typedef。</p>
<h2 id="条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements"><a href="#条款17：Store-newed-objects-in-smart-pointers-in-standalone-statements" class="headerlink" title="条款17：Store newed objects in smart pointers in standalone statements."></a>条款17：Store newed objects in smart pointers in standalone statements.</h2><p>以独立语句将新对象置于智能指针，否则有资源泄漏的风险。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>
<p>因为 C++ 编译器未必是在 shared_ptr 将新对象添加进来之前执行 priority()，若这时 priority() 出错，新资源的指针会遗失。</p>
<h1 id="4-设计与声明"><a href="#4-设计与声明" class="headerlink" title="4 设计与声明"></a>4 设计与声明</h1><h2 id="条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly"><a href="#条款18：Make-interfaces-easy-to-use-correctly-and-hard-to-use-incorrectly" class="headerlink" title="条款18：Make interfaces easy to use correctly and hard to use incorrectly."></a>条款18：Make interfaces easy to use correctly and hard to use incorrectly.</h2><ul>
<li>好的接口很容易被正确使用，不容易被误用。</li>
<li>促进被正确使用的方法包括：接口的一致性、与内置类型的行为兼容。</li>
<li>阻止误用的方法包括：建立新类型、限制类型上的操作、束缚对象值、消除客户的资源管理责任。</li>
<li>tr1::shared_ptr 支持定制型删除器，这可防范 cross-DLL problem，即在一个 DLL 中被 new 创建，却在另一个 DLL 中被 delete 销毁。</li>
<li>使用 tr1::shared_ptr 等消除某些客户错误的同时，也值得我们关注其使用成本。</li>
</ul>
<h2 id="条款19：Treat-class-design-as-type-design"><a href="#条款19：Treat-class-design-as-type-design" class="headerlink" title="条款19：Treat class design as type design."></a>条款19：Treat class design as type design.</h2><ul>
<li>新 type 的对象应该如何被创建和销毁？（构造、析构、new、delete）</li>
<li>对象的初始化和赋值有什么样的区别？</li>
<li>新 type 的对象如果被 passed by value，意味着什么？（copy constructor）</li>
<li>什么是新 type 的合法值？</li>
<li>你的新 type 需要配合某个继承图系（inheritance graph）吗？（受其束缚，如 virtual）</li>
<li>你的新 type 需要什么样的转换？</li>
<li>什么样的操作符和函数对此新 type 而言是合理的？</li>
<li>什么样的标准函数应该驳回？（声明为 private）</li>
<li>谁该取用新 type 的成员？（public/private/protected、friends）</li>
<li>什么是新 type 的未声明接口（undeclared interface）？</li>
<li>你的新 type 有多么一般化？（class template）</li>
<li>你真的需要一个新 type 吗？（使用 non-member function 或者 template？）</li>
</ul>
<h2 id="条款20：Prefer-pass-by-reference-to-const-to-pass-by-value"><a href="#条款20：Prefer-pass-by-reference-to-const-to-pass-by-value" class="headerlink" title="条款20：Prefer pass-by-reference-to-const to pass-by-value."></a>条款20：Prefer pass-by-reference-to-const to pass-by-value.</h2><p>更高效，且可避免切割问题（slicing problem）。</p>
<p>你可以合理假设“pass-by-value 并不昂贵”的唯一对象就是内置类型、STL 迭代器、函数对象。</p>
<h2 id="条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object"><a href="#条款-21：Don’t-try-to-return-a-reference-when-you-must-return-an-object" class="headerlink" title="条款 21：Don’t try to return a reference when you must return an object."></a>条款 21：Don’t try to return a reference when you must return an object.</h2><p>比如<code>operator*</code>。</p>
<p>绝不要返回一个指向 local stack 上对象的 pointer 或 reference，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。</p>
<h2 id="条款22：Declare-data-members-private"><a href="#条款22：Declare-data-members-private" class="headerlink" title="条款22：Declare data members private."></a>条款22：Declare data members private.</h2><ul>
<li>语法一致性。</li>
<li>细微划分访问控制。</li>
<li>封装性与“当其内容改变时可能造成的代码破坏量”成反比。</li>
<li>protected 并不比 public 更具封装性。</li>
</ul>
<h2 id="条款23：Prefer-non-member-non-friend-functions-to-member-functions"><a href="#条款23：Prefer-non-member-non-friend-functions-to-member-functions" class="headerlink" title="条款23：Prefer non-member non-friend functions to member functions."></a>条款23：Prefer non-member non-friend functions to member functions.</h2><p>可以增加封装性、包裹弹性（packaging flexibility）、机能扩充性。</p>
<p>比如一些便利函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;		<span class="comment">// member function的写法。</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>&#123; ... &#125;	<span class="comment">// non-member，non-friend的写法。</span></span><br></pre></td></tr></table></figure>
<p>另外，如果有很多这样的便利函数，可以按照机能划分到不同的头文件、不同的 namespace 下。</p>
<h2 id="条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters"><a href="#条款24：Declare-non-member-functions-when-type-conversions-should-apply-to-all-parameters" class="headerlink" title="条款24：Declare non-member functions when type conversions should apply to all parameters"></a>条款24：Declare non-member functions when type conversions should apply to all parameters</h2><p>比如想要创建一个实数类，让它既能实现“Rational <em> int”，又想让它能够实现“int </em> Rational”的运算（内含隐性转换），就需要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational &amp;rhs)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>注意，不用把它声明为 friend，friend 能避免就避免。</p>
<h2 id="条款25：Consider-support-for-a-non-throwing-swap"><a href="#条款25：Consider-support-for-a-non-throwing-swap" class="headerlink" title="条款25：Consider support for a non-throwing swap."></a>条款25：Consider support for a non-throwing swap.</h2><p>（有点绕）</p>
<h1 id="5-实现"><a href="#5-实现" class="headerlink" title="5 实现"></a>5 实现</h1><h2 id="条款26：Postpone-variable-definitions-as-long-as-possible"><a href="#条款26：Postpone-variable-definitions-as-long-as-possible" class="headerlink" title="条款26：Postpone variable definitions as long as possible."></a>条款26：Postpone variable definitions as long as possible.</h2><p>尽可能延后变量定义式的出现。</p>
<h2 id="条款27：Minimize-casting"><a href="#条款27：Minimize-casting" class="headerlink" title="条款27：Minimize casting."></a>条款27：Minimize casting.</h2><p>两种旧式转型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(T) expr;</span><br><span class="line">T(expr);</span><br></pre></td></tr></table></figure>
<p>四种新式转型：</p>
<ul>
<li><code>const_cast&lt;T&gt;(expr)</code>。常量性转除（cast away the constness）。</li>
<li><code>dynamic_cast&lt;T&gt;(expr)</code>。安全向下转型（safe downcasting）。执行速度很慢。</li>
<li><code>reinterpret_cast&lt;T&gt;(expr)</code>。低级转换，行为取决于编译器（不可抑制），很少用。</li>
<li><p><code>static_cast&lt;T&gt;(expr)</code>。强迫隐式转换，包括：</p>
<ul>
<li>non-const 转 const</li>
<li>int 转 double</li>
<li>void<em> 转 T</em></li>
<li>pointer-to-base 转 pointer-to-derived</li>
</ul>
</li>
</ul>
<p>唯一使用旧时转型的时机：explicit 构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line">doSomeWork(Widget(<span class="number">15</span>));</span><br><span class="line">doSomeWork(<span class="keyword">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));</span><br></pre></td></tr></table></figure>
<p>转型可能会做很多事，甚至在基类指针转化为派生类指针时会改变指针的地址。</p>
<p>dynamic_cast 一般用于将基类指针转为派生类指针，然后执行派生类中才有的函数。但尽量用派生类的指针类型或在基类中声明 virtual 来避免使用它。</p>
<p>如果转型是必要的，把它隐匿在函数中，不要交给客户。</p>
<h2 id="条款28：Avoid-returning-“handles”-to-object-internals"><a href="#条款28：Avoid-returning-“handles”-to-object-internals" class="headerlink" title="条款28：Avoid returning “handles” to object internals."></a>条款28：Avoid returning “handles” to object internals.</h2><p>避免返回指向对象内部某对象的 handles（包括 references、pointers、iterators），会破坏封装性。</p>
<p>如果是返回 const 的对象引用，记得用两个 const，即便如此，也存在着“handle 比其所指对象更长寿”的风险。</p>
<h2 id="条款29：Strive-for-exception-safe-code"><a href="#条款29：Strive-for-exception-safe-code" class="headerlink" title="条款29：Strive for exception-safe code."></a>条款29：Strive for exception-safe code.</h2><p>异常安全性的两个条件：</p>
<ul>
<li>当异常被抛出时，不泄露任何资源。</li>
<li>当异常被抛出时，不允许数据败坏。</li>
</ul>
<p>异常安全函数（Exception-safe function）提供以下三个保证之一：</p>
<ul>
<li>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。</li>
<li>强烈保证：如果异常被抛出，程序状态不改变（恢复到调用前的状态）。（copy-and-swap）</li>
<li>不抛掷（nothrow）保证：承诺绝不抛出异常，</li>
</ul>
<p>（有个例子没仔细看）</p>
<h2 id="条款30：Understand-the-ins-and-outs-of-inlining"><a href="#条款30：Understand-the-ins-and-outs-of-inlining" class="headerlink" title="条款30：Understand the ins and outs of inlining."></a>条款30：Understand the ins and outs of inlining.</h2><ul>
<li>将大多数 inlining 限制在小型、被频繁使用的函数上。</li>
<li>不要只因为 function templates 出现在头文件，将就它们声明为 inline。</li>
</ul>
<h2 id="条款31：Minimize-compilation-dependecies-between-files"><a href="#条款31：Minimize-compilation-dependecies-between-files" class="headerlink" title="条款31：Minimize compilation dependecies between files."></a>条款31：Minimize compilation dependecies between files.</h2><p>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。可以使用 Handle classes 和 Interface classes。</p>
<p>程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用。</p>
<p>一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; create(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">        <span class="keyword">const</span> Date&amp; birthday</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday)</span><br><span class="line">        : theName(name), theBirthday(birthday)</span><br><span class="line">        &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson()&#123; &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>; 			<span class="comment">//略去实现</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span> <span class="keyword">const</span></span>;		<span class="comment">//略去实现</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; Person::create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name, </span><br><span class="line">                                            <span class="keyword">const</span> Date&amp; birthday)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Person&gt; pp(Person::create(name, dateOfBirth));</span><br></pre></td></tr></table></figure>
<h1 id="6-继承与面向对象设计"><a href="#6-继承与面向对象设计" class="headerlink" title="6 继承与面向对象设计"></a>6 继承与面向对象设计</h1><h2 id="条款32：Make-sure-public-inheritance-models-“is-a-”"><a href="#条款32：Make-sure-public-inheritance-models-“is-a-”" class="headerlink" title="条款32：Make sure public inheritance models “is-a.”"></a>条款32：Make sure public inheritance models “is-a.”</h2><p>public 继承意味着“is-a”，适用于 base classes 身上的每一件事一定也适用于 derived classes 身上。</p>
<h2 id="条款33：Avoid-hiding-inherited-names"><a href="#条款33：Avoid-hiding-inherited-names" class="headerlink" title="条款33：Avoid hiding inherited names."></a>条款33：Avoid hiding inherited names.</h2><ul>
<li>derived classes 内的名称会遮掩 base classes 内的名称。在 public 继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用 using 声明式或转交函数（forwarding functions）。</li>
</ul>
<h2 id="条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation"><a href="#条款34：Differentiate-between-inheritance-of-interface-and-inheritance-of-implementation" class="headerlink" title="条款34：Differentiate between inheritance of interface and inheritance of implementation."></a>条款34：Differentiate between inheritance of interface and inheritance of implementation.</h2><ul>
<li>接口继承和实现继承不同 ，在 public 继承之下，derived classes 总是继承 base class 的接口。</li>
<li>pure virtual 函数只具体指定接口继承。</li>
<li>impure virtual 函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual 函数具体指定接口继承以及强制性实现继承。</li>
</ul>
<h2 id="条款35：Consider-alternatives-to-virtual-functions"><a href="#条款35：Consider-alternatives-to-virtual-functions" class="headerlink" title="条款35：Consider alternatives to virtual functions"></a>条款35：Consider alternatives to virtual functions</h2><p>virtual 的替代方案：</p>
<ul>
<li>使用 non-virtual interface（NVI）手法，那是 Template Method 设计模式的一种特殊模式。它以 public non-virtual 成员函数包裹较低访问性（private 或 protected）的 virtual 函数。</li>
<li>将 virtual 函数替换为“函数指针成员变量”，这是 Strategy 设计模式的一种分解表现形式。</li>
<li>以 tr1::function 成员变量替换 virtual 函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是 Strategy 设计模式的某种形式。</li>
<li>将继承体系内的 vitual 函数替换为另一个继承体系的 virtual 函数。这是 Strategy 设计模式的传统实现手法。</li>
</ul>
<h2 id="条款36：Never-redefine-an-inherited-non-virtual-function"><a href="#条款36：Never-redefine-an-inherited-non-virtual-function" class="headerlink" title="条款36：Never redefine an inherited non-virtual function."></a>条款36：Never redefine an inherited non-virtual function.</h2><h2 id="条款37：Never-redefine-a-function’s-inherited-default-parameter-value"><a href="#条款37：Never-redefine-a-function’s-inherited-default-parameter-value" class="headerlink" title="条款37：Never redefine a function’s inherited default parameter value."></a>条款37：Never redefine a function’s inherited default parameter value.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;</span><br><span class="line">pr-&gt;draw();</span><br></pre></td></tr></table></figure>
<ul>
<li>Rectangle 中赋予了不同的缺省参数值，很槽糕。</li>
<li>这里 pr 调用的是派生类复写后的 virtual 函数，但是缺省参数不是 Green 而是 Red（由静态类型决定）。</li>
<li>使用virtual 函数的替代设计，如 NVI（non-virtual interface）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        doDraw(color);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span><span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition"><a href="#条款38：Model-“has-a”-or-“is-implemented-in-terms-of”-through-composition" class="headerlink" title="条款38：Model “has-a” or “is-implemented-in-terms-of” through composition."></a>条款38：Model “has-a” or “is-implemented-in-terms-of” through composition.</h2><p>复合（composition），同义词有分层（layering）、内含（containment）、聚合（aggregation）、内嵌（embedding）等。它的意义（has-a）和 public 继承（is-a）完全不同。</p>
<h2 id="条款39：Use-private-inheritance-judiciously"><a href="#条款39：Use-private-inheritance-judiciously" class="headerlink" title="条款39：Use private inheritance judiciously."></a>条款39：Use private inheritance judiciously.</h2><ul>
<li>private 继承意味着 is-implemented-in-terms-of（根据某物实现出）。通常比复合（composition）的级别低，但当派生类需要访问 protected base class 的成员，或需重新定义继承而来的 virtual 函数时，这么设计是合理的。</li>
<li>和复合不同，private 继承可以造成 empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li>
</ul>
<h2 id="条款40：Use-multiple-inheritance-judiciously"><a href="#条款40：Use-multiple-inheritance-judiciously" class="headerlink" title="条款40：Use multiple inheritance judiciously."></a>条款40：Use multiple inheritance judiciously.</h2><ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对 virtual 继承的需要。</li>
<li>virtual 继承会增加大小、速度、初始化及赋值复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具使用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public 继承某个 Interface class”和“private 继承某个协助实现的 class”的组合。</li>
</ul>
<h1 id="7-模板和范型编程"><a href="#7-模板和范型编程" class="headerlink" title="7 模板和范型编程"></a>7 模板和范型编程</h1><h2 id="条款41：Understand-implicit-interfaces-and-compile-time-polymorphism"><a href="#条款41：Understand-implicit-interfaces-and-compile-time-polymorphism" class="headerlink" title="条款41：Understand implicit interfaces and compile-time polymorphism."></a>条款41：Understand implicit interfaces and compile-time polymorphism.</h2><ul>
<li>classes 和 templates 都支持接口（interfaces）和多态（polymorphism）。</li>
<li>对 classes 而言接口是显式的，以函数签名为中心。多态则是通过 virtual 函数发生于运行期。</li>
<li>对 template 参数而言，接口是隐式的，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析，发生于编译期。</li>
</ul>
<h2 id="条款42：Understand-the-two-meanings-of-typename"><a href="#条款42：Understand-the-two-meanings-of-typename" class="headerlink" title="条款42：Understand the two meanings of typename."></a>条款42：Understand the two meanings of typename.</h2><ul>
<li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li>
<li>typename 还有个功能是标识嵌套从属类型名称（nested dependent name）。但不得在 base class lists 或 member initialization list 内使用。</li>
</ul>
<p>一个正确的使用例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条款43：Know-how-to-access-names-in-templatized-base-classes"><a href="#条款43：Know-how-to-access-names-in-templatized-base-classes" class="headerlink" title="条款43：Know how to access names in templatized base classes."></a>条款43：Know how to access names in templatized base classes.</h2><p>当我们从 Object Oriented C++ 跨进 Template C++ 后，继承就没有那样畅行无阻了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span>:</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        sendClear(info);		<span class="comment">// 调用基类函数，无法通过编译。</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种解决方式：</p>
<ol>
<li>调用前加上<code>this-&gt;</code>。</li>
<li>使用using声明式。</li>
<li>使用作用域声明符明确指示，但会关闭 virtual 绑定行为。</li>
</ol>
<h2 id="条款44：Factor-parameter-independent-code-out-of-templates"><a href="#条款44：Factor-parameter-independent-code-out-of-templates" class="headerlink" title="条款44：Factor parameter-independent code out of templates."></a>条款44：Factor parameter-independent code out of templates.</h2><ul>
<li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li>
<li>因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。</li>
<li>因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Meng Fanze</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/04/10/《Effective C++》笔记/">http://ifanze.cn/2018/04/10/《Effective C++》笔记/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请在评论区说明。</li></ul></div><br><div class="tags"><a href="/tags/C/">C++</a></div><div class="post-nav"><a class="pre" href="/2018/04/16/libevent笔记/">libevent笔记</a><a class="next" href="/2018/02/23/Docker-CheatSheet/">Docker CheatSheet</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'kfIuT7r4gG6hnmNl3uQ5vOqp-gzGzoHsz',
  appKey:'59tx3uBM3K1Ao4JFH5oE3VEK',
  placeholder:'Welcome~',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ifanze.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/homebrew/" style="font-size: 15px;">homebrew</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/《C-Primer》/" style="font-size: 15px;">《C++ Primer》</a> <a href="/tags/libevent/" style="font-size: 15px;">libevent</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ifanze.cn" title="欢迎友链～" target="_blank">欢迎友链～</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Meng Fanze's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>