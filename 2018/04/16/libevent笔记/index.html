<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="孟凡泽的博客"><title>libevent笔记 | Meng Fanze's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">libevent笔记</h1><a id="logo" href="/.">Meng Fanze's Blog</a><p class="description">C++、Web、Game</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">libevent笔记</h1><div class="post-meta">Apr 16, 2018<span> | </span><span class="category"><a href="/categories/笔记/">笔记</a></span></div><a class="disqus-comment-count" href="/2018/04/16/libevent笔记/#vcomment"><span class="valine-comment-count" data-xid="/2018/04/16/libevent笔记/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Design-Goals"><span class="toc-text">1 Design Goals</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Components"><span class="toc-text">2 Components</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Libraries"><span class="toc-text">3 Libraries</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Headers"><span class="toc-text">4 Headers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Setup"><span class="toc-text">5 Setup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Log"><span class="toc-text">Log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handle-Error"><span class="toc-text">Handle Error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manage-Memory"><span class="toc-text">Manage Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locks-and-threading"><span class="toc-text">Locks and threading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug"><span class="toc-text">Debug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Detect-Version"><span class="toc-text">Detect Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Free-global-structures"><span class="toc-text">Free global structures</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-event-base"><span class="toc-text">6 event_base</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Recognized-backend"><span class="toc-text">Recognized backend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Turn-off"><span class="toc-text">Turn off</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#New-amp-free-amp-reinit"><span class="toc-text">New &amp; free &amp; reinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#New-with-event-config"><span class="toc-text">New with event_config</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#backend"><span class="toc-text">backend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorities"><span class="toc-text">priorities</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Event-loop"><span class="toc-text">7 Event loop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Run"><span class="toc-text">Run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stop"><span class="toc-text">stop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#internal-time-cache"><span class="toc-text">internal time cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dump-status"><span class="toc-text">dump status</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterate-events"><span class="toc-text">iterate events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#obsolete-methods"><span class="toc-text">obsolete methods</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Events"><span class="toc-text">8 Events</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#conditions"><span class="toc-text">conditions:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#status"><span class="toc-text">status:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#construct"><span class="toc-text">construct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timeout-only-events"><span class="toc-text">Timeout-only events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Signal-events"><span class="toc-text">Signal events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap-allocation-events"><span class="toc-text">Heap-allocation events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pending-and-Non-pending"><span class="toc-text">Pending and Non-pending</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspecting-Event-Status"><span class="toc-text">Inspecting Event Status</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#One-off-events"><span class="toc-text">One-off events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manually-activating-an-event"><span class="toc-text">Manually activating an event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optimizing-common-timeouts"><span class="toc-text">Optimizing common timeouts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Distinguish-an-initialized-event-and-a-cleared-event"><span class="toc-text">Distinguish an initialized event and a cleared event</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Helper"><span class="toc-text">9 Helper</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Types"><span class="toc-text">Basic Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timer"><span class="toc-text">Timer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv6"><span class="toc-text">IPv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure"><span class="toc-text">Structure</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Bufferevents"><span class="toc-text">10 Bufferevents</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Type"><span class="toc-text">Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Watermarks"><span class="toc-text">Watermarks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callbacks"><span class="toc-text">Callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Option-Flags"><span class="toc-text">Option Flags</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Socket-based-Bufferevents"><span class="toc-text">11 Socket-based Bufferevents</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Create"><span class="toc-text">Create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Launch"><span class="toc-text">Launch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generic-operations"><span class="toc-text">Generic operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manipulate-Data"><span class="toc-text">Manipulate Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-specific-functions"><span class="toc-text">Type-specific functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locking-and-Unlocking"><span class="toc-text">Locking and Unlocking</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Bufferevents-Advanced-topics"><span class="toc-text">12 Bufferevents: Advanced topics</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Paired-bufferevents"><span class="toc-text">Paired bufferevents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filtering-bufferevents"><span class="toc-text">Filtering bufferevents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Limit-max-single-r-w-size"><span class="toc-text">Limit max single r/w size</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rate-limiting"><span class="toc-text">Rate-limiting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rate-limiting-on-group"><span class="toc-text">Rate-limiting on group</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspecting-rate-limiting"><span class="toc-text">Inspecting rate-limiting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manually-adjusting-rate-limits"><span class="toc-text">Manually adjusting rate limits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting-the-smallest-share-possible-in-a-rate-limited-group"><span class="toc-text">Setting the smallest share possible in a rate-limited group </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bufferevents-and-SSL"><span class="toc-text">Bufferevents and SSL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Evbuffers"><span class="toc-text">13 Evbuffers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Create-amp-free"><span class="toc-text">Create &amp; free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread-Safety"><span class="toc-text">Thread-Safety</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspecting-an-evbuffer"><span class="toc-text">Inspecting an evbuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Adding-Data"><span class="toc-text">Adding Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Move-Data"><span class="toc-text">Move Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Adding-Data-to-the-front"><span class="toc-text">Adding Data to the front</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rearranging-the-internal-layout"><span class="toc-text">Rearranging the internal layout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remove-Data"><span class="toc-text">Remove Data </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Copying-Data"><span class="toc-text">Copying Data</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Line-oriented-Input"><span class="toc-text">Line-oriented Input</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Searching"><span class="toc-text">Searching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspecting-data-without-copying-it"><span class="toc-text">Inspecting data without copying it</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Adding-data-to-an-evbuffer-directly"><span class="toc-text">Adding data to an evbuffer directly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Network-IO-with-evbuffers"><span class="toc-text">Network IO with evbuffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Evbuffers-and-callbacks"><span class="toc-text">Evbuffers and callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Avoiding-data-copies-with-evbuffer-based-IO"><span class="toc-text">Avoiding data copies with evbuffer-based IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Adding-a-file-to-an-evbuffer"><span class="toc-text">Adding a file to an evbuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fine-grained-control-with-file-segments"><span class="toc-text">Fine-grained control with file segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Adding-an-evbuffer-to-another-by-reference"><span class="toc-text">Adding an evbuffer to another by reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Making-an-evbuffer-add-or-remove-only"><span class="toc-text">Making an evbuffer add- or remove-only</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Connection-listeners-evconnlistener"><span class="toc-text">14 Connection listeners: evconnlistener </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Use-DNS"><span class="toc-text">15 Use DNS</span></a></li></ol></div></div><div class="post-content"><p><a href="https://github.com/nmathewson/libevent-book">https://github.com/nmathewson/libevent-book</a></p>
<a id="more"></a>
<!-- toc -->
<p>Libevent is a library for writing fast portable nonblocking IO. </p>
<h1 id="1-Design-Goals"><a href="#1-Design-Goals" class="headerlink" title="1 Design Goals"></a>1 Design Goals</h1><ul>
<li>Portability</li>
<li>Speed</li>
<li>Scalability</li>
<li>Convenience</li>
</ul>
<h1 id="2-Components"><a href="#2-Components" class="headerlink" title="2 Components"></a>2 Components</h1><ul>
<li>evutil</li>
<li>event &amp; event_base</li>
<li>bufferevent</li>
<li>evbuffer</li>
<li>evhttp</li>
<li>evdns</li>
<li>evrpc</li>
</ul>
<h1 id="3-Libraries"><a href="#3-Libraries" class="headerlink" title="3 Libraries"></a>3 Libraries</h1><ul>
<li>libevent_core</li>
<li>libevent_extra</li>
<li>libevent [outdated]</li>
<li>libevent_pthreads</li>
<li>libevent_openssl</li>
</ul>
<h1 id="4-Headers"><a href="#4-Headers" class="headerlink" title="4 Headers"></a>4 Headers</h1><ul>
<li>API headers</li>
<li>Compatibility headers</li>
<li>Structure headers</li>
</ul>
<h1 id="5-Setup"><a href="#5-Setup" class="headerlink" title="5 Setup"></a>5 Setup</h1><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_log_callback</span><span class="params">(event_log_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_log_cb)(int severity, const char *msg);</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_DEBUG 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_MSG   1</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_WARN  2 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_ERR   3 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_logging</span><span class="params">(<span class="keyword">ev_uint32_t</span> which)</span></span>;</span><br><span class="line"><span class="comment">// #define EVENT_DBG_NONE 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_DBG_ALL 0xffffffffu</span></span><br></pre></td></tr></table></figure>
<h2 id="Handle-Error"><a href="#Handle-Error" class="headerlink" title="Handle Error"></a>Handle Error</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_fatal_callback</span><span class="params">(event_fatal_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_fatal_cb)(int err);</span></span><br></pre></td></tr></table></figure>
<h2 id="Manage-Memory"><a href="#Manage-Memory" class="headerlink" title="Manage Memory"></a>Manage Memory</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_mem_functions</span><span class="params">(</span></span></span><br><span class="line">    void *(*malloc_fn)(size_t sz),</span><br><span class="line">    <span class="keyword">void</span> *(*realloc_fn)(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz),</span><br><span class="line">    <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr));</span><br></pre></td></tr></table></figure>
<h2 id="Locks-and-threading"><a href="#Locks-and-threading" class="headerlink" title="Locks and threading"></a>Locks and threading</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef WIN32</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_windows_threads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef _EVENT_HAVE_PTHREAD</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_pthreads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_PTHREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_lock_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_lock_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_lock_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int lock_api_version; </span></span><br><span class="line"><span class="comment">//     unsigned supported_locktypes; </span></span><br><span class="line"><span class="comment">//     void *(*alloc)(unsigned locktype); </span></span><br><span class="line"><span class="comment">//     void (*free)(void *lock, unsigned locktype); </span></span><br><span class="line"><span class="comment">//     int (*lock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">//     int (*unlock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define EVTHREAD_WRITE  0x04 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_READ   0x08 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_TRY    0x10</span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_RECURSIVE 1 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_READWRITE 2 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCK_API_VERSION 1 </span></span><br><span class="line"></span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_condition_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_condition_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_condition_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int condition_api_version; </span></span><br><span class="line"><span class="comment">//     void *(*alloc_condition)(unsigned condtype); </span></span><br><span class="line"><span class="comment">//     void (*free_condition)(void *cond); </span></span><br><span class="line"><span class="comment">//     int (*signal_condition)(void *cond, int broadcast); </span></span><br><span class="line"><span class="comment">//     int (*wait_condition)(void *cond, void *lock, const struct timeval *timeout); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_enable_lock_debugging</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_debug_unassign</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Detect-Version"><a href="#Detect-Version" class="headerlink" title="Detect Version"></a>Detect Version</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION_NUMBER 0x02000300 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION <span class="meta-string">"2.0.3-alpha"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_get_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">ev_uint32_t</span> event_get_version_number(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Free-global-structures"><a href="#Free-global-structures" class="headerlink" title="Free global structures"></a>Free global structures</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">libevent_global_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="6-event-base"><a href="#6-event-base" class="headerlink" title="6 event_base"></a>6 event_base</h1><h2 id="Recognized-backend"><a href="#Recognized-backend" class="headerlink" title="Recognized backend"></a>Recognized backend</h2><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>devpoll</li>
<li>evport</li>
<li>win32</li>
</ul>
<h2 id="Turn-off"><a href="#Turn-off" class="headerlink" title="Turn off"></a>Turn off</h2><ul>
<li>Set environment variables. e.g. <code>EVENT_NOKQUEUE</code>.</li>
<li>Call <code>event_config_avoid_method()</code> below.</li>
</ul>
<h2 id="New-amp-free-amp-reinit"><a href="#New-amp-free-amp-reinit" class="headerlink" title="New &amp; free &amp; reinit"></a>New &amp; free &amp; reinit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_free</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;      <span class="comment">// call after fork() in child proc</span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure>
<h2 id="New-with-event-config"><a href="#New-with-event-config" class="headerlink" title="New with event_config"></a>New with event_config</h2><p>To avoid specific available backend by name, or by feature.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_config *<span class="title">event_config_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct event_base <span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_config_free</span><span class="params">(struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg,<span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_require_features</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_method_feature feature)</span></span>;</span><br><span class="line"><span class="comment">// enum event_method_feature &#123;     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_ET = 0x01,     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_O1 = 0x02,     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_FDS = 0x04, </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_flag</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_base_config_flag flag)</span></span>;</span><br><span class="line"><span class="comment">// enum event_base_config_flag &#123;</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NOLOCK = 0x01,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_IGNORE_ENV = 0x02, </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_num_cpus_hint</span><span class="params">(struct event_config *cfg, <span class="keyword">int</span> cpus)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_max_dispatch_interval</span><span class="params">(struct event_config *cfg, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timeval *max_interval, <span class="keyword">int</span> max_callbacks, <span class="keyword">int</span> min_priority)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">event_get_supported_methods</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">enum</span> event_method_feature <span class="title">event_base_get_features</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>;</span><br><span class="line">event_get_method()          <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure>
<h2 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> n_priorities)</span></span>;    <span class="comment">// 1 ~ EVENT_MAX_PRIORITIES</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_get_npriorities</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line">event_priority_init()       <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure>
<h1 id="7-Event-loop"><a href="#7-Event-loop" class="headerlink" title="7 Event loop"></a>7 Event loop</h1><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>default: run until no more events registered in it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="comment">// #define EVLOOP_ONCE             0x01 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NONBLOCK         0x02 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br></pre></td></tr></table></figure>
<h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct timeval *tv)</span></span>;     <span class="comment">// exit after all active events cb done.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;  <span class="comment">// exit after current one cb done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_exit</span><span class="params">(struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_break</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopcontinue</span><span class="params">(struct event_base *)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="internal-time-cache"><a href="#internal-time-cache" class="headerlink" title="internal time cache"></a>internal time cache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_gettimeofday_cached</span><span class="params">(struct event_base *base, struct timeval *tv_out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_update_cache_time</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="dump-status"><a href="#dump-status" class="headerlink" title="dump status"></a>dump status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_dump_events</span><span class="params">(struct event_base *base, FILE *f)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="iterate-events"><a href="#iterate-events" class="headerlink" title="iterate events"></a>iterate events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_foreach_event</span><span class="params">(struct event_base *base, event_base_foreach_event_cb fn, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// typedef int (*event_base_foreach_event_cb)(const struct event_base *, const struct event *, void *)</span></span><br></pre></td></tr></table></figure>
<h2 id="obsolete-methods"><a href="#obsolete-methods" class="headerlink" title="obsolete methods"></a>obsolete methods</h2><ul>
<li><code>event_dispatch()</code></li>
<li><code>event_loop()</code></li>
<li><code>event_loopexit()</code></li>
<li><code>event_loopbreak()</code></li>
</ul>
<h1 id="8-Events"><a href="#8-Events" class="headerlink" title="8 Events"></a>8 Events</h1><h2 id="conditions"><a href="#conditions" class="headerlink" title="conditions:"></a>conditions:</h2><ul>
<li>fd being ready to read from or write to.</li>
<li>fd becoming ready to read from or write to (Edge-triggered IO only).</li>
<li>a timeout expiring.</li>
<li>a signal occuring.</li>
<li>a user-triggered event.</li>
</ul>
<h2 id="status"><a href="#status" class="headerlink" title="status:"></a>status:</h2><ul>
<li>initialized -&gt; pending (by <code>add</code>)</li>
<li>pending -&gt; active (condition trigger an event occur, cb run)</li>
<li>active -&gt; pending (persistent) -&gt; <code>delete</code> -&gt; non-pending -&gt; <code>add</code> -&gt; pending</li>
<li>active -&gt; non-pending (non-persistent)</li>
</ul>
<h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, event_callback_fn cb, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="comment">// typedef void (*event_callback_fn)(evutil_socket_t, short, void *); </span></span><br><span class="line"><span class="comment">// #define EV_TIMEOUT      0x01 </span></span><br><span class="line"><span class="comment">// #define EV_READ         0x02 </span></span><br><span class="line"><span class="comment">// #define EV_WRITE        0x04 </span></span><br><span class="line"><span class="comment">// #define EV_SIGNAL       0x08 </span></span><br><span class="line"><span class="comment">// #define EV_PERSIST      0x10 </span></span><br><span class="line"><span class="comment">// #define EV_ET           0x20 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>You can’t create an event that receives itself as a cb argument. Instead:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_self_cbarg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Timeout-only-events"><a href="#Timeout-only-events" class="headerlink" title="Timeout-only events"></a>Timeout-only events</h2><p>no benefit beyond clarifying your code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(base, callback, arg) \     </span></span><br><span class="line">event_new((base), <span class="number">-1</span>, <span class="number">0</span>, (callback), (arg)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv) \    </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_pending(ev, tv_out) \     </span></span><br><span class="line">event_pending((ev), EV_TIMEOUT, (tv_out))</span><br></pre></td></tr></table></figure>
<h2 id="Signal-events"><a href="#Signal-events" class="headerlink" title="Signal events"></a>Signal events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(base, signum, cb, arg) \     </span></span><br><span class="line">event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv) \     </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, what, tv_out) \     </span></span><br><span class="line">event_pending((ev), (what), (tv_out))</span><br></pre></td></tr></table></figure>
<ul>
<li>Don’t set a timeout on a signal event.</li>
<li>It’s safe to call functions that you aren’t supposed to call from a regulat POSIX signal handler.</li>
<li>With most backends, only one event_base per process at a time can be listening for signals. If you add signal events to two event_base at once - even if the signals are different - only one event_base will receive signals. (kqueue doesn’t have this limitation.)</li>
</ul>
<h2 id="Heap-allocation-events"><a href="#Heap-allocation-events" class="headerlink" title="Heap-allocation events"></a>Heap-allocation events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int event_assign(struct event *event, struct event_base *base, evutil_socket_t fd, short what, void (*callback)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_assign(event, base, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, <span class="number">-1</span>, <span class="number">0</span>, callback, arg) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(event, base, signum, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, signum, EV_SIGNAL|EV_PERSIST, callback, arg)</span><br></pre></td></tr></table></figure>
<ul>
<li>Your code won’t be binary-compatible with future versions of libevent as the size of a event may differ. To check, make use of this function:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> event_get_struct_event_size(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>May return a value less than <code>sizeof(event)</code> because of padding bytes at the end.</li>
<li>Never call <code>event_assign</code> on an event that is already pending. call <code>event_del()</code> first.</li>
</ul>
<h2 id="Pending-and-Non-pending"><a href="#Pending-and-Non-pending" class="headerlink" title="Pending and Non-pending"></a>Pending and Non-pending</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_remove_timer</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *event, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Inspecting-Event-Status"><a href="#Inspecting-Event-Status" class="headerlink" title="Inspecting Event Status"></a>Inspecting Event Status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, <span class="keyword">short</span> what, struct timeval *tv_out)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> event_get_fd(<span class="keyword">const</span> struct event *ev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; <span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event, struct event_base **base_out, <span class="keyword">evutil_socket_t</span> *fd_out, <span class="keyword">short</span> *events_out, event_callback_fn *callback_out, <span class="keyword">void</span> **arg_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event *<span class="title">event_base_get_running_event</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="One-off-events"><a href="#One-off-events" class="headerlink" title="One-off events"></a>One-off events</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure>
<ul>
<li>If you don’t need to add an event more than once, or delete it once it has been added, and it doesn’t have to persistent, use <code>event_base_once</code>.</li>
<li>It doesn’t support <code>EV_SIGNAL</code> or <code>EV_PERSIST</code>.</li>
<li>Can’t be deleted or manually activated.</li>
</ul>
<h2 id="Manually-activating-an-event"><a href="#Manually-activating-an-event" class="headerlink" title="Manually activating an event"></a>Manually activating an event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *ev, <span class="keyword">int</span> what, <span class="keyword">short</span> ncalls)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Don’t calling <code>event_active</code> recursively on the same event.</li>
</ul>
<h2 id="Optimizing-common-timeouts"><a href="#Optimizing-common-timeouts" class="headerlink" title="Optimizing common timeouts"></a>Optimizing common timeouts</h2><ul>
<li>Libevent use a binary algorithm to keep track of pending events’ timeouts, which gives performance of O(lg n) for adding and deleting each event timeout.</li>
<li>If you have a large number of events with the same timeout, a doubly-linked queue will be better.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct timeval *<span class="title">event_base_init_common_timeout</span><span class="params">( struct event_base *base, <span class="keyword">const</span> struct timeval *duration)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Distinguish-an-initialized-event-and-a-cleared-event"><a href="#Distinguish-an-initialized-event-and-a-cleared-event" class="headerlink" title="Distinguish an initialized event and a cleared event"></a>Distinguish an initialized event and a cleared event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_initialized</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_initialized(ev) event_initialized(ev) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_initialized(ev) event_initialized(ev)</span></span><br></pre></td></tr></table></figure>
<h1 id="9-Helper"><a href="#9-Helper" class="headerlink" title="9 Helper"></a>9 Helper</h1><h2 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h2><ul>
<li><p>evutil_socket_t  </p>
</li>
<li><p>ev_uint64_t       EV_UINT64_MAX       0</p>
</li>
<li>ev_int64_t        EV_INT64_MAX        EV_INT64_MIN</li>
<li>ev_uint32_t       EV_UINT32_MAX       0</li>
<li>ev_int32_t        EV_INT32_MAX        EV_INT32_MIN</li>
<li>ev_uint16_t       EV_UINT16_MAX       0</li>
<li>ev_int16_t        EV_INT16_MAX        EV_INT16_MIN</li>
<li>ev_uint8_t        EV_UINT8_MAX        0</li>
<li><p>ev_int8_t         EV_INT8_MAX         EV_INT8_MIN</p>
</li>
<li><p>ev_ssize_t        EV_SSIZE_MIN        EV_SSIZE_MAX</p>
</li>
<li>ev_off_t          </li>
<li>ev_socket_t</li>
<li>ev_intptr_t</li>
<li>ev_uintptr_t</li>
</ul>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timeradd(tvp, uvp, vvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timersub(tvp, uvp, vvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerisset(tvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timercmp(tvp, uvp, cmp)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_closesocket</span><span class="params">(<span class="keyword">evutil_socket_t</span> s)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SOCKET_ERROR() </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SET_SOCKET_ERROR(errcode) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_geterror(sock) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_error_to_string(errcode)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_nonblocking</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_listen_socket_reuseable</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_closeonexec</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">evutil_socket_t</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_int64_t</span> evutil_strtoll(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">char</span> **endptr, <span class="keyword">int</span> base);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_snprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strcasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strncasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">evutil_inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_parse_sockaddr_port</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, struct sockaddr *out, <span class="keyword">int</span> *outlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_sockaddr_cmp</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa1, <span class="keyword">const</span> struct sockaddr *sa2, <span class="keyword">int</span> include_port)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_offsetof(type, field) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_get_bytes</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_secure_rng_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_add_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dat, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="10-Bufferevents"><a href="#10-Bufferevents" class="headerlink" title="10 Bufferevents"></a>10 Bufferevents</h1><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><ul>
<li>socket-based bufferevents</li>
<li>asynchronous-IO bufferevents (Windows only, experimental)</li>
<li>filtering bufferevents</li>
<li>paired bufferevents</li>
</ul>
<h2 id="Watermarks"><a href="#Watermarks" class="headerlink" title="Watermarks"></a>Watermarks</h2><ul>
<li>Read low-water mark</li>
<li>Read high-water mark</li>
<li>Write low-water mark</li>
<li>Write high-water mark</li>
</ul>
<h2 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h2><ul>
<li><code>BEV_EVENT_READING</code></li>
<li><code>BEV_EVENT_WRITING</code></li>
<li><code>BEV_EVENT_ERROR</code></li>
<li><code>BEV_EVENT_TIMEOUT</code></li>
<li><code>BEV_EVENT_EOF</code></li>
<li><code>BEV_EVENT_CONNECTED</code></li>
</ul>
<h2 id="Option-Flags"><a href="#Option-Flags" class="headerlink" title="Option Flags"></a>Option Flags</h2><ul>
<li><code>BEV_OPT_CLOSE_ON_FREE</code></li>
<li><code>BEV_OPT_THREADSAFE</code></li>
<li><code>BEV_OPT_DEFER_CALLBACKS</code></li>
<li><code>BEV_OPT_UNLOCK_CALLBACKS</code></li>
</ul>
<h1 id="11-Socket-based-Bufferevents"><a href="#11-Socket-based-Bufferevents" class="headerlink" title="11 Socket-based Bufferevents"></a>11 Socket-based Bufferevents</h1><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">enum</span> bufferevent_options options)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fd 需要时 non-blocking 的，可以使用<code>evutil_make_socket_nonblocking()</code>。</li>
<li>不想现在指定 fd 可以将其设为 -1。</li>
</ul>
<h2 id="Launch"><a href="#Launch" class="headerlink" title="Launch"></a>Launch</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, struct sockaddr *address, <span class="keyword">int</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect_hostname</span><span class="params">(struct bufferevent *bev, struct evdns_base *dns_base, <span class="keyword">int</span> family, <span class="keyword">const</span> <span class="keyword">char</span> *hostname, <span class="keyword">int</span> port)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_get_dns_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>If no socket set, it will allocates a new nonblocking one.</li>
</ul>
<h2 id="Generic-operations"><a href="#Generic-operations" class="headerlink" title="Generic operations"></a>Generic operations</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_free</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setcb</span><span class="params">(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, <span class="keyword">void</span> *cbarg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_getcb</span><span class="params">(struct bufferevent *bufev, bufferevent_data_cb *readcb_ptr, bufferevent_data_cb *writecb_ptr, bufferevent_event_cb *eventcb_ptr, <span class="keyword">void</span> **cbarg_ptr)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx); </span></span><br><span class="line"><span class="comment">// typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_enable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>; <span class="function"><span class="keyword">void</span> <span class="title">bufferevent_disable</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events)</span></span>; <span class="comment">// EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">bufferevent_get_enabled</span><span class="params">(struct bufferevent *bufev)</span></span>; <span class="comment">// EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_setwatermark</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> events, <span class="keyword">size_t</span> lowmark, <span class="keyword">size_t</span> highmark)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bufferevent_free</code> will free the bufferevent as soon as possible, probably won’t flush data on write buffer.</li>
<li><code>BEV_OPT_CLOSE_ON_FREE</code> will close its transport underlying it - such as socket - when free.</li>
<li>By default, a newly created bufferevent has writing enabled, but not reading. </li>
</ul>
<h2 id="Manipulate-Data"><a href="#Manipulate-Data" class="headerlink" title="Manipulate Data"></a>Manipulate Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_input</span><span class="params">(struct bufferevent *bufev)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer *<span class="title">bufferevent_get_output</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_write_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> bufferevent_read(struct bufferevent *bufev, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size); </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_read_buffer</span><span class="params">(struct bufferevent *bufev, struct evbuffer *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_set_timeouts</span><span class="params">(struct bufferevent *bufev, <span class="keyword">const</span> struct timeval *timeout_read, <span class="keyword">const</span> struct timeval *timeout_write)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_flush</span><span class="params">(struct bufferevent *bufev, <span class="keyword">short</span> iotype, <span class="keyword">enum</span> bufferevent_flush_mode state)</span></span>; </span><br><span class="line"><span class="comment">// iotype: EV_READ, EV_WRITE, or EV_READ|EV_WRITE</span></span><br><span class="line"><span class="comment">// state: BEV_NORMAL, BEV_FLUSH, or BEV_FINISHED</span></span><br></pre></td></tr></table></figure>
<ul>
<li>It won’t be timeout if r/w is disabled or no data to r/w.</li>
<li>If timeout, invoke cb with <code>BEV_EVENT_TIMEOUT|BEV_EVENT_READING</code> or <code>BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING</code>.</li>
</ul>
<h2 id="Type-specific-functions"><a href="#Type-specific-functions" class="headerlink" title="Type-specific functions"></a>Type-specific functions</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket-based only</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_priority_set</span><span class="params">(struct bufferevent *bufev, <span class="keyword">int</span> pri)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_get_priority</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_setfd</span><span class="params">(struct bufferevent *bufev, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="keyword">evutil_socket_t</span> bufferevent_getfd(struct bufferevent *bufev);</span><br><span class="line"></span><br><span class="line"><span class="function">struct event_base *<span class="title">bufferevent_get_base</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_get_underlying</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Locking-and-Unlocking"><a href="#Locking-and-Unlocking" class="headerlink" title="Locking and Unlocking"></a>Locking and Unlocking</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_lock</span><span class="params">(struct bufferevent *bufev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_unlock</span><span class="params">(struct bufferevent *bufev)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Required threading support activated and <code>BEV_OPT_THREADSAFE</code> on creation.</li>
</ul>
<h1 id="12-Bufferevents-Advanced-topics"><a href="#12-Bufferevents-Advanced-topics" class="headerlink" title="12 Bufferevents: Advanced topics"></a>12 Bufferevents: Advanced topics</h1><h2 id="Paired-bufferevents"><a href="#Paired-bufferevents" class="headerlink" title="Paired bufferevents"></a>Paired bufferevents</h2><p>All bytes written on one are received on the other, without via the network stack.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_pair_new</span><span class="params">(struct event_base *base, <span class="keyword">int</span> options, struct bufferevent *pair[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_pair_get_partner</span><span class="params">(struct bufferevent *bev)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>BEV_OPT_CLOSE_ON_FREE</code> has no effect.</li>
<li><code>BEV_OPT_DEFER_CALLBACKS</code> is always on.</li>
</ul>
<h2 id="Filtering-bufferevents"><a href="#Filtering-bufferevents" class="headerlink" title="Filtering bufferevents"></a>Filtering bufferevents</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct bufferevent *bufferevent_filter_new(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void (*free_context)(void *), void *ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// enum bufferevent_filter_result &#123;         </span></span><br><span class="line"><span class="comment">//     BEV_OK = 0,         </span></span><br><span class="line"><span class="comment">//     BEV_NEED_MORE = 1,         </span></span><br><span class="line"><span class="comment">//     BEV_ERROR = 2 </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"><span class="comment">// typedef enum bufferevent_filter_result (*bufferevent_filter_cb)( </span></span><br><span class="line"><span class="comment">//     struct evbuffer *source, </span></span><br><span class="line"><span class="comment">//     struct evbuffer *destination, </span></span><br><span class="line"><span class="comment">//     ev_ssize_t dst_limit, </span></span><br><span class="line"><span class="comment">//     enum bufferevent_flush_mode mode, </span></span><br><span class="line"><span class="comment">//     void *ctx</span></span><br><span class="line"><span class="comment">// );</span></span><br></pre></td></tr></table></figure>
<h2 id="Limit-max-single-r-w-size"><a href="#Limit-max-single-r-w-size" class="headerlink" title="Limit max single r/w size"></a>Limit max single r/w size</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_max_single_read</span><span class="params">(struct bufferevent *bev, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_max_single_write</span><span class="params">(struct bufferevent *bev, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_single_read(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_single_write(struct bufferevent *bev);</span><br></pre></td></tr></table></figure>
<h2 id="Rate-limiting"><a href="#Rate-limiting" class="headerlink" title="Rate-limiting"></a>Rate-limiting</h2><p>algorithm: token bucket.</p>
<ul>
<li>read bucket &amp; write bucket.</li>
<li>refill rate: determines the max average rate.</li>
<li>max burst size: determines the max number of bytes that will be r/w in a single burst.</li>
<li>timing unit: smoothness of the traffic.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_RATE_LIMIT_MAX EV_SSIZE_MAX </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ev_token_bucket_cfg</span>;</span> </span><br><span class="line"><span class="function">struct ev_token_bucket_cfg *<span class="title">ev_token_bucket_cfg_new</span><span class="params">(         </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> read_rate, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> read_burst,         </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> write_rate, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">size_t</span> write_burst, c</span></span></span><br><span class="line"><span class="function"><span class="params">    onst struct timeval *tick_len</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ev_token_bucket_cfg_free</span><span class="params">(struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_set_rate_limit</span><span class="params">(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Rate-limiting-on-group"><a href="#Rate-limiting-on-group" class="headerlink" title="Rate-limiting on group"></a>Rate-limiting on group</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bufferevent_rate_limit_group</span>;</span> </span><br><span class="line"><span class="function">struct bufferevent_rate_limit_group *<span class="title">bufferevent_rate_limit_group_new</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_set_cfg</span><span class="params">(struct bufferevent_rate_limit_group *group, <span class="keyword">const</span> struct ev_token_bucket_cfg *cfg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_free</span><span class="params">(struct bufferevent_rate_limit_group *)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_add_to_rate_limit_group</span><span class="params">(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_remove_from_rate_limit_group</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Inspecting-rate-limiting"><a href="#Inspecting-rate-limiting" class="headerlink" title="Inspecting rate-limiting"></a>Inspecting rate-limiting</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_read_limit(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_write_limit(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_rate_limit_group_get_read_limit( struct bufferevent_rate_limit_group *); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_rate_limit_group_get_write_limit( struct bufferevent_rate_limit_group *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_to_read(struct bufferevent *bev); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> bufferevent_get_max_to_write(struct bufferevent *bev);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_get_totals</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_uint64_t</span> *total_read_out, <span class="keyword">ev_uint64_t</span> *total_written_out)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_rate_limit_group_reset_totals</span><span class="params">( struct bufferevent_rate_limit_group *grp)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Manually-adjusting-rate-limits"><a href="#Manually-adjusting-rate-limits" class="headerlink" title="Manually adjusting rate limits"></a>Manually adjusting rate limits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_decrement_read_limit</span><span class="params">(struct bufferevent *bev, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_decrement_write_limit</span><span class="params">(struct bufferevent *bev, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_decrement_read</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_ssize_t</span> decr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_decrement_write</span><span class="params">( struct bufferevent_rate_limit_group *grp, <span class="keyword">ev_ssize_t</span> decr)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Setting-the-smallest-share-possible-in-a-rate-limited-group"><a href="#Setting-the-smallest-share-possible-in-a-rate-limited-group" class="headerlink" title="Setting the smallest share possible in a rate-limited group "></a>Setting the smallest share possible in a rate-limited group </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_rate_limit_group_set_min_share</span><span class="params">( struct bufferevent_rate_limit_group *group, <span class="keyword">size_t</span> min_share)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Bufferevents-and-SSL"><a href="#Bufferevents-and-SSL" class="headerlink" title="Bufferevents and SSL"></a>Bufferevents and SSL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> bufferevent_ssl_state &#123;         </span><br><span class="line">    BUFFEREVENT_SSL_OPEN = <span class="number">0</span>,         </span><br><span class="line">    BUFFEREVENT_SSL_CONNECTING = <span class="number">1</span>,         </span><br><span class="line">    BUFFEREVENT_SSL_ACCEPTING = <span class="number">2</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_openssl_filter_new</span><span class="params">(struct event_base *base, struct bufferevent *underlying, SSL *ssl, <span class="keyword">enum</span> bufferevent_ssl_state state, <span class="keyword">int</span> options)</span></span>; </span><br><span class="line"><span class="function">struct bufferevent * <span class="title">bufferevent_openssl_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, SSL *ssl, <span class="keyword">enum</span> bufferevent_ssl_state state, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SSL *<span class="title">bufferevent_openssl_get_ssl</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">bufferevent_get_openssl_error</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_ssl_renegotiate</span><span class="params">(struct bufferevent *bev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_openssl_get_allow_dirty_shutdown</span><span class="params">(struct bufferevent *bev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bufferevent_openssl_set_allow_dirty_shutdown</span><span class="params">(struct bufferevent *bev, <span class="keyword">int</span> allow_dirty_shutdown)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="13-Evbuffers"><a href="#13-Evbuffers" class="headerlink" title="13 Evbuffers"></a>13 Evbuffers</h1><h2 id="Create-amp-free"><a href="#Create-amp-free" class="headerlink" title="Create &amp; free"></a>Create &amp; free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer *<span class="title">evbuffer_new</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_free</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Thread-Safety"><a href="#Thread-Safety" class="headerlink" title="Thread-Safety"></a>Thread-Safety</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_enable_locking</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *lock)</span></span>;  <span class="comment">// NULL is legal, it will allocate a new lock.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_lock</span><span class="params">(struct evbuffer *buf)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_unlock</span><span class="params">(struct evbuffer *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Inspecting-an-evbuffer"><a href="#Inspecting-an-evbuffer" class="headerlink" title="Inspecting an evbuffer"></a>Inspecting an evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> evbuffer_get_length(<span class="keyword">const</span> struct evbuffer *buf);</span><br><span class="line"><span class="keyword">size_t</span> evbuffer_get_contiguous_space(<span class="keyword">const</span> struct evbuffer *buf);</span><br></pre></td></tr></table></figure>
<h2 id="Adding-Data"><a href="#Adding-Data" class="headerlink" title="Adding Data"></a>Adding Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_printf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_vprintf</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_expand</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Move-Data"><a href="#Move-Data" class="headerlink" title="Move Data"></a>Move Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer *src)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_buffer</span><span class="params">(struct evbuffer *src, struct evbuffer *dst, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Adding-Data-to-the-front"><a href="#Adding-Data-to-the-front" class="headerlink" title="Adding Data to the front"></a>Adding Data to the front</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend</span><span class="params">(struct evbuffer *buf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_prepend_buffer</span><span class="params">(struct evbuffer *dst, struct evbuffer* src)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Rearranging-the-internal-layout"><a href="#Rearranging-the-internal-layout" class="headerlink" title="Rearranging the internal layout"></a>Rearranging the internal layout</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">evbuffer_pullup</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Remove-Data"><a href="#Remove-Data" class="headerlink" title="Remove Data "></a>Remove Data </h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_drain</span><span class="params">(struct evbuffer *buf, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove</span><span class="params">(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Copying-Data"><a href="#Copying-Data" class="headerlink" title="Copying Data"></a>Copying Data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout(struct evbuffer *buf, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen); </span><br><span class="line"><span class="keyword">ev_ssize_t</span> evbuffer_copyout_from(struct evbuffer *buf, <span class="keyword">const</span> struct evbuffer_ptr *pos, <span class="keyword">void</span> *data_out, <span class="keyword">size_t</span> datlen);</span><br></pre></td></tr></table></figure>
<h2 id="Line-oriented-Input"><a href="#Line-oriented-Input" class="headerlink" title="Line-oriented Input"></a>Line-oriented Input</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">evbuffer_readln</span><span class="params">(struct evbuffer *buffer, <span class="keyword">size_t</span> *n_read_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"><span class="comment">// enum evbuffer_eol_style &#123;         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_ANY,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_CRLF,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_CRLF_STRICT,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_LF,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_EOL_NUL </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search</span><span class="params">(struct evbuffer *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_range</span><span class="params">(struct evbuffer *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *what, <span class="keyword">size_t</span> len, <span class="keyword">const</span> struct evbuffer_ptr *start, <span class="keyword">const</span> struct evbuffer_ptr *end)</span></span>; </span><br><span class="line"><span class="function">struct evbuffer_ptr <span class="title">evbuffer_search_eol</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *start, <span class="keyword">size_t</span> *eol_len_out, <span class="keyword">enum</span> evbuffer_eol_style eol_style)</span></span>;</span><br><span class="line"><span class="comment">// struct evbuffer_ptr &#123;         </span></span><br><span class="line"><span class="comment">//     ev_ssize_t pos; </span></span><br><span class="line"><span class="comment">//     struct &#123;                 </span></span><br><span class="line"><span class="comment">//         /* internal fields */        </span></span><br><span class="line"><span class="comment">//     &#125; _internal; </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_ptr_set</span><span class="params">(struct evbuffer *buffer, struct evbuffer_ptr *pos, <span class="keyword">size_t</span> position, <span class="keyword">enum</span> evbuffer_ptr_how how)</span></span>;</span><br><span class="line"><span class="comment">// enum evbuffer_ptr_how &#123;         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_PTR_SET,         </span></span><br><span class="line"><span class="comment">//     EVBUFFER_PTR_ADD </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="Inspecting-data-without-copying-it"><a href="#Inspecting-data-without-copying-it" class="headerlink" title="Inspecting data without copying it"></a>Inspecting data without copying it</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_peek</span><span class="params">(struct evbuffer *buffer, <span class="keyword">ev_ssize_t</span> len, struct evbuffer_ptr *start_at, struct evbuffer_iovec *vec_out, <span class="keyword">int</span> n_vec)</span></span>;</span><br><span class="line"><span class="comment">// struct evbuffer_iovec &#123; </span></span><br><span class="line"><span class="comment">//     void *iov_base;         </span></span><br><span class="line"><span class="comment">//     size_t iov_len; </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="Adding-data-to-an-evbuffer-directly"><a href="#Adding-data-to-an-evbuffer-directly" class="headerlink" title="Adding data to an evbuffer directly"></a>Adding data to an evbuffer directly</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_reserve_space</span><span class="params">(struct evbuffer *buf, <span class="keyword">ev_ssize_t</span> size, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_commit_space</span><span class="params">(struct evbuffer *buf, struct evbuffer_iovec *vec, <span class="keyword">int</span> n_vecs)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Network-IO-with-evbuffers"><a href="#Network-IO-with-evbuffers" class="headerlink" title="Network IO with evbuffers"></a>Network IO with evbuffers</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_write_atmost</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">ev_ssize_t</span> howmuch)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_read</span><span class="params">(struct evbuffer *buffer, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">int</span> howmuch)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Evbuffers-and-callbacks"><a href="#Evbuffers-and-callbacks" class="headerlink" title="Evbuffers and callbacks"></a>Evbuffers and callbacks</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_cb_entry</span>;</span> </span><br><span class="line"><span class="function">struct evbuffer_cb_entry *<span class="title">evbuffer_add_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evbuffer_cb_func)(struct evbuffer *buffer, const struct evbuffer_cb_info *info, void *arg);</span></span><br><span class="line"><span class="comment">// struct evbuffer_cb_info &#123;         </span></span><br><span class="line"><span class="comment">//     size_t orig_size;         </span></span><br><span class="line"><span class="comment">//     size_t n_added;         </span></span><br><span class="line"><span class="comment">//     size_t n_deleted; </span></span><br><span class="line"><span class="comment">// &#125;; </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb_entry</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *ent)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_remove_cb</span><span class="params">(struct evbuffer *buffer, evbuffer_cb_func cb, <span class="keyword">void</span> *cbarg)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVBUFFER_CB_ENABLED 1 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_set_flags</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_cb_clear_flags</span><span class="params">(struct evbuffer *buffer, struct evbuffer_cb_entry *cb, <span class="keyword">ev_uint32_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_defer_callbacks</span><span class="params">(struct evbuffer *buffer, struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Avoiding-data-copies-with-evbuffer-based-IO"><a href="#Avoiding-data-copies-with-evbuffer-based-IO" class="headerlink" title="Avoiding data copies with evbuffer-based IO"></a>Avoiding data copies with evbuffer-based IO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_reference</span><span class="params">(struct evbuffer *outbuf, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> datlen, evbuffer_ref_cleanup_cb cleanupfn, <span class="keyword">void</span> *extra)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evbuffer_ref_cleanup_cb)(const void *data, size_t datalen, void *extra);</span></span><br></pre></td></tr></table></figure>
<h2 id="Adding-a-file-to-an-evbuffer"><a href="#Adding-a-file-to-an-evbuffer" class="headerlink" title="Adding a file to an evbuffer"></a>Adding a file to an evbuffer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_file</span><span class="params">(struct evbuffer *output, <span class="keyword">int</span> fd, <span class="keyword">ev_off_t</span> offset, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Fine-grained-control-with-file-segments"><a href="#Fine-grained-control-with-file-segments" class="headerlink" title="Fine-grained control with file segments"></a>Fine-grained control with file segments</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evbuffer_file_segment</span>;</span> </span><br><span class="line"><span class="function">struct evbuffer_file_segment *<span class="title">evbuffer_file_segment_new</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">ev_off_t</span> offset, <span class="keyword">ev_off_t</span> length, <span class="keyword">unsigned</span> flags)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_file_segment_free</span><span class="params">(struct evbuffer_file_segment *seg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_file_segment</span><span class="params">(struct evbuffer *buf, struct evbuffer_file_segment *seg, <span class="keyword">ev_off_t</span> offset, <span class="keyword">ev_off_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*evbuffer_file_segment_cleanup_cb)</span><span class="params">( struct evbuffer_file_segment <span class="keyword">const</span> *seg, <span class="keyword">int</span> flags, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evbuffer_file_segment_add_cleanup_cb</span><span class="params">(struct evbuffer_file_segment *seg, evbuffer_file_segment_cleanup_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Adding-an-evbuffer-to-another-by-reference"><a href="#Adding-an-evbuffer-to-another-by-reference" class="headerlink" title="Adding an evbuffer to another by reference"></a>Adding an evbuffer to another by reference</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_add_buffer_reference</span><span class="params">(struct evbuffer *outbuf, struct evbuffer *inbuf)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Making-an-evbuffer-add-or-remove-only"><a href="#Making-an-evbuffer-add-or-remove-only" class="headerlink" title="Making an evbuffer add- or remove-only"></a>Making an evbuffer add- or remove-only</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_freeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evbuffer_unfreeze</span><span class="params">(struct evbuffer *buf, <span class="keyword">int</span> at_front)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="14-Connection-listeners-evconnlistener"><a href="#14-Connection-listeners-evconnlistener" class="headerlink" title="14 Connection listeners: evconnlistener "></a>14 Connection listeners: evconnlistener </h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">evutil_socket_t</span> fd)</span></span>; </span><br><span class="line"><span class="function">struct evconnlistener *<span class="title">evconnlistener_new_bind</span><span class="params">(struct event_base *base, evconnlistener_cb cb, <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> flags, <span class="keyword">int</span> backlog, <span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">int</span> socklen)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_free</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evconnlistener_cb)(struct evconnlistener *listener, evutil_socket_t sock, struct sockaddr *addr, int len, void *ptr);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_disable</span><span class="params">(struct evconnlistener *lev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evconnlistener_enable</span><span class="params">(struct evconnlistener *lev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_cb cb, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">evutil_socket_t</span> evconnlistener_get_fd(struct evconnlistener *lev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">evconnlistener_get_base</span><span class="params">(struct evconnlistener *lev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evconnlistener_set_error_cb</span><span class="params">(struct evconnlistener *lev, evconnlistener_errorcb errorcb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*evconnlistener_errorcb)(struct evconnlistener *lis, void *ptr);</span></span><br></pre></td></tr></table></figure>
<p>flag:</p>
<ul>
<li><code>LEV_OPT_LEAVE_SOCKETS_BLOCKING</code></li>
<li><code>LEV_OPT_CLOSE_ON_FREE</code></li>
<li><code>LEV_OPT_CLOSE_ON_EXEC</code></li>
<li><code>LEV_OPT_REUSEABLE</code></li>
<li><code>LEV_OPT_THREADSAFE</code></li>
<li><code>LEV_OPT_DISABLED</code></li>
<li><code>LEV_OPT_DEFERRED_ACCEPT</code></li>
</ul>
<h1 id="15-Use-DNS"><a href="#15-Use-DNS" class="headerlink" title="15 Use DNS"></a>15 Use DNS</h1></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Meng Fanze</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/04/16/libevent笔记/">http://ifanze.cn/2018/04/16/libevent笔记/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>转载请在评论区说明。</li></ul></div><br><div class="tags"><a href="/tags/libevent/">libevent</a><a href="/tags/network/">network</a></div><div class="post-nav"><a class="pre" href="/2018/06/21/《深入理解计算机系统》/">《深入理解计算机系统》</a><a class="next" href="/2018/04/10/《Effective C++》笔记/">《Effective C++》笔记</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'kfIuT7r4gG6hnmNl3uQ5vOqp-gzGzoHsz',
  appKey:'59tx3uBM3K1Ao4JFH5oE3VEK',
  placeholder:'Welcome~',
  avatar:'retro',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ifanze.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/笔记/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/homebrew/" style="font-size: 15px;">homebrew</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/blog/" style="font-size: 15px;">blog</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/《C-Primer》/" style="font-size: 15px;">《C++ Primer》</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/C/" style="font-size: 15px;">C++</a> <a href="/tags/libevent/" style="font-size: 15px;">libevent</a> <a href="/tags/network/" style="font-size: 15px;">network</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://ifanze.cn" title="欢迎友链～" target="_blank">欢迎友链～</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Meng Fanze's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>