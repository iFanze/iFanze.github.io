<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="孟凡泽的博客"><title>libevent笔记 | Meng Fanze's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">libevent笔记</h1><a id="logo" href="/.">Meng Fanze's Blog</a><p class="description">C++、Web、Game</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">libevent笔记</h1><div class="post-meta">Apr 16, 2018</div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Design-Goals"><span class="toc-text">1 Design Goals</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Components"><span class="toc-text">2 Components</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Libraries"><span class="toc-text">3 Libraries</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Headers"><span class="toc-text">4 Headers</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Setup"><span class="toc-text">5 Setup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Log"><span class="toc-text">Log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handle-Error"><span class="toc-text">Handle Error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manage-Memory"><span class="toc-text">Manage Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locks-and-threading"><span class="toc-text">Locks and threading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug"><span class="toc-text">Debug</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Detect-Version"><span class="toc-text">Detect Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Free-global-structures"><span class="toc-text">Free global structures</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-event-base"><span class="toc-text">6 event_base</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Recognized-backend"><span class="toc-text">Recognized backend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Turn-off"><span class="toc-text">Turn off</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#New-amp-free-amp-reinit"><span class="toc-text">New &amp; free &amp; reinit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#New-with-event-config"><span class="toc-text">New with event_config</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#backend"><span class="toc-text">backend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorities"><span class="toc-text">priorities</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Event-loop"><span class="toc-text">7 Event loop</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Run"><span class="toc-text">Run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stop"><span class="toc-text">stop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#internal-time-cache"><span class="toc-text">internal time cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dump-status"><span class="toc-text">dump status</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterate-events"><span class="toc-text">iterate events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#obsolete-methods"><span class="toc-text">obsolete methods</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Events"><span class="toc-text">8 Events</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#conditions"><span class="toc-text">conditions:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#status"><span class="toc-text">status:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#construct"><span class="toc-text">construct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timeout-only-events"><span class="toc-text">Timeout-only events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Signal-events"><span class="toc-text">Signal events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap-allocation-events"><span class="toc-text">Heap-allocation events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pending-and-Non-pending"><span class="toc-text">Pending and Non-pending</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Inspecting-Event-Status"><span class="toc-text">Inspecting Event Status</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#One-off-events"><span class="toc-text">One-off events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manually-activating-an-event"><span class="toc-text">Manually activating an event</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optimizing-common-timeouts"><span class="toc-text">Optimizing common timeouts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Distinguish-an-initialized-event-and-a-cleared-event"><span class="toc-text">Distinguish an initialized event and a cleared event</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Helper"><span class="toc-text">9 Helper</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Types"><span class="toc-text">Basic Types</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timer"><span class="toc-text">Timer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-text">Socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPv6"><span class="toc-text">IPv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Structure"><span class="toc-text">Structure</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Bufferevents"><span class="toc-text">10 Bufferevents</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Type"><span class="toc-text">Type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Watermarks"><span class="toc-text">Watermarks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callbacks"><span class="toc-text">Callbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flags"><span class="toc-text">Flags</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Socket-based-Bufferevents"><span class="toc-text">11 Socket-based Bufferevents</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Create"><span class="toc-text">Create</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Launch"><span class="toc-text">Launch</span></a></li></ol></li></ol></div></div><div class="post-content"><p><a href="https://github.com/nmathewson/libevent-book">https://github.com/nmathewson/libevent-book</a></p>
<a id="more"></a>
<!-- toc -->
<p>Libevent is a library for writing fast portable nonblocking IO. </p>
<h1 id="1-Design-Goals"><a href="#1-Design-Goals" class="headerlink" title="1 Design Goals"></a>1 Design Goals</h1><ul>
<li>Portability</li>
<li>Speed</li>
<li>Scalability</li>
<li>Convenience</li>
</ul>
<h1 id="2-Components"><a href="#2-Components" class="headerlink" title="2 Components"></a>2 Components</h1><ul>
<li>evutil</li>
<li>event &amp; event_base</li>
<li>bufferevent</li>
<li>evbuffer</li>
<li>evhttp</li>
<li>evdns</li>
<li>evrpc</li>
</ul>
<h1 id="3-Libraries"><a href="#3-Libraries" class="headerlink" title="3 Libraries"></a>3 Libraries</h1><ul>
<li>libevent_core</li>
<li>libevent_extra</li>
<li>libevent [outdated]</li>
<li>libevent_pthreads</li>
<li>libevent_openssl</li>
</ul>
<h1 id="4-Headers"><a href="#4-Headers" class="headerlink" title="4 Headers"></a>4 Headers</h1><ul>
<li>API headers</li>
<li>Compatibility headers</li>
<li>Structure headers</li>
</ul>
<h1 id="5-Setup"><a href="#5-Setup" class="headerlink" title="5 Setup"></a>5 Setup</h1><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_log_callback</span><span class="params">(event_log_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_log_cb)(int severity, const char *msg);</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_DEBUG 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_MSG   1</span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_WARN  2 </span></span><br><span class="line"><span class="comment">// #define EVENT_LOG_ERR   3 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_logging</span><span class="params">(<span class="keyword">ev_uint32_t</span> which)</span></span>;</span><br><span class="line"><span class="comment">// #define EVENT_DBG_NONE 0 </span></span><br><span class="line"><span class="comment">// #define EVENT_DBG_ALL 0xffffffffu</span></span><br></pre></td></tr></table></figure>
<h2 id="Handle-Error"><a href="#Handle-Error" class="headerlink" title="Handle Error"></a>Handle Error</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_fatal_callback</span><span class="params">(event_fatal_cb cb)</span></span>;</span><br><span class="line"><span class="comment">// typedef void (*event_fatal_cb)(int err);</span></span><br></pre></td></tr></table></figure>
<h2 id="Manage-Memory"><a href="#Manage-Memory" class="headerlink" title="Manage Memory"></a>Manage Memory</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_set_mem_functions</span><span class="params">(</span></span></span><br><span class="line">    void *(*malloc_fn)(size_t sz),</span><br><span class="line">    <span class="keyword">void</span> *(*realloc_fn)(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> sz),</span><br><span class="line">    <span class="keyword">void</span> (*free_fn)(<span class="keyword">void</span> *ptr));</span><br></pre></td></tr></table></figure>
<h2 id="Locks-and-threading"><a href="#Locks-and-threading" class="headerlink" title="Locks and threading"></a>Locks and threading</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef WIN32</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_windows_threads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #ifdef _EVENT_HAVE_PTHREAD</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_use_pthreads</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// #define EVTHREAD_USE_PTHREADS_IMPLEMENTED </span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_lock_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_lock_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_lock_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int lock_api_version; </span></span><br><span class="line"><span class="comment">//     unsigned supported_locktypes; </span></span><br><span class="line"><span class="comment">//     void *(*alloc)(unsigned locktype); </span></span><br><span class="line"><span class="comment">//     void (*free)(void *lock, unsigned locktype); </span></span><br><span class="line"><span class="comment">//     int (*lock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">//     int (*unlock)(unsigned mode, void *lock); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define EVTHREAD_WRITE  0x04 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_READ   0x08 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_TRY    0x10</span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_RECURSIVE 1 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCKTYPE_READWRITE 2 </span></span><br><span class="line"><span class="comment">// #define EVTHREAD_LOCK_API_VERSION 1 </span></span><br><span class="line"></span><br><span class="line">void evthread_set_id_callback(unsigned long (*id_fn)(void));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evthread_set_condition_callbacks</span><span class="params">(<span class="keyword">const</span> struct evthread_condition_callbacks *)</span></span>;</span><br><span class="line"><span class="comment">// struct evthread_condition_callbacks &#123; </span></span><br><span class="line"><span class="comment">//     int condition_api_version; </span></span><br><span class="line"><span class="comment">//     void *(*alloc_condition)(unsigned condtype); </span></span><br><span class="line"><span class="comment">//     void (*free_condition)(void *cond); </span></span><br><span class="line"><span class="comment">//     int (*signal_condition)(void *cond, int broadcast); </span></span><br><span class="line"><span class="comment">//     int (*wait_condition)(void *cond, void *lock, const struct timeval *timeout); </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evthread_enable_lock_debugging</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_enable_debug_mode</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_debug_unassign</span><span class="params">(struct event *ev)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Detect-Version"><a href="#Detect-Version" class="headerlink" title="Detect Version"></a>Detect Version</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION_NUMBER 0x02000300 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBEVENT_VERSION <span class="meta-string">"2.0.3-alpha"</span> </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_get_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">ev_uint32_t</span> event_get_version_number(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Free-global-structures"><a href="#Free-global-structures" class="headerlink" title="Free global structures"></a>Free global structures</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">libevent_global_shutdown</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="6-event-base"><a href="#6-event-base" class="headerlink" title="6 event_base"></a>6 event_base</h1><h2 id="Recognized-backend"><a href="#Recognized-backend" class="headerlink" title="Recognized backend"></a>Recognized backend</h2><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
<li>kqueue</li>
<li>devpoll</li>
<li>evport</li>
<li>win32</li>
</ul>
<h2 id="Turn-off"><a href="#Turn-off" class="headerlink" title="Turn off"></a>Turn off</h2><ul>
<li>Set environment variables. e.g. <code>EVENT_NOKQUEUE</code>.</li>
<li>Call <code>event_config_avoid_method()</code> below.</li>
</ul>
<h2 id="New-amp-free-amp-reinit"><a href="#New-amp-free-amp-reinit" class="headerlink" title="New &amp; free &amp; reinit"></a>New &amp; free &amp; reinit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_base *<span class="title">event_base_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_free</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_reinit</span><span class="params">(struct event_base *base)</span></span>;      <span class="comment">// call after fork() in child proc</span></span><br><span class="line"><span class="function">struct event_base *<span class="title">event_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;            <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure>
<h2 id="New-with-event-config"><a href="#New-with-event-config" class="headerlink" title="New with event_config"></a>New with event_config</h2><p>To avoid specific available backend by name, or by feature.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event_config *<span class="title">event_config_new</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">struct event_base <span class="title">event_base_new_with_config</span><span class="params">(<span class="keyword">const</span> struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_config_free</span><span class="params">(struct event_config *cfg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_avoid_method</span><span class="params">(struct event_config *cfg,<span class="keyword">const</span> <span class="keyword">char</span> *method)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_require_features</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_method_feature feature)</span></span>;</span><br><span class="line"><span class="comment">// enum event_method_feature &#123;     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_ET = 0x01,     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_O1 = 0x02,     </span></span><br><span class="line"><span class="comment">//     EV_FEATURE_FDS = 0x04, </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_flag</span><span class="params">(struct event_config *cfg, <span class="keyword">enum</span> event_base_config_flag flag)</span></span>;</span><br><span class="line"><span class="comment">// enum event_base_config_flag &#123;</span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NOLOCK = 0x01,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_IGNORE_ENV = 0x02, </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_STARTUP_IOCP = 0x04,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_NO_CACHE_TIME = 0x08,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST = 0x10,     </span></span><br><span class="line"><span class="comment">//     EVENT_BASE_FLAG_PRECISE_TIMER = 0x20 </span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_num_cpus_hint</span><span class="params">(struct event_config *cfg, <span class="keyword">int</span> cpus)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_config_set_max_dispatch_interval</span><span class="params">(struct event_config *cfg, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> struct timeval *max_interval, <span class="keyword">int</span> max_callbacks, <span class="keyword">int</span> min_priority)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">event_get_supported_methods</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">event_base_get_method</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">enum</span> event_method_feature <span class="title">event_base_get_features</span><span class="params">(<span class="keyword">const</span> struct event_base *base)</span></span>;</span><br><span class="line">event_get_method()          <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure>
<h2 id="priorities"><a href="#priorities" class="headerlink" title="priorities"></a>priorities</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_priority_init</span><span class="params">(struct event_base *base, <span class="keyword">int</span> n_priorities)</span></span>;    <span class="comment">// 1 ~ EVENT_MAX_PRIORITIES</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_get_npriorities</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line">event_priority_init()       <span class="comment">// [obsolete]</span></span><br></pre></td></tr></table></figure>
<h1 id="7-Event-loop"><a href="#7-Event-loop" class="headerlink" title="7 Event loop"></a>7 Event loop</h1><h2 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h2><p>default: run until no more events registered in it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loop</span><span class="params">(struct event_base *base, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_dispatch</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"><span class="comment">// #define EVLOOP_ONCE             0x01 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NONBLOCK         0x02 </span></span><br><span class="line"><span class="comment">// #define EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></span><br></pre></td></tr></table></figure>
<h2 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopexit</span><span class="params">(struct event_base *base, <span class="keyword">const</span> struct timeval *tv)</span></span>;     <span class="comment">// exit after all active events cb done.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopbreak</span><span class="params">(struct event_base *base)</span></span>;  <span class="comment">// exit after current one cb done.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_exit</span><span class="params">(struct event_base *base)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_got_break</span><span class="params">(struct event_base *base)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_loopcontinue</span><span class="params">(struct event_base *)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="internal-time-cache"><a href="#internal-time-cache" class="headerlink" title="internal time cache"></a>internal time cache</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_gettimeofday_cached</span><span class="params">(struct event_base *base, struct timeval *tv_out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_update_cache_time</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="dump-status"><a href="#dump-status" class="headerlink" title="dump status"></a>dump status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_base_dump_events</span><span class="params">(struct event_base *base, FILE *f)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="iterate-events"><a href="#iterate-events" class="headerlink" title="iterate events"></a>iterate events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_base_foreach_event</span><span class="params">(struct event_base *base, event_base_foreach_event_cb fn, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">// typedef int (*event_base_foreach_event_cb)(const struct event_base *, const struct event *, void *)</span></span><br></pre></td></tr></table></figure>
<h2 id="obsolete-methods"><a href="#obsolete-methods" class="headerlink" title="obsolete methods"></a>obsolete methods</h2><ul>
<li><code>event_dispatch()</code></li>
<li><code>event_loop()</code></li>
<li><code>event_loopexit()</code></li>
<li><code>event_loopbreak()</code></li>
</ul>
<h1 id="8-Events"><a href="#8-Events" class="headerlink" title="8 Events"></a>8 Events</h1><h2 id="conditions"><a href="#conditions" class="headerlink" title="conditions:"></a>conditions:</h2><ul>
<li>fd being ready to read from or write to.</li>
<li>fd becoming ready to read from or write to (Edge-triggered IO only).</li>
<li>a timeout expiring.</li>
<li>a signal occuring.</li>
<li>a user-triggered event.</li>
</ul>
<h2 id="status"><a href="#status" class="headerlink" title="status:"></a>status:</h2><ul>
<li>initialized -&gt; pending (by <code>add</code>)</li>
<li>pending -&gt; active (condition trigger an event occur, cb run)</li>
<li>active -&gt; pending (persistent) -&gt; <code>delete</code> -&gt; non-pending -&gt; <code>add</code> -&gt; pending</li>
<li>active -&gt; non-pending (non-persistent)</li>
</ul>
<h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event *<span class="title">event_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> what, event_callback_fn cb, <span class="keyword">void</span> *arg)</span></span>; </span><br><span class="line"><span class="comment">// typedef void (*event_callback_fn)(evutil_socket_t, short, void *); </span></span><br><span class="line"><span class="comment">// #define EV_TIMEOUT      0x01 </span></span><br><span class="line"><span class="comment">// #define EV_READ         0x02 </span></span><br><span class="line"><span class="comment">// #define EV_WRITE        0x04 </span></span><br><span class="line"><span class="comment">// #define EV_SIGNAL       0x08 </span></span><br><span class="line"><span class="comment">// #define EV_PERSIST      0x10 </span></span><br><span class="line"><span class="comment">// #define EV_ET           0x20 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_free</span><span class="params">(struct event *event)</span></span>;</span><br></pre></td></tr></table></figure>
<p>You can’t create an event that receives itself as a cb argument. Instead:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_self_cbarg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Timeout-only-events"><a href="#Timeout-only-events" class="headerlink" title="Timeout-only events"></a>Timeout-only events</h2><p>no benefit beyond clarifying your code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(base, callback, arg) \     </span></span><br><span class="line">event_new((base), <span class="number">-1</span>, <span class="number">0</span>, (callback), (arg)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_add(ev, tv) \    </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_pending(ev, tv_out) \     </span></span><br><span class="line">event_pending((ev), EV_TIMEOUT, (tv_out))</span><br></pre></td></tr></table></figure>
<h2 id="Signal-events"><a href="#Signal-events" class="headerlink" title="Signal events"></a>Signal events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(base, signum, cb, arg) \     </span></span><br><span class="line">event_new(base, signum, EV_SIGNAL|EV_PERSIST, cb, arg)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_add(ev, tv) \     </span></span><br><span class="line">event_add((ev),(tv)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_del(ev) \     </span></span><br><span class="line">event_del(ev) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_pending(ev, what, tv_out) \     </span></span><br><span class="line">event_pending((ev), (what), (tv_out))</span><br></pre></td></tr></table></figure>
<ul>
<li>Don’t set a timeout on a signal event.</li>
<li>It’s safe to call functions that you aren’t supposed to call from a regulat POSIX signal handler.</li>
<li>With most backends, only one event_base per process at a time can be listening for signals. If you add signal events to two event_base at once - even if the signals are different - only one event_base will receive signals. (kqueue doesn’t have this limitation.)</li>
</ul>
<h2 id="Heap-allocation-events"><a href="#Heap-allocation-events" class="headerlink" title="Heap-allocation events"></a>Heap-allocation events</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int event_assign(struct event *event, struct event_base *base, evutil_socket_t fd, short what, void (*callback)(evutil_socket_t, short, void *), void *arg);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_assign(event, base, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, <span class="number">-1</span>, <span class="number">0</span>, callback, arg) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_assign(event, base, signum, callback, arg) \     </span></span><br><span class="line">event_assign(event, base, signum, EV_SIGNAL|EV_PERSIST, callback, arg)</span><br></pre></td></tr></table></figure>
<ul>
<li>Your code won’t be binary-compatible with future versions of libevent as the size of a event may differ. To check, make use of this function:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> event_get_struct_event_size(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>May return a value less than <code>sizeof(event)</code> because of padding bytes at the end.</li>
<li>Never call <code>event_assign</code> on an event that is already pending. call <code>event_del()</code> first.</li>
</ul>
<h2 id="Pending-and-Non-pending"><a href="#Pending-and-Non-pending" class="headerlink" title="Pending and Non-pending"></a>Pending and Non-pending</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *tv)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_del</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_remove_timer</span><span class="params">(struct event *ev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_priority_set</span><span class="params">(struct event *event, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Inspecting-Event-Status"><a href="#Inspecting-Event-Status" class="headerlink" title="Inspecting Event Status"></a>Inspecting Event Status</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_pending</span><span class="params">(<span class="keyword">const</span> struct event *ev, <span class="keyword">short</span> what, struct timeval *tv_out)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> event_get_signal(ev) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> event_get_fd(<span class="keyword">const</span> struct event *ev); </span><br><span class="line"><span class="function">struct event_base *<span class="title">event_get_base</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">event_get_events</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function">event_callback_fn <span class="title">event_get_callback</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">event_get_callback_arg</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; <span class="function"><span class="keyword">int</span> <span class="title">event_get_priority</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_get_assignment</span><span class="params">(<span class="keyword">const</span> struct event *event, struct event_base **base_out, <span class="keyword">evutil_socket_t</span> *fd_out, <span class="keyword">short</span> *events_out, event_callback_fn *callback_out, <span class="keyword">void</span> **arg_out)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct event *<span class="title">event_base_get_running_event</span><span class="params">(struct event_base *base)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="One-off-events"><a href="#One-off-events" class="headerlink" title="One-off events"></a>One-off events</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int event_base_once(struct event_base *, evutil_socket_t, short, void (*)(evutil_socket_t, short, void *), void *, const struct timeval *);</span><br></pre></td></tr></table></figure>
<ul>
<li>If you don’t need to add an event more than once, or delete it once it has been added, and it doesn’t have to persistent, use <code>event_base_once</code>.</li>
<li>It doesn’t support <code>EV_SIGNAL</code> or <code>EV_PERSIST</code>.</li>
<li>Can’t be deleted or manually activated.</li>
</ul>
<h2 id="Manually-activating-an-event"><a href="#Manually-activating-an-event" class="headerlink" title="Manually activating an event"></a>Manually activating an event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_active</span><span class="params">(struct event *ev, <span class="keyword">int</span> what, <span class="keyword">short</span> ncalls)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Don’t calling <code>event_active</code> recursively on the same event.</li>
</ul>
<h2 id="Optimizing-common-timeouts"><a href="#Optimizing-common-timeouts" class="headerlink" title="Optimizing common timeouts"></a>Optimizing common timeouts</h2><ul>
<li>Libevent use a binary algorithm to keep track of pending events’ timeouts, which gives performance of O(lg n) for adding and deleting each event timeout.</li>
<li>If you have a large number of events with the same timeout, a doubly-linked queue will be better.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> struct timeval *<span class="title">event_base_init_common_timeout</span><span class="params">( struct event_base *base, <span class="keyword">const</span> struct timeval *duration)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Distinguish-an-initialized-event-and-a-cleared-event"><a href="#Distinguish-an-initialized-event-and-a-cleared-event" class="headerlink" title="Distinguish an initialized event and a cleared event"></a>Distinguish an initialized event and a cleared event</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_initialized</span><span class="params">(<span class="keyword">const</span> struct event *ev)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_initialized(ev) event_initialized(ev) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_initialized(ev) event_initialized(ev)</span></span><br></pre></td></tr></table></figure>
<h1 id="9-Helper"><a href="#9-Helper" class="headerlink" title="9 Helper"></a>9 Helper</h1><h2 id="Basic-Types"><a href="#Basic-Types" class="headerlink" title="Basic Types"></a>Basic Types</h2><ul>
<li><p>evutil_socket_t  </p>
</li>
<li><p>ev_uint64_t       EV_UINT64_MAX       0</p>
</li>
<li>ev_int64_t        EV_INT64_MAX        EV_INT64_MIN</li>
<li>ev_uint32_t       EV_UINT32_MAX       0</li>
<li>ev_int32_t        EV_INT32_MAX        EV_INT32_MIN</li>
<li>ev_uint16_t       EV_UINT16_MAX       0</li>
<li>ev_int16_t        EV_INT16_MAX        EV_INT16_MIN</li>
<li>ev_uint8_t        EV_UINT8_MAX        0</li>
<li><p>ev_int8_t         EV_INT8_MAX         EV_INT8_MIN</p>
</li>
<li><p>ev_ssize_t        EV_SSIZE_MIN        EV_SSIZE_MAX</p>
</li>
<li>ev_off_t          </li>
<li>ev_socket_t</li>
<li>ev_intptr_t</li>
<li>ev_uintptr_t</li>
</ul>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timeradd(tvp, uvp, vvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timersub(tvp, uvp, vvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerclear(tvp) <span class="comment">/* ... */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timerisset(tvp) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_timercmp(tvp, uvp, cmp)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_gettimeofday</span><span class="params">(struct timeval *tv, struct timezone *tz)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_closesocket</span><span class="params">(<span class="keyword">evutil_socket_t</span> s)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_CLOSESOCKET(s) evutil_closesocket(s)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SOCKET_ERROR() </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVUTIL_SET_SOCKET_ERROR(errcode) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_geterror(sock) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_socket_error_to_string(errcode)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_nonblocking</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_listen_socket_reuseable</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_make_socket_closeonexec</span><span class="params">(<span class="keyword">evutil_socket_t</span> sock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_socketpair</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">evutil_socket_t</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ev_int64_t</span> evutil_strtoll(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">char</span> **endptr, <span class="keyword">int</span> base);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_snprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_vsnprintf</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strcasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_ascii_strncasecmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">evutil_inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> len)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_parse_sockaddr_port</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, struct sockaddr *out, <span class="keyword">int</span> *outlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_sockaddr_cmp</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa1, <span class="keyword">const</span> struct sockaddr *sa2, <span class="keyword">int</span> include_port)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evutil_offsetof(type, field) <span class="comment">/* ... */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_get_bytes</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evutil_secure_rng_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evutil_secure_rng_add_bytes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dat, <span class="keyword">size_t</span> datlen)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="10-Bufferevents"><a href="#10-Bufferevents" class="headerlink" title="10 Bufferevents"></a>10 Bufferevents</h1><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><ul>
<li>socket-based bufferevents</li>
<li>asynchronous-IO bufferevents (Windows only, experimental)</li>
<li>filtering bufferevents</li>
<li>paired bufferevents</li>
</ul>
<h2 id="Watermarks"><a href="#Watermarks" class="headerlink" title="Watermarks"></a>Watermarks</h2><ul>
<li>Read low-water mark</li>
<li>Read high-water mark</li>
<li>Write low-water mark</li>
<li>Write high-water mark</li>
</ul>
<h2 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a>Callbacks</h2><ul>
<li><code>BEV_EVENT_READING</code></li>
<li><code>BEV_EVENT_WRITING</code></li>
<li><code>BEV_EVENT_ERROR</code></li>
<li><code>BEV_EVENT_TIMEOUT</code></li>
<li><code>BEV_EVENT_EOF</code></li>
<li><code>BEV_EVENT_CONNECTED</code></li>
</ul>
<h2 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h2><ul>
<li><code>BEV_OPT_CLOSE_ON_FREE</code></li>
<li><code>BEV_OPT_THREADSAFE</code></li>
<li><code>BEV_OPT_DEFER_CALLBACKS</code></li>
<li><code>BEV_OPT_UNLOCK_CALLBACKS</code></li>
</ul>
<h1 id="11-Socket-based-Bufferevents"><a href="#11-Socket-based-Bufferevents" class="headerlink" title="11 Socket-based Bufferevents"></a>11 Socket-based Bufferevents</h1><h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct bufferevent *<span class="title">bufferevent_socket_new</span><span class="params">(struct event_base *base, <span class="keyword">evutil_socket_t</span> fd, <span class="keyword">enum</span> bufferevent_options options)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>fd 需要时 non-blocking 的，可以使用<code>evutil_make_socket_nonblocking()</code>。</li>
<li>不想现在指定 fd 可以将其设为 -1。</li>
</ul>
<h2 id="Launch"><a href="#Launch" class="headerlink" title="Launch"></a>Launch</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bufferevent_socket_connect</span><span class="params">(struct bufferevent *bev, struct sockaddr *address, <span class="keyword">int</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a href="/2018/04/10/《C++ Primer》笔记/" class="next">《C++ Primer》笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://ifanze.cn"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/16/libevent笔记/">libevent笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/10/《C++ Primer》笔记/">《C++ Primer》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/Docker-CheatSheet/">Docker CheatSheet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/macOS-CheatSheet/">macOS CheatSheet</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/23/macOS-重装与软件管理/">macOS 重装与软件管理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Meng Fanze's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>